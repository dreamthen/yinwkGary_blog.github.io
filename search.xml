<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[足球团队前端代码review与规范]]></title>
    <url>%2F2019%2F12%2F05%2F%E8%B6%B3%E7%90%83%E5%9B%A2%E9%98%9F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81review%E4%B8%8E%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一、Git提交注释部分(git comment -m ‘?’)，建议规范起来。 原因 首先比较重要的一点就是，当出现代码合并冲突问题或者代码合并合漏的情况，可以根据注释模板标识来进行查找，具体的人具体的提交版本可以一目了然，不必打扰其他相关的人；其次就是分支回滚时，可以清楚的看出回滚位置，做到很便捷的回滚；最后一点，能清晰的反应开发者这一个周都做了什么，更利于开发者回顾这一个周业务或者技术开发，再现实点儿的意义就是便于写周报，😄 为此，我在我们足球业务组内部制定了一套注释草案，请大家建议、提意见或者查漏补缺: 12345678910111213141516171819202122//我们以type:description形式来写注释，中间的:表达的是在某一种类型下，提交的某某某版本注释开发业务 'business:xxx'修改bug 'fix:xxx'优化 'optimize:xxx’追加文档 'doc:xxx'生态搭建 'build:xxx’样式修改 'style:xxx'重写 'rewrite:xxx'单元测试 'test:xxx'//这里面是有交集冲突的，比如: //如果只改了样式，而没有动任何其他的配置，那就是style:xxx//但如果改了样式又改了其他的部分，是要按照当时业务场景来看的，可能是business、fix、optimize、rewrite等等//以此类推，就是当单纯改了某一个分类，就按照分类算，但如果改了不同的分类，那就按照业务场景来看。//有的小伙伴英语不好，多学几个单词感觉费劲，咱也有中文版:开发业务 '业务:xxx'修改bug '问题:xxx'优化 '优化:xxx'追加文档 '文档:xxx'生态搭建 '生态:xxx'样式修改 '样式:xxx'重写 '重写:xxx'单元测试 '测试:xxx' 二、Jenkins发布系统步骤 原因 也就是为什么要有这个系统。我们的前端打包之后的文件实际上就是一些静态资源，开发人员每一次都要打包，而且还要上传到gitlab上面，静态资源是不应该放到gitlab代码管理库里面去的，有了这个发布系统，直接交给流程机器人进行打包处理，并自动发布到SIT、STG和PRD的环境上面，减少了人工的打包以及手动拉到服务器上面的时间，且静态资源也是分发到OSS静态资源服务器上面，可谓物归其所地。 步骤 打开http://ticket.hupu.io/desk/这个发布工单的系统，如果是创建一个新的项目应用，无论是后台还是前端，选择”新应用申请”，申请一个新项目应用，申请就会耗一些时间，运维老大会对你申请的这个应用提出意见，比如应用名字等等，按照规范改，之后要找不同的人(王节红(运维老大)跟他说你这个应用的gitlab所在地址等等确认、邰鹏(拓海CBA官网的运维负责人)的确认)，最后新应用上线完成。 之后，需要进行前端配置，由于OSS只放html文件，打包后的静态文件（CSS、JS等），需要放入W1服务器，OSS不支持CDN加速，而W1服务器实际上就是一个CDN服务器，所以需要配置webpack中的publicPath，访问静态文件需要使用w1的域名，路径为:http://w1.hoopchina.com.cn/games/static/项目名。 缺点 当然也存在比较多的缺点，和前端小伙伴讨论的过程中，发现这个发布系统，只能单线程发布，对于多线程提交工单，并不支持，且进行提交工单的分支必须为release，所以当多人项目发布不同的功能点时，由于提交的时间点不同，当一人提交上去，另外的小伙伴就只能等着，等待这人的功能测试完全上线，才可以提交第二个工单，这样效率实际上是大大降低的。 优化建议 和小伙伴商量之后，希望发布工单系统可以支持多分支提交工单，不只依赖于release分支，可以选择多个分支并入release分支，既可以勾选并入，也可以消除勾选移除，发布时，先检测是否存在冲突，解决完冲突之后，再发布至release，release分支发至sit和stg环境，待测试测完之后，再选择prd发布至线上并合入master分支（想法gitlab上的项目默认接入ci/cd，可以暴露gitlab的菜单选项，针对于某一个项目自定义自己的发布工单系统）。 三、表单校验插件能在我们业务前端内使用 原因 抛弃之前的if else冗长的判断逻辑，将其集成插件使用，减少项目代码的冗余，提高规则插件的可复用性，此插件符合设计模式单一职责以及开放封闭的原则，使用策略模式来编写。 原理 此插件是以校验规则为基则，支持添加一或多个校验变量对应一或多个校验规则，来实现一对一、多对一、一对多和多对多的校验方式，数据类型支持数组或者是字符串，校验规则可以自定义，且对出现异常或者问题时的提示语，也支持type:提示异常语的形式来弹出或者飞入等自定义形式提示异常。 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344import verify from "../utils/verify";const &#123;phone, code, password, passwordConfirm&#125; = this.state;return verify.addRule([ phone, code, password, passwordConfirm], [&#123; rule: 'isEmpty', errMsg: [ 'warning:请输入手机号', 'warning:请输入正确的验证码', 'warning:请输入6-16位密码', 'warning:请输入6-16位确认密码' ]&#125;]).addRule( phone, [&#123; rule: 'isPhone:^1[3|4|5|6|7|8|9]\\d&#123;9&#125;$', errMsg: [ 'warning:输入的手机号不符合标准' ] &#125;]).addRule( password, [&#123; rule: 'passwordBit:6', errMsg: [ 'warning:请输入6-16位密码' ] &#125;]).addRule( password, [&#123; rule: 'passwordReg:^[\\w]+$', errMsg: [ 'warning:请输入数字或者字母' ] &#125;]).addRule( password, [&#123; rule: `isConfirm:$&#123;passwordConfirm&#125;`, errMsg: [ 'warning:两次输入得密码不一致' ]&#125;]).execute(); 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//表单校验插件let verify = (function () &#123; const ruleMap = new WeakMap(); const rulesList = &#123; //校验输入框是否为空 isEmpty(val, type, errMsg) &#123; if ((!val &amp;&amp; val !== 0) || val.length &lt;= 0) &#123; return &#123; type, errMsg &#125;; &#125; return false; &#125;, //校验密码和确认密码是否相同 isConfirm(val, confirmVal, type, errMsg) &#123; if (val !== confirmVal) &#123; return &#123; type, errMsg &#125;; &#125; return false; &#125;, //校验密码长度 passwordBit(val, length, type, errMsg) &#123; if (val.length &lt; length) &#123; return &#123; type, errMsg &#125;; &#125; return false; &#125;, //校验密码是否是只有数字或者字母 passwordReg(val, reg, type, errMsg) &#123; let _reg = new RegExp(reg, 'g'); if(!_reg.test(val)) &#123; return &#123; type, errMsg &#125;; &#125; return false; &#125;, //校验手机号码 isPhone(val, reg, type, errMsg) &#123; let _reg = new RegExp(reg); if(!_reg.test(val)) &#123; return &#123; type, errMsg &#125;; &#125; return false; &#125; &#125;; class Verify &#123; constructor() &#123; ruleMap.set(this, []); &#125; /** * 添加校验规则 * @param vals * @param rules * @returns &#123;Verify&#125; */ addRule = (vals, rules) =&gt; &#123; const mapList = ruleMap.get(this); vals = (Object.prototype.toString.call(vals) === "[object Array]") ? vals : [vals]; for (let [key, val] of vals.entries()) &#123; rules.forEach(ruleItem =&gt; &#123; mapList.push(() =&gt; &#123; let &#123;rule, errMsg&#125; = ruleItem; const operation = rule.split(":"); errMsg = errMsg instanceof Array ? errMsg : [errMsg]; const currentErrMsg = errMsg[key]; const method = operation.shift(); operation.unshift(val); operation.push(...currentErrMsg.split(":")); return rulesList[method](...operation); &#125;); &#125;); &#125; ruleMap.set(this, mapList); return this; &#125;; /** * 进行校验 * @returns &#123;boolean|*&#125; */ execute = () =&gt; &#123; const mapList = ruleMap.get(this); let msg; for (let mapVal of mapList.values()) &#123; if ((msg = mapVal())) &#123; this.clear(); return msg; &#125; &#125; this.clear(); return false; &#125;; /** * 将校验规则的方法都清除掉 */ clear = () =&gt; &#123; ruleMap.set(this, []); &#125;; &#125; return new Verify();&#125;)();export default verify; 四、目录结构 原因 建立一个生态，最重要的就是目录结构，一个好的目录结构，能够使开发的效率变高，省去过多的查找目录、路径和文件的时间，而开发一个生态或者一个项目，往往是要和业务连接起来的，所以目录结构有必要与业务紧密相连。 详情 我们足球业务项目，建议采用umi的那种目录结构，配合业务界面的组件，无论是业务组件(不包含公用组件)、业务样式、私有业务样式变量，还是redux的行为action、触发redux action行为产生数据处理并返回的reducer、私有静态常量、私有工具，都放入和业务界面组件同一个目录路径下，这样在开发某一个界面的业务时，就不需要返回上一级甚至于根目录下寻找这些业务可能必备的样式、组件、工具、action、reducer和静态变量。 而公有的部分则放入到盛装业务界面组件根路径的外部，比如静态图片、文字字体、音频和视频资源、公有的样式、公有的样式变量、公有的工具和组件以及公有的静态常量，都放入外部，分目录盛装，名字叫啥就不建议了，最起码要语义清晰且常用，让人能够比较容易的理解。 五、react state和props的使用 概括 state花心,props专一 ; state如此善变,props始终如一 使用 在还没有redux统一管理数据的年代,我们一般使用state来承接变量,在一个组件的内部,我们一般使用state来控制这个组件的喜怒哀乐和言行举止,控制器呢,就是setState;但是当组件套用时,父子关系呈现出来,父组件发现没办法传授和教育子组件一些经验和知识,因为组件都是有血有肉有自己意识的,所以只能强制,父组件通过传入自己的state,来改变子组件的一些坏习惯,俗话说得好,“小树不修不直溜,人不修理哏啾啾”,自然在子组件还没有成熟时,传入子组件内部的父组件state(也就是子组件props),子组件是无法修改的,只能听之任之,接受洗礼,但是当子组件变成熟,父组件变老,子组件想要改变父组件的需求也就自然显示出来,那如何能修改呢,只能劝父组件授权给他,以为父组件好的名义,父组件听到了心里,觉得”儿啊，长大了，懂事了”,直接给予子组件一个方法,这个方法行为直接可以改变父组件的state生活行为,而这个方法是子组件控制的。 故state承接的是变量,而props只是state在父子传递state时的桥梁,桥梁是不可妄动的。 建议state中不要放入常量,如果嫌某常量只是在本组件内使用或者嫌重新建一个静态常量文件麻烦,那就直接使用组件内部的this.constants = {number: ‘这是常量’};或者不放入到react组件内,直接在文件顶部加一个const constants = {number: ‘这是常量’};也是可以的。 六、react事件 定义 事件往往代表一个对象、一个组件和一套工具的行为,而react事件的演化从初始阶段的bind显示硬绑定,至中期的箭头函数,直至现阶段比较好的箭头函数配合data-propsType属性的方式。 前期bind硬绑定 在前期,我们既希望事件函数的this指向React组件对象本身,又希望可以传递某些数据状态,且this不要指向事件所绑定的元素dom或者react虚拟dom，在这时候，我们选择了bind硬绑定,事件.bind(this, params)酱紫,但是发现这样大抵是为内存泄漏埋下了隐患。 我们先看一下模拟bind的js源代码: 1234567891011121314Function.prototype.bind = function(context) &#123; let _this = this, fBind, args = [...arguments]; function F() &#123;&#125; fBind = function () &#123; const newArgs = [...args, ...arguments]; return _this.apply(this instanceof fBind ? this : context, newArgs); &#125;; //这里让返回的函数的隐式原型指向其绑定的事件函数的显式原型 F.prototype = _this.prototype; fBind.prototype = new F(); return fBind;&#125;; 这样就是一个完整的bind硬绑定的函数，基于Function函数对象的原型链上面，但是大家可以看到，bind硬绑定形成了一个闭包，fBind的这个函数对象，在异步机制中的内存当中是一直存在的。那就意味着，我硬绑定多个事件，就会形成多个闭包，这样迟早会形成内存泄漏，实在是不可取的一个方式。 中期的箭头函数与现阶段的箭头函数配合data-propsType属性 对于箭头函数，我们极为熟悉，不能改变其this的指向、无arguments类参数数组、不能使用new绑定构造调用和引用关联以及不能使用super继承。这样既写法简单，this的指向又解决了，指向React组件对象本身，且不指向事件所绑定的元素dom或者react虚拟dom。那么参数如何传入呢，当然你如果不嫌麻烦，可以这样: harmony1234567&lt;div onClick=&#123;(e) =&gt; &#123; const type = 'me'; //这个就是你定义的箭头函数 onChangeHandler(type, e);&#125;&#125;&gt; 来吧，点击&lt;/div&gt; 但是太过麻烦，每次都要内部一个箭头函数，在外面又要再定义一个封装的箭头函数，感觉有点儿烦。所以我们可以利用自定义属性的方法，来解决这个问题。 harmony1234567891011121314151617class Demo extends React.Component&#123; onChangeHandler = (e) =&gt; &#123; const &#123;target&#125; = e || &#123;&#125;; const type = target.getAttribute('data-type'); console.log(type); &#125;; render() &#123; return ( &lt;div onClick=&#123; data-type='me' onChangeHandler &#125;&gt; 来吧，点击 &lt;/div&gt; ); &#125; &#125; 这种箭头函数配合data-propsType属性的方式，简易实用，是现阶段比较好的事件实现过程。 七、添加注释 详情 注释是体现一个好的开发人员素养的标识,好且有效的注释在多人团队同时开发过程中的垫脚石,所以建议小伙伴们,无论是在业务逻辑还是技术逻辑比较复杂的部分,做好详细的注释,复杂技术逻辑只要讲清楚代码逻辑即可,而复杂业务逻辑,就需要讲业务的背景讲清楚,即是什么、为什么详细的表达明白。]]></content>
      <categories>
        <category>review与规范</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Javascript]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Javascript%2F</url>
    <content type="text"><![CDATA[&lt;上篇&gt;整理: 词法作用域、this以及原型对象一、词法作用域 浏览器执行JavaScript语言 在浏览器引擎执行JS之前,JS就已经经过了浏览器编译器的编译,也就是词法分析和语法分析,将关键字、保留字、自定义变量以及函数根据词法解释和抽象语法树进行解析,并且按照优先级和词法作用域放到应有的位置上,最后通过浏览器引擎执行 词法分析 词法分析分为: 分词和词法解释。 分词就是将各个表达式根据空格分开,再根据关键字、保留字等词法进行匹配词法解释。 语法分析 语法分析就是根据抽象语法树上面的语法解释,类型、强制类型转换、ToNumber、ToString和ToPrometive等泛泛含义对表达式解构。 引擎执行 词法分析和语法分析之后,浏览器就会将已经编译好的JS代码,交给引擎执行。 LHS、RHS 词法作用域限定了变量和函数产生效果的范围,分为三种: 全局作用域、函数作用域以及块级作用域(ES6引入),为了更好的理解这三种作用域,以及其中变量和函数的定义与赋值,从概念上引入了LHS和RHS,用来解释引擎执行时,变量的赋值目标以及赋值操作的源头 LHS: 赋值操作的目标是谁 RHS: 谁才是赋值操作的源头 例子 //定义foo函数为LHS;获取变量a为RHS;var b = 为LHS;获取变量a和b为RHS function foo(a) { var b = a; return a + b; } //var c = 为LHS;foo(10)为RHS;将实参10赋值给虚参a为LHS var c = foo(10); //console.log为RHS;获取变量c为RHS console.log(c); //五个表达式中,共有四个LHS和五个RHS 词法作用域链 简单来说,作用域链使内部作用域内的变量和函数变成了私密且不可访问的,保证了内部变量不会污染到全局以及外部作用域,以免造成变量名冲突等不可预知的错误,外部作用域是访问不到以及操作不到的,而内部作用域的优先级却是越来越高,可以访问和操作到自己以及外部N层作用域的变量和函数 例子 var a = &quot;hello&quot;; function foo() { var b = &quot;world&quot;; //foo函数作用域,可以访问到和操作到a,这里打印&quot;hello&quot; console.log(a); function bar() { var c = &quot;wenkai.yin&quot;; //bar函数作用域,可以访问到和操作到c,b,a,这里打印&quot;wenkai.yin&quot; &quot;world&quot; &quot;hello&quot; console.log(c, b, a); } bar(); //这里报错ReferrenceError c is not defined //因为foo函数作用域中访问不到和操作不到优先级最高的bar函数作用域中的私密变量c, //且在本作用域下找不到变量c,由此向外部作用域,也就是全局作用域中查找变量c,发现c并没有定义,更别说给c赋值了, //所以这时候会报ReferrenceError c is not defined console.log(c); } foo(); 变量提升 综上所述,变量和函数的定义是在浏览器编译器编译时,具体应该是在词法分析的词法解释时,就已经定义好了变量和函数的位置,之后的引擎执行才是进行赋值,由此会出现变量提升的情况 例子一 console.log(a); var a = 14; //这里打印的值为undefined,这里不会报错,因为变量a已经在浏览器编译中就定义了,执行顺序应该是: //var a; //console.log(a); //a = 14; 例子二 a = 14; var a; console.log(a); //这里打印的值为14,执行顺序应该是: //var a; //a = 14; //console.log(a); 例子三 console.log(a); let a = 14; //这里会直接报错ReferrenceError a is not defined //因为在ES6中let和const不会出现变量提升,let和const并不只是为了进行区分变量和常量才产生的 //其核心是为了产生块级作用域,块级作用域也遵从词法作用域的规则以及作用域链,所以才不会出现变量提升 //实际执行结果应该是: //console.log(a); //{ // let a = 14; //} //这时候全局作用域中是没办法访问和操作块级作用域中的变量a的,由此判断a未定义,才会报错ReferrenceError a is not defined 例子四 if(a in window) { var a = 10; } console.log(a); //这里会直接打印:10 //这里是存在变量提升的概念的,变量a的定义是在浏览器编译的词法分析的词法解释时,就已经确定了a的位置,所以变量在window对象中是存在的 //实际浏览器引擎执行结果应该是: //var a; //if(a in window) { // a = 10; //} //console.log(a); eval和with eval通过将字符串转换为Javascript语句和表达式,来改变某个词法作用域;with通过创造词法作用域,使得某个对象属性获得with词法作用域中变量的值 例子一 var b = &quot;bigger&quot;; function foo(sentence) { eval(sentence); console.log(b); } foo(&quot;var b = &apos;smaller&apos;&quot;); //这里打印smaller,本来foo的词法作用域中是不存在变量b的,而eval改变了foo的词法作用域,使得foo词法作用域中出现了变量b 例子二 var obj = {a: &quot;foo&quot;, b: &quot;bar&quot;}; with(obj) { a = &quot;bar&quot;; b = &quot;foos&quot;; } console.log(obj); //这里打印{a: &quot;bar, b: &quot;foos&quot;},with创造了词法作用域,使得其中的变量赋值操作是私密的,不可访问且不可操作的 console.log(a); console.log(b); //变量a和b在全局作用域中都没有定义,只有在with创造的作用域下,进行赋值, //所以这里会报错:ReferrenceError a is not defined;ReferrenceError b is not defined eval由于对字符串词法和语法分析比较复杂,字符串中的变量和表达式会永久的保留在内存中的,不会被浏览器垃圾回收机制回收,会造成网站的性能较差的原因,被官方不推荐使用;而with由于也会造成网站性能变差,并且没有必要使用with改变对象属性值的原因,被官方列为禁用表达式语句 作用域与闭包 闭包跟作用域有着千丝万缕的联系,有时候你会不经意间使用到,但是却不知是闭包,其实你平时使用的好多场景都有闭包 闭包简单来说,可以解释为:A函数里面定义了一个B函数,B函数在非A函数作用域下执行,在A函数释放的情况下,仍能访问和操作A函数作用域下的变量和函数 这就是闭包,在业务开发过程中,我们会遇到很多此类示例 例子一 function foo() { var name = &quot;wenkai.yin&quot;; setTimeout(function time() { console.log(name); name = &quot;Gary&quot;; console.log(name); }, 1000); } foo(); //在这里打印: //wenkai.yin //Gary //这就是一个闭包示例,名为time的函数在foo函数作用域下定义,在foo函数调用释放之后,在setTimeout这个函数作用域下执行,仍能访问和操作到foo函数作用域下的变量name,这就形成了一个闭包,变量name,明明应该随着foo函数的调用释放被销毁,但是却没有,在内存中获得保留,形成一块儿闭包区域 例子二 function foo() { var name = &quot;world&quot;; function bar() { console.log(name); name = &quot;hello&quot;; console.log(name); } return bar; } foo()(); //这里打印: //world //hello //在这里bar函数是在foo函数词法作用域下定义的,但是在foo函数调用释放之后,bar函数在全局作用域下还是能够访问和操作foo函数作用域下的本应被销毁掉的变量name,说明这时候变量name并没有在内存中显示,反而保留了下来,形成了一块儿闭包区域 例子三 function deep() { for(var i = 0; i &lt; 10; i++) { setTimeout(function time() { console.log(i); }, i * 1000); } } deep(); //在这里会打印: 10个10 //由于延时器异步的关系,当浏览器引擎遇到异步代码时,会先把异步代码放到异步队列中,先执行同步代码,等待到同步代码执行完毕之后,再去轮询异步队列中的异步代码,而这时候for循环已经结束,i的值为10,所以打印了10个10 //当然里面也存在闭包,例子一中已经说明 //修复异步问题,使用闭包方法: function deep() { for(var i = 0; i &lt; 10; i++) { setTimeout((function time(i) { var j = i; return function () { console.log(j); } })(i), i * 1000); } } deep(); //在这里会打印: 0-9十个数字 //j是time函数词法作用域下的变量,而for循环中的变量i通过参数的方式传入time IIFE自执行函数表达式, //这时time函数词法作用域下返回一个匿名函数,且不在time函数词法作用域下而是在setTimeout函数作用域下执行,这时候形成了十个闭包,内存中保留了time函数释放之后的内部的i和j变量,形成了十个闭包区域 //修复异步问题,使用let关键字: function deep() { for(let i = 0; i &lt; 10; i++) { setTimeout(function time() { console.log(i); }, i * 1000); } } deep(); //在这里会打印: 0-9十个数字 //实际上在这里每一次循环都会形成一个块级作用域,块级作用域下定义的time函数, //而time函数在setTimeout函数词法作用域下执行,仍然可以获取到块级作用域下的变量i,这时的变量i是保留在内存当中的,形成了类似于闭包的十个块级作用域闭包区域 IIFE自执行函数表达式 IIFE自执行函数表达式的出现本质上是为了防止变量名称冲突,避免污染全局变量,利用函数词法作用域,做了一处自动执行的私密装置 例子 var name = &quot;global&quot;; (function IIFE(global) { var name = &quot;IIFE&quot;; console.log(name, global.name); })(window); console.log(name); //在这里打印: IIFE global //global //体现了全局作用域下的变量name和IIFE函数词法作用域下的变量name的不同含义,且IIFE函数词法作用域下的变量不会造成全局变量的污染,不会造成命名冲突,是私密的。 //还有一种自执行函数表达式的写法 var name = &quot;global&quot;; (function IIFE(fn) { fn(window); })(function foo(global) { var name = &quot;IIFE&quot;; console.log(name, global.name); }); console.log(name); //在这里打印: IIFE global //global //同上含义,只不过传入的参数方式不同,一种是传递window参数,一种是直接传递函数 try…catch…模拟块级作用域 早在ES6 let和const关键字出现之前,就已经有团队和公司在开始模拟块级作用域了,其中Google公司的Tracer解析编译工具在编译和模拟块级作用域时,编译出来的ES5代码,就是使用了try{} catch() {}这种方式 例子 try { throw undefined; } catch(a) { b = 12; console.log(b); } console.log(b); //在这里打印: //12 //ReferrenceError:b is not defined //这种机制在ES3中就早已经出现了 二、this动态作用域this动态作用域是公认的js闭包之外的第二个难点,有很多人不明白this所指代的是什么,是对象?词法作用域?还是上下文?其实都不是,让我们来一起揭开this的面纱 this是什么 this实际上是函数对象调用执行时所处的上下文对象(这里的上下文对象指的并不是作用域) this指向分类 this指向的分类一共有四种: 1. 普通函数调用执行,默认指向window 2. 使用对象调用执行,软绑定指向该对象 3. 使用apply、call或者bind绑定在某个对象上执行,硬绑定指向该对象 4. 使用new语法糖构造器调用执行,new绑定指向函数对象本身 例子一 var a = 99; function foo() { console.log(this.a); } foo(); //在这里打印: //99 //由于是普通调用在全局作用域下执行,此时的this指向的是window, //由此console.log(window.a),打印的是99 例子二 var $a = &apos;world&apos;; var $obj = { $a: &apos;9hello9&apos;, b() { console.log(this.$a); } }; $obj.b(); //在这里打印: //9hello9 //由于是使用对象调用执行,软绑定this指向该对象 //由此console.log($obj.a),打印的是9hello9 例子三 var $a = &apos;6world6&apos;; var $obj = { $a: &apos;9hello9&apos;, b() { console.log(this.$a); } }; var $_obj = { $a: &apos;7fast7&apos; }; $obj.b.apply($_obj); $obj.b.call($_obj); //在这里打印: //7fast7 //7fast7 //由于是使用apply、call或者bind绑定在某个对象上调用执行,硬绑定this指向该对象 //由此console.log($_obj.$a),打印的是7fast7 例子四 var $a = &apos;6world6&apos;; function Fo($a) { this.$a = $a; } var $fo = new Fo(&apos;9hello9&apos;); console.log($fo.$a); //在这里打印: //9hello9 //由于是使用new语法糖构造器调用执行,new绑定指向函数对象本身 //由此console.log($fo.$a),打印的是9hello9 this指向优先级 this默认绑定 &lt; 对象软绑定 &lt; apply、call和bind硬绑定 &lt; new绑定 对比对象软绑定和apply、call以及bind硬绑定的优先级 function bar() { console.log(this.$a); } var $obj = { $a: &quot;5we5&quot;, bar: bar }; var $_obj = { $a: &quot;6happy6&quot; }; $obj.bar.apply($_obj); $obj.bar.call($_obj); //在这里打印: //6happy6 //6happy6 //由此可见,apply、call以及bind硬绑定的优先级大于对象软绑定 对比对象软绑定和new绑定的优先级 function bar() { console.log(this.$a); } var $obj = { $a: &quot;4snake4&quot;, bar: bar }; var $result = new $obj.bar(); //在这里打印: //undefined //由此可见,new绑定的优先级大于对象软绑定 对比apply、call以及bind硬绑定和new绑定的优先级,由于apply/call和new不能同时使用,所以我们演示就使用bind硬绑定与new绑定进行优先级比较 function Fo($a) { this.$a = $a; } var bar = { $a: &quot;8money8&quot; }; var fBind = Fo.bind(bar); var _bind = new fBind(&quot;3sheep3&quot;); console.log(_bind.$a); //在这里打印: //3sheep3 //由此可见,new绑定的优先级大于apply、call以及bind硬绑定 polyfill兼容模拟bind硬绑定 if(!Function.prototype.bind) { Function.prototype.bind = function (context) { if(typeof this !== &quot;function&quot;) { throw new TypeError(&quot;被绑定的对象并不是函数对象!&quot;); } let self = this, args = Array.from(arguments), fBind; args.shift(); function F() {} fBind = function () { let innerArgs = Array.from(arguments); return self.apply(this instanceof fBind ? this : context, [...args, ...innerArgs]); }; F.prototype = self.prototype; fBind.prototype = new F(); return fBind; }; } //polyfill兼容模拟bind硬绑定大概上就是如此 //测试硬绑定,非new绑定模式 function Person(name, age) { this.name = name; this.age = age; } var $obj = { name: &quot;Gary&quot;, age: 26 }; var $_obj = Person.bind($obj); var $obj_ano = { name: &quot;Clay yin&quot;, age: 29, $_obj }; var $obj_empty = {}; $_obj(&quot;wenkai.yin&quot;, 27); console.log($obj.name, $obj.age); $obj_ano.$_obj(&quot;yin.wenkai&quot;, 25); console.log($obj.name, $obj.age); console.log($obj_ano.name, $obj_ano.age); $_obj.apply($obj_empty, [&quot;Gary Yin&quot;, 24]); console.log($obj_empty.name, $obj_empty.age); console.log($obj.name, $obj.age); //在这里打印: //wenkai.yin 27 //yin.wenkai 25 //Clay yin 29 //undefined undefined //Gary Yin 24 //测试硬绑定,new绑定模式 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var obj = { name: &quot;Gary Yin&quot;, age: 24 }; var fBind = Person.bind(obj); var person = new fBind(&quot;wenkai.yin&quot;, 26); console.log(person.name, person.age); person.introduce(); console.log(obj.name, obj.age); //在这里打印: //wenkai.yin 26 //hello, I&apos;m wenkai.yin, 24 year&apos;s old //Gary Yin 24 polyfill兼容模拟softBind软绑定 Function.prototype.softBind = function (context) { if(typeof this !== &quot;function&quot;) { throw new TypeError(&quot;被绑定的对象并不是函数对象!&quot;); } var self = this, args = Array.from(arguments), fBind; args.shift(); function F() {} fBind = function () { var innerArgs = Array.from(arguments); return self.apply((!this || this === window) ? context : this, [...args, ...innerArgs]); }; F.prototype = self.prototype; fBind.prototype = new F(); return fBind; }; //polyfill兼容模拟softBind软绑定大概上就是如此 //测试软绑定,非new绑定模式 function Person(name, age) { this.name = name; this.age = age; } var $obj = { name: &quot;Gary&quot;, age: 26 }; var $_obj = Person.softBind($obj); $_obj(&quot;wenkai.yin&quot;, 27); console.log($obj.name, $obj.age); var $obj_ano = { name: &quot;Clay yin&quot;, age: 29, $_obj }; var $obj_empty = {}; $obj_ano.$_obj(&quot;Gary Yin&quot;, 28); console.log($obj_ano.name, $obj_ano.age); console.log($obj.name, $obj.age); $_obj.apply($obj_empty, [&quot;yin.wenkai&quot;, 24]); console.log($obj_empty.name, $obj_empty.age); console.log($obj.name, $obj.age); //在这里打印: //wenkai.yin 27 //Gary Yin 28 //wenkai.yin 27 //yin.wenkai 24 //wenkai.yin 27 //测试软绑定,new绑定模式 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var $obj = { name: &quot;Clay yin&quot;, age: 29 }; var $_obj = Person.bind($obj); var person = new Person(&quot;Gary_yin&quot;, 22); console.log(person.name, person.age); person.introduce(); console.log($obj.name, $obj.age); //在这里打印: //Gary_yin 22 //hello, I&apos;m Gary_yin, 22 year&apos;s old //Clay yin 29 polyfill兼容模拟new绑定 function _new() { var args = Array.from(arguments), Collapse = args.shift(), _obj = {}; _obj.__proto__ = Collapse.prototype; var target = Collapse.apply(_obj, args); return typeof target === &quot;object&quot; ? target : _obj; } //测试模拟new绑定 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function() { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var person = _new(Person, &quot;Gary&quot;, 26); console.log(person.name, person.age); person.introduce(); console.log(Object.getPrototypeOf(person) === Person.prototype); console.log(Person.prototype.isPrototypeOf(person)); //在这里打印: //Gary 26 //hello, I&apos;m Gary, 26 year&apos;s old //true //true 注意点 this与函数调用执行的位置的上下文对象息息相关,有时候千万不要被一些障眼法蒙蔽 例子一 var name = &quot;Gary Yin&quot;; function bar() { console.log(this.name); } var obj = { name: &quot;wenkai.yin&quot;, bar }; var _bar = obj.bar; _bar(); //在这里打印: //Gary Yin //此时bar函数调用执行位置的上下文对象,并不是对象软绑定,而是全局对象window 例子二 function say() { console.log(this.name); } var obj = { name: &quot;obj_one&quot; }; var objTwo = { name: &quot;obj_two&quot; }; var objThree = { name: &quot;obj_three&quot; }; var foo = say.bind(obj).bind(objTwo).bind(objThree); foo(); //在这里打印: //obj_one //此时say函数调用执行this只硬绑定指向了一层上下文对象,那就是obj,剩下的两层硬绑定,都是bind硬绑定内部返回的函数对象fBind进行的,与say函数没有任何关系 例子三 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function() { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var $obj = { name: &quot;Gary&quot;, age: 26 }; var fBind = Person.bind($obj); var person = new fBind(&quot;wenkai.yin&quot;, 28); console.log(person.name, person.age); person.introduce(); console.log($obj.name, $obj.age); //在这里打印: //wenkai.yn 28 //hello, I&apos;m wenkai.yin, 28 year&apos;s old //Gary 26 //根据polyfill兼容模拟的bind,我们可以看出,当this指向其构造器fBind时,也就是new返回的函数,进行构造调用时,外部绑定的函数对象的this就不会指向绑定的对象,而是会指向构造器fBind,所以引用对象person委托关联指向fBind,并通过原型链指向Person。 //于是,名称和年龄是外部参数wenkai.yin和28,可以调用执行原型链上面的函数introduce,而$obj对象上面的属性值并没有发生任何改变 三、原型链原型链,从本质上来讲,就是引用对象与普通对象、引用对象与函数对象之间委托关联,当建立起委托关联后,引用对象本身的隐式原型proto与构造函数的显式原型prototype就会形成引用关系,使得引用对象不仅可以调用本身被显式绑定的属性值,也可以追本溯源的通过原型链调用构造函数原型链上面的属性和函数方法。 伪继承 继承在传统面向对象的语言中是子类直接复制父类的属性和方法,复制后,子类上是直接存在其父类的属性和方法的,但是在JS中,继承并不是复制,而是委托关联,通过原型链向父级搜索查找,直至继承树的顶端Object.prototype也就是Object对象的显式原型。 例子一 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; function Gary(name, age, hobby) { Person.call(this, name, age); this.hobby = hobby; } //以下三行就是JS伪继承委托关联的精髓s //将子类的显式原型的隐式原型指向父类的显式原型 function F() {} F.prototype = Person.prototype; Gary.prototype = new F(); Gary.prototype.hobbyMine = function () { console.log(`${this.name}, I love ${this.hobby}`); }; var gary = new Gary(&quot;wenkai.yin&quot;, 26, &quot;program&quot;); console.log(gary.name, gary.age, gary.hobby); gary.introduce(); gary.hobbyMine(); //在这里打印: //wenkai.yin 26 program //hello, I&apos;m wenkai.yin, 26 year&apos;s old //wenka.yin, I love program 例子二 //还是同样剧情的例子,不过这一次我们要换一下继承方式 //并且深究一下内部的委托关联原型链 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; function Gary(name, age, hobby) { Person.call(this, name, age); this.hobby = hobby; } //以下三行就是JS伪继承委托关联的精髓 //将子类的显式原型的隐式原型指向父类的显式原型 Gary.prototype = Object.create(Person.prototype); Gary.prototype.hobbyMine = function () { console.log(`${this.name}, I love ${this.hobby}`); }; var gary = new Gary(&quot;wenkai.yin&quot;, 26, &quot;program&quot;); console.log(gary.name, gary.age, gary.hobby); gary.introduce(); gary.hobbyMine(); console.log(gary.__proto__ === Gary.prototype); console.log(Gary.prototype.__proto__ === Person.prototype); console.log(Object.getPrototypeOf(gary) === Gary.prototype); console.log(Object.getPrototypeOf(Object.getPrototypeOf(gary)) === Person.prototype); console.log(Gary.prototype.isPrototypeOf(gary)); console.log(Person.prototype.isPrototypeOf(Gary.prototype)); //在这里打印: //wenkai.yin 26 program //hello, I&apos;m wenkai.yin, 26 year&apos;s old //wenkai.yin, I love program //true //true //true //true //true //true //这里使用了两个方法,isPrototypeOf和getPrototypeOf。 //a.isPrototypeOf(b)是判断b是否是在a的原型链上,可以用于检查引用对象和其他任意对象之间的委托关联关系 //Object.getPrototypeOf(b) === a与b.__proto__ === a的效果相同的,Object.getPrototypeOf(b)也只不过是提取了b对象中的隐式原型与a对象或者a函数对象的显式原型进行比对。 polyfill兼容模拟Object.create方法 从polyfill兼容模拟Object.create方法的源代码来看,利用的是原型链的机制,将子类与父类或者说是子对象与父对象委托关联起来。使用Object.create的优势,首先,不需要再去考虑委托关联构造调用时的参数问题,使用第三函数对象,也就是F函数中转承接;第二,适用于引用对象与任意对象(普通对象、函数对象)之间的委托关联。 if(!Object.create) { Object.create = function(o) { function F() {} F.prototype = o; return new F(); }; } 例子一 var a = { }; var b = { age: &quot;b&quot; }; a = Object.create(b); console.log(a.age); //在这里打印: //b 例子二 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; function Gary(name, age, hobby) { Person.call(this, name, age); this.hobby = hobby; } //以下三行就是JS伪继承委托关联的精髓 //将子类的显式原型的隐式原型指向父类的显式原型 Gary.prototype = Object.create(Person.prototype); Gary.prototype.hobbyMine = function () { console.log(`${this.name}, I love ${this.hobby}`); }; var gary = new Gary(&quot;wenkai.yin&quot;, 26, &quot;program&quot;); console.log(gary.name, gary.age, gary.hobby); gary.introduce(); gary.hobbyMine(); //在这里打印: //wenka.yin 26 program //hello, I&apos;m wenkai.yin, 26 year&apos;s old //wenkai.yin, I love program 注意点 instanceof通常是检查引用对象是否在某一个函数对象的原型链上,不过也只是作用于引用对象和函数对象之间,并不能检查引用对象和普通对象之间的委托关联关系 例子一 function Person(name, age) { this.name = name; this.age = age; } var gary = new Person(&quot;wenkai.yin&quot;, 26); console.log(gary instanceof Person); console.log(gary instanceof Object); //在这里打印: //true //true 例子二 var a = { name: &quot;Gary&quot;, age: 26 }; var b = { name: &quot;wenkai.yin&quot;, age: 28 }; a = Object.create(b); console.log(Object.getPrototypeOf(a) === b); console.log(b.isPrototypeOf(a)); //在这里打印: //true //true //当遇到检查引用对象和普通对象之间的委托关联,判断引用对象是否在普通对象的原型链上时, //就不能使用instanceof,我们这里使用的是isPrototypeOf,b.isPrototypeOf(a) 原型链的顶部,也就是Object.prototype,Object对象的显式原型,那按照原型链的规则来看,原型链的顶部Object对象的显式原型的隐式原型指向哪儿呢? 答案是null function Person(name, age) { this.name = name; this.age = age; } var gary = new Person(&quot;wenkai.yin&quot;, 26); console.log(Object.getPrototypeOf(gary) === Person.prototype); console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); console.log(Object.getPrototypeOf(Object.prototype) === null); console.log(Person.prototype.isPrototypeOf(gary)); console.log(Object.prototype.isPrototypeOf(Person.prototype)); //在这里打印: //true //true //true //true //true 四、对象定义对象有两种方式,一种是构造调用进行定义,还有一种是使用字面量语法糖的形式定义。 例子一 var obj = new Object(); obj.name = &quot;Gary&quot;; obj.age = 24; console.log(obj); //在这里打印: //Object {name: &quot;Gary&quot;, age: 24} //使用构造调用定义,添加属性或者方法,必须使用.或者[字符串]的形式,一行一行添加,非常繁琐 例子二 var obj = { name: &quot;Gary Yin&quot;, age: 26 }; console.log(obj); //在这里打印: //Object {name: &quot;Gary Yin&quot;, age: 26} //使用字面量语法糖定义,批量添加属性或者方法,一般定义对象,基本都这样使用 添加或者修改对象属性或者方法 例子一 var obj = { name: &quot;Gary Yin&quot;, age: 26 }; obj.name = &quot;wenkai.yin&quot;; obj.hobby = &quot;basketball&quot;; obj.sexy = &quot;men&quot;; console.log(obj); //在这里打印: //Object {name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;basketball&quot;, sexy: &quot;men&quot;} //这种.形式添加或者修改对象属性或者方法,弊端在于属性名或者方法名,必须遵守定义变量名称的规则 //也就是必须以字母、下划线或者$符号开头,且属性名称或者方法名称只允许使用数字、字母、下划线和$符号 例子二 var obj = { name: &quot;Gary Yin&quot;, age: 26 }; obj[&quot;name&quot;] = &quot;wenkai.yin&quot;; obj[&quot;1hobby&quot;] = &quot;basketball&quot;; obj[&quot;sexy&quot;] = &quot;men&quot;; obj[&quot;@#$%&quot;] = &quot;@#$%&quot;; console.log(obj); //在这里打印: //Object {name: &quot;wenkai.yin&quot;, age: 26, 1hobby: &quot;basketball&quot;, sexy: &quot;men&quot;, @#$%: &quot;@#$%&quot;} //这种[字符串]形式添加或者修改对象属性或者方法,属性名或者方法名可以使用任意的字符串进行定义,没有任何的限制,兼容所有的字符串(包括汉字) 例子三 var obj = { }; Object.defineProperty(obj, &quot;name&quot;, { value: &quot;wenkai.yin&quot;, writable: true, enumerable: true, configurable: true }); console.log(obj); //在这里打印: //Object {name: &quot;wenkai.yin&quot;} Object.defineProperties(obj, { age: { value: 26, writable: true, enumerable: true, configurable: true }, hobby: { value: &quot;program&quot;, writable: true, enumerable: true, configurable: true } }); console.log(obj); //在这里打印: //Object {name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;program&quot;} //defineProperty和defineProperties是添加和修改配置对象属性方法最细致的两种方式,defineProperty只能添加和修改一项属性和方法,而defineProperties可以批量添加和修改属性和方法 获取对象属性和方法的配置信息 例子一 var obj = { name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;program&quot; }; console.log(Object.getOwnPropertyDescriptors(obj)); //在这里打印: //{ // name: { // configurable: true, // enumerable: true, // value: &quot;wenkai.yin&quot;, // writable: true // }, // age: { // configurable: true, // enumerable: true, // value: 26, // writable: true // }, // hobby: { // configurable: true, // enumerable: true, // value: &quot;program&quot;, // writable: true // } //} //批量获取对象属性和方法的配置信息 console.log(Object.getOwnPropertyDescriptor(obj, &quot;age&quot;)); //在这里打印: //{ // configurable: true, // enumerable: true, // value: 26, // writable: true //} //获取对象单个属性或者方法的配置信息 获取对象的属性和方法的配置信息后,将要解释一下这些配置信息的作用,value就是属性值,writable是用来控制属性或者方法是否可修改值的开关,configurable是用来控制属性或者方法是否可配置、可添加以及可删除,enumerable是用来控制属性或者方法是否可枚举 例子一 var obj = { name: &quot;Gary&quot; }; Object.defineProperties(obj, { age: { value: 26, enumerable: false, writable: true, configurable: true }, hobby: { value: &quot;program&quot;, enumerable: true, writable: true, configurable: true } }); for(var key in obj) { console.log(key); } //在这里打印: //name //program //属性的enumerable可枚举如果为false,遍历对象的属性名称,就不会出现 for(let key of Object.keys(obj)) { console.log(key); } //在这里打印: //name //program //属性的enumerable可枚举如果为false,遍历对象的属性名称,就不会出现 console.log(Object.getOwnPropertyNames(obj)); //在这里打印: //[&quot;name&quot;, &quot;age&quot;, program&quot;] console.log(obj.hasOwnProperty(&quot;age&quot;)); //在这里打印: //true console.log(Reflect.ownKeys(obj)); //在这里打印: //[&quot;name&quot;, &quot;age&quot;, &quot;program&quot;] //由此可得出结论,除了for...in、Object.keys(obj)、Object.values(obj)和Object.entries(obj)受控制是否可枚举的属性enumerable影响之外,其他方式都可以获取到控制是否可枚举属性enumerable为false的属性名称 //for...in、Object.keys(obj)、Object.values(obj)和Object.entries(obj)还是能获取原型链上的属性和方法的遍历方式 例子二 var obj = { name: &quot;Gary&quot; }; Object.defineProperties(obj, { age: { value: 26, enumerable: true, writable: true, configurable: true }, hobby: { value: &quot;program&quot;, enumerable: true, writable: false, configurable: true } }); obj.name = &quot;wenkai.yin&quot;; obj.hobby = &quot;basketball&quot;; console.log(obj); //Object {name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;program&quot;} //当设置了控制属性值是否可修改的writable为false时,属性值便不可被改变 //且当writable设置为false时,不可被再次设置为true Object.defineProperty(obj, &quot;hobby&quot;, { value: &quot;program&quot;, writable: true, configurable: true, enumerable: true }); //在这里打印: //直接报错,property can not redefine: hobby 例子三 var obj = { name: &quot;Gary&quot; }; Object.defineProperties(obj, { age: { value: 26, enumerable: true, writable: true, configurable: true }, hobby: { value: &quot;program&quot;, enumerable: true, writable: true, configurable: false } }); delete obj.age; delete obj.program; console.log(obj); //在这里打印: //Object {name: &quot;Gary&quot;, hobby: &quot;program&quot;} Object.defineProperty(obj, &quot;hobby&quot;, { value: &quot;basketball&quot;, writable: true, enumerable: true, configurable: true }); //在这里打印: //直接报错,property can not redefine: hobby 例子四 var obj = { name: &quot;Gary&quot;, age: 26, hobby: &quot;basketball&quot; }; Object.preventExtensions(obj); obj.sexy = &quot;men&quot;; obj.hobby = &quot;program&quot;; console.log(obj); //在这里打印: //Object {name: &quot;Gary&quot;, age: 26, hobby: &quot;program&quot;} //preventExtensions方法使得obj对象不可添加新的属性 例子五 var obj = { name: &quot;Gary&quot;, age: 26, hobby: &quot;basketball&quot; }; Object.seal(obj); obj.sexy = &quot;men&quot;; obj.hobby = &quot;program&quot; delete obj.age; delete obj.name; console.log(obj); //在这里打印: //Object {name: &quot;Gary&quot;, age: 26, hobby: &quot;program&quot;} for(var key in obj) { console.log(key); } //在这里打印: //name //age //program Object.defineProperty(obj, &quot;name&quot;, { value: &quot;wenkai.yin&quot;, configurable: true, writable: true, enumerable: true }); console.log(obj); //在这里打印: //直接报错: property can not redefine: name //由此可以得出结论: seal方法使得obj对象所有属性不可配置对象属性和方法信息、不可删除对象属性,且不可添加对象属性,但是属性名称还是可以枚举的,原属性值还是可以修改的,也就是说seal方法使得obj对象所有属性的configurable置为false,所有属性的writable和enumerable还是维持原来的状态 例子六 var obj = { name: &quot;Gary&quot;, age: 26, hobby: &quot;basketball&quot; }; Object.freeze(obj); obj.sexy = &quot;men&quot;; obj.hobby = &quot;program&quot; delete obj.age; delete obj.name; console.log(obj); //在这里打印: //Object {name: &quot;Gary&quot;, age: 26, hobby: &quot;basketball&quot;} for(var key in obj) { console.log(key); } //在这里打印 //name //age //hobby Object.defineProperty(obj, &quot;name&quot;, { value: &quot;wenkai.yin&quot;, configurable: true, writable: true, enumerable: true }); console.log(obj); //在这里打印: //直接报错: property can not redefine: name //由此可以得出结论: freeze方法使得obj对象不可配置对象属性和方法信息、不可删除对象属性、不可添加对象属性,且不可修改对象属性值,但是属性名称还是可以枚举的,也就是说freeze方法使得obj对象所有属性的configurable和writable置为false,所有属性的enumerable还是维持原来的状态 对象遍历 ES6语法中,新增了keys、values、entries和Reflect.OwnKeys遍历对象的函数方法,当然你也可以直接使用ES5语法中的for…in、getOwnPropertyNames等形式对对象进行遍历,还有一种使用迭代器(Symbol.iterator)的方式,这种方式需要开发者手写对象的Symbol.iterator迭代器方法,并不常见 例子一 var obj = { name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;basketball&quot; }; for(let key of Object.keys(obj)) { console.log(key); } //在这里打印: //name //age //hobby for(let value of Object.values(obj)) { console.log(value); } //在这里打印: //wenkai.yin //26 //basketball for(let [key, value] of Object.entries(obj)) { console.log(key, value); } //在这里打印: //name wenkai.yin //age 26 //hobby basketball for(let key in obj) { console.log(key); } //在这里打印: //name //age //hobby 例子二 var obj = { name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;basketball&quot; }; var objNames = Object.getOwnPropertyNames(obj); for(let val of objNames) { console.log(val); } //在这里打印: //name //age //hobby var objOwnKeys = Reflect.ownKeys(obj); for(let val of objOwnKeys) { console.log(val); } //在这里打印: //name //age //hobby 例子三 var obj = { name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;basketball&quot;, [Symbol.iterator]() { var self = this, index = 0, objArr = Object.keys(self), length = objArr.length; return { next() { return { value: self[objArr[index++]], done: index &gt; length }; } }; } }; for(let val of obj) { console.log(val); } //在这里打印: //wenkai.yin //26 //basketball 笔试训练自此你不知道的Javascript&lt;上篇&gt;整理: 词法作用域、this以及原型对象重点都已经划完了,下面我们会进入上篇的笔试训练阶段。 笔试一 var a = 20; var foo = { a: 10, getA: function () { return this.a; } }; var _getA = foo.getA; console.log(_getA()); //在这里打印: //20 笔试二 var timer1 = (cb, time) =&gt; { (function loop() { cb(); setTimeout(loop, time); })(); }; var timer2 = (cb, time) =&gt; { cb(); setInterval(cb, time); }; //1.timer1和timer2实现了什么功能,执行结果上会有什么区别? //回答: timer1和timer2实现了隔时轮询的功能,从执行结果上来看并没有任何的区别 //2.模拟requestAnimationFrame方法的话应该参照哪种实现? //回答: 应该参照第一种timer1的实现方法 //3.timer1中调换cb()和setTimeout的先后顺序会有什么影响? //回答: 并不会有什么影响,由于JS语言是单线程语言,所以同一时间只能做同一件事,它会先执行同步代码,当遇到异步代码时,会先把异步代码放进异步队列中,等待同步代码执行完毕之后,再轮询异步队列中的异步代码,由此不会有任何的影响 笔试三 var a = 1; function f() { console.log(a); var = 2; } f(); //在这里打印: //undefined 笔试四 f(); g(); function f() { console.log(&apos;f&apos;); } var g = function() { console.log(&apos;g&apos;); }; //在这里打印: //f //TypeError: g is not a function 笔试五 var person = { name: &quot;Messi&quot; }; console.log(person.hasOwnProperty(&quot;name&quot;)); console.log(person.hasOwnProperty(&quot;hasOwnProperty&quot;)); console.log(Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)); //在这里打印: //true //false //true 笔试六 function person(pname, page) { this.name = pname; this.age = page; } person.prototype.profession = &quot;football player&quot;; var person1 = new person(&quot;Messi&quot;, 29); var person2 = new person(&quot;Bale&quot;, 28); console.log(person1.hasOwnProperty(&quot;name&quot;)); console.log(person1.hasOwnProperty(&quot;hasOwnProperty&quot;)); console.log(person1.__proto__ === person.prototype); console.log(person.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)); console.log(person1.__proto__.__proto__ === person.prototype.__proto__); console.log(person.prototype.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //在这里打印: //true //false //true //false //true //true 笔试七 function shallowClone(o) { const obj = {}; for(let i in o) { obj[i] = o[i]; } return obj; } const oldObj = { a: 1, b: [&apos;e&apos;, &apos;f&apos;, &apos;g&apos;], c: {h: {i: 2}} }; const newObj = shallowClone(oldObj); console.log(newObj.c.h, oldObj.c.h); console.log(newObj.c.h === oldObj.c.h); newObj.c.h = &quot;change&quot;; console.log(newObj.c.h, oldObj.c.h); //在这里打印: //{i: 2} {i: 2} //true //&apos;change&apos; &apos;change&apos; 自此你不知道的Javascript&lt;上篇&gt;整理: 词法作用域、this以及原型对象整理结束 &lt;花絮&gt;整理polyfill兼容模拟的函数方法以及元素视图盒模型polyfill兼容模拟的函数方法 polyfill兼容模拟new绑定 function _new() { var obj = {}, args = Array.from(arguments), Collapse = args.shift(); obj.__proto__ = Collapse.prototype; var target = Collapse.apply(obj, args); return typeof target === &quot;object&quot; ? target : obj; } function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function() { console.log(`I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var person = _new(Person, &quot;wenkai.yin&quot;, 26); console.log(person.name, person.age); person.introduce(); //在这里打印: //wenkai.yin 26 //I&apos;m wenkai.yin, 26 year&apos;s old polyfill兼容模拟bind硬绑定 if(!Function.prototype.bind) { Function.prototype.bind = function(context) { if(typeof this !== &quot;function&quot;) { throw new TypeError(&quot;被绑定的对象类型并不是函数~&quot;); } var self = this, args = Array.from(arguments) fBind; args.shift(); function F() {} fBind = function() { var innerArgs = Array.from(arguments); return self.apply(this instanceof fBind ? this : context, [...args, ...innerArgs]); } F.prototype = self.prototype; fBind.prototype = new F(); return fBind; } } function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function() { console.log(`I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var obj = { name: &quot;Gary Yin&quot;, age: 26 }; var fBind = Person.bind(obj); var obj_ano = { name: &quot;wenkai.yin&quot;, age: 27, fBind }; obj_ano.fBind(&quot;one piece&quot;, 12); console.log(obj, obj_ano); //在这里打印: //Object {name: &quot;one piece&quot;, age: 12} //Object {name: &quot;wenkai.yin&quot;, age: 27, fBind: f} var obj_empty = {}; fBind.apply(obj_empty, [&quot;Gary wenkai&quot;, 22]); console.log(obj, obj_empty); //在这里打印: //Object {name: &quot;Gary wenkai&quot;, age: 22} //Object {} polyfill兼容模拟Object.create if(!Object.create) { Object.create = function(o) { function F() {} F.prototype = o; return new F(); }; } var gary = { name: &quot;Gary Yin&quot;, age: 24 }; var gary_ = Object.create(gary); console.log(gary_.name, gary_.age); console.log(gary.isPrototypeOf(gary_)); console.log(Object.getPrototypeOf(gary_) === gary); //在这里打印: //Gary Yin 24 //true //true polyfill兼容模拟函数截流以及函数防抖 //函数截流 var throttle = (function () { var firstTime = true, timer = null; return function(func, speed) { if(firstTime) { func(); firstTime = false; return false; } if(timer) { return false; } timer = setTimeout(function time() { clearTimeout(timer); timer = null; func(); }, speed); }; })(); window.onresize = function (event) { throttle(function () { console.log(event); }, 1000); }; //快速缩小或者放大浏览器长宽最多会打印两条数据,输出的数据会很慢: //Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …} //Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …} //函数防抖 var debounce = (function () { var timer = null; return function (func, speed) { if(timer) { clearTimeout(timer); timer = null; } timer = setTimeout(function time() { func(); }, speed); } })(); window.onresize = function(event) { debounce(function() { console.log(event); }, 1000); }; //持续快速缩小或者放大浏览器长宽1s之后,只会打印一条数据: //Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …} polyfill兼容模拟softBind软绑定 if(!Function.prototype.softBind) { Function.prototype.softBind = function(context) { if(typeof this !== &quot;function&quot;) { throw new TypeError(&quot;被绑定的对象类型并不是函数~&quot;); } var self = this, args = Array.from(arguments), fSoftBind; args.shift(); function F() {} fBind = function() { var innerArgs = Array.from(arguments); return self.apply((!this || this === window) ? context : this, [...args, ...innerArgs]); }; F.prototype = self.prototype; fBind.prototype = new F(); return fBind; }; } function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function() { console.log(`I&apos;m ${this.name}, ${this.age} year&apos;s old`); }; var obj = { name: &quot;Gary Yin&quot;, age: 26 }; var fBind = Person.softBind(obj); var obj_ano = { name: &quot;wenkai.yin&quot;, age: 27, fBind }; obj_ano.fBind(&quot;one piece&quot;, 12); console.log(obj, obj_ano); //在这里打印: //Object {name: &quot;Gary Yin&quot;, age: 26} //Object {name: &quot;one piece&quot;, age: 12, fBind: f} var obj_empty = {}; fBind.apply(obj_empty, [&quot;Gary wenkai&quot;, 22]); console.log(obj, obj_empty); //在这里打印: //Object {name: &quot;Gary Yin&quot;, age: 26} //Object {name: &quot;Gary wenkai&quot;, age: 22} polyfill兼容模拟isInteger是否为整数 if(!Number.isInteger) { Number.isInteger = function(num) { return typeof num === &quot;number&quot; &amp;&amp; (num % 1 === 0); }; } console.log(Number.isInteger(44.6)); console.log(Number.isInteger(Number.MAX_SAFE_INTEGER)); console.log(Number.isInteger(Infinity)); console.log(Number.isInteger(NaN)); console.log(Number.isInteger(99)); //在这里打印: //false //true //false //false //true polyfill兼容模拟isNaN是否为NaN if(!Number.isNaN) { Number.isNaN = function(num) { return typeof num === &quot;number&quot; &amp;&amp; (num !== num); }; } console.log(Number.isNaN({})); console.log(Number.isNaN([])); console.log(Number.isNaN(NaN)); console.log(Number.isNaN(0 * Infinity)); console.log(Number.isNaN(1 / 0)); console.log(Number.isNaN(1 / Infinity)); console.log(Number.isNaN(Infinity / Infinity)); //在这里打印: //false //false //true //true //false //false //true polyfill兼容模拟isNagetiveZero是否为负零,负号一般代指方向 if(!Number.isNagetiveZero) { Number.isNagetiveZero = function(num) { return typeof num === &quot;number&quot; &amp;&amp; (1 / num === -Infinity); }; } console.log(Number.isNagetiveZero(-0)); console.log(Number.isNagetiveZero(0)); console.log(Number.isNagetiveZero(1 / Infinity)); console.log(Number.isNagetiveZero(99 / -Infinity)); //在这里打印: //true //false //false //true polyfill兼容模拟isEpsilon来判断0.1 + 0.2 === 0.3 if(!Number.isEpsilon) { Number.isEpsilon = function(num) { return num &lt; Number.EPSILON; }; } console.log(Number.isEpsilon(0.1 + 0.2 - 0.3)); //在这里打印: //true 元素视图盒模型//获取浏览器屏幕的可视宽度以及高度 console.log(window.innerWidth, window.innerHeight); //获取页面元素的无边框宽度以及高度 var box = document.getElementById(&quot;box&quot;); console.log(box.clientWidth, box.clientHeight); //获取页面元素的有边框宽度以及高度 console.log(box.offsetWidth, box.offsetHeight); //获取页面文档的高度 console.log(document.body.clientHeight || document.documentElement.clientHeight); //获取滑块滑动后距离顶部的高度 console.log(document.body.scrollTop || document.documentElement.scrollTop); //获取元素在页面的相对位置 var position = box.getBoundingClientRect(); console.log(position.top, position.left, position.right, position.bottom); //获取元素在页面的绝对位置 var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; var absoluteTop = position.top + scrollTop, absoluteBottom = position.bottom + scrollTop; console.log(absoluteTop, absoluteBottom); //获取元素的滑块滑动高度 console.log(box.scrollHeight); &lt;中篇&gt;整理: 类型、语法类型 基本类型 Javascript中基本类型分为: number、string、boolean、undefined和null,null类型由于JS最初时的一个bug导致它的typeof类型为object 引用类型 Javascript中引用类型分为: object以及function 内置函数和内置对象 Javascript中存在内置函数和内置对象,它们分别是: String、Number、Boolean、Object、Array、Function、RegExp、Math、JSON、Symbol和Error,当你去构造调用一个内置函数时,你就可以使用这些内置函数所拥有的属性或者方法,譬如说toString,valueOf,toFixed等等,但是你可能会问,为什么那些常量,比如说var string = “string”;string.toString();也可以调用构造调用的引用对象才能调用的属性或者方法呢?回答: 这些常量本身并没有这些属性和方法,而是它们在调用属性或者方法的时候,浏览器引擎会将它们封装成理应匹配的构造调用内置函数或者内置方法,这样这些常量就可以调用了 例子 var string_obj = new String(&quot;I&apos;m Gary&quot;), string = &quot;I&apos;m Seven&quot;; console.log(string_obj.slice(0, 5)); console.log(string.slice(0, 6)); //在这里打印: //I&apos;m G //I&apos;m Se var number_obj = new Number(10), number = 22; console.log(number_obj.toFixed(2)); console.log(number.toFixed(2)); //使用数字常量去调用数字构造调用的属性或者方法时,必须使用两个点调用,第一个点浏览器会认为是数字常量浮点类型的第一个点,第二点才是调用数字构造调用的属性或者方法的点 console.log(40..toFixed(2)); //在这里打印: //10.00 //22.00 //40.00 0.1 + 0.2 !== 0.3 大家都清楚,在JS里,0.1+0.2!==0.3,而是等于0.30000000000000004,原因:浮点数十进制在底层转化为二进制机器码进行运算,由于JS的浮点数并不是很精确,所以运算之后,转化为十进制之后,并不是0.3,而是0.30000000000000004那该怎么解决这个问题,使得0.1+0.2===0.3呢? ES6在Number内置函数上提供了一个属性EPSILON,它可以进行甄别0.1+0.2相加运算之后的值是否是在这个范围之内,如果是,就返回true,如果不是,就返回false 例子 function isEpsilon(num) { return num &lt; Number.EPSILON } console.log(isEpsilon(0.1 + 0.2 - 0.3)); //在这里打印: //true //说明0.1 + 0.2 - 0.3是在这个区间之内的,说明0.1 + 0.2 === 0.3 //而这个Number.EPSILON的区间范围是:2.220446049250313e-16 内置数字函数Number处理 下面是Number内置数字函数对各个类型的常量或者变量处理的结果,当处理基本类型的常量或者变量时,遇到null、false、0、””、” “和”0”时,会处理成0;遇到true,会处理成1;遇到undefined、NaN、字符串中含有字母时,会处理成NaN;当处理引用类型的常量或者变量时,会根据对象的ToNumber、ToString和ToPremitive进行处理,当遇到Number内置数字函数进行处理时,会直接调用对象的ToNumber也就是valueOf,遇到空数组时,会处理成0;遇到有一个数组元素的数组时,会处理成这一个数组元素产生的结果;遇到有两个数组的数组时,会处理成NaN;遇到对象时,会处理成NaN 例子 console.log(Number(undefined)); console.log(Number(null)); console.log(Number(NaN)); console.log(Number(0)); console.log(Number(&quot;0&quot;)); console.log(Number(&quot;0n0&quot;)); console.log(Number(&quot;&quot;)); console.log(Number(&quot; &quot;)); console.log(Number({})); console.log(Number([])); console.log(Number([44])); console.log(Number([&quot;4N4&quot;])); console.log(Number([44, 99])); console.log(Number(true)); console.log(Number(false)); //在这里打印: //NaN //0 //NaN //0 //0 //NaN //0 //0 //NaN //0 //44 //NaN //NaN //1 //0 内置字符串函数String处理 下面是String内置字符串函数对各个类型的常量或者变量处理的结果,当处理基本类型的常量或者变量时,遇到undefined、null、NaN、true、false、1、0时,会处理成”undefined”,”null”,”NaN”,”true”,”false”,”true”,”false”,”1”,”0”;当处理引用类型的常量或者变量时,会根据对象的ToNumber、ToString和ToPremitive进行处理,当遇到String内置字符串函数进行处理时,会直接调用对象的ToString也就是toString,遇到空数组时,会处理成””;遇到有一个数组元素的数组时,会处理成这个数组元素的字符串形式;遇到有多个数组的数组时,会处理成每个数组元素的字符串形式并在中间加上逗号;遇到对象时,会处理成其原型链上toString后显示的结果[object Object] 例子 console.log(String(undefined)); console.log(String(null)); console.log(String(0)); console.log(String(NaN)); console.log(String(true)); console.log(String(false)); console.log(String([])); console.log(String({})); console.log(String([44])); console.log(String([66, 99])); console.log(String(&quot; &quot;)); //在这里打印: //&quot;undefined&quot; //&quot;null&quot; //&quot;0&quot; //&quot;NaN&quot; //&quot;true&quot; //&quot;false&quot; //&quot;&quot; //[object Object] //&quot;44&quot; //&quot;66,99&quot; //&quot; &quot; 字符串toString方法处理 下面是toString字符串方法对各个类型的常量或者变量处理的结果,当处理基本类型的常量或者变量时,遇到undefined、null时,会直接报TypeError错误,表明undefined和null并不存在toString方法;当遇到NaN、true、false、1、0时,会直接处理成”NaN”,”true”,”false”,”1”,”0”;当处理引用类型的常量或者变量时,会根据对象的ToNumber、ToString和ToPremitive进行处理,当遇到toString字符串方法进行处理时,遇到空数组时,会处理成””;遇到有一个数组元素的数组时,会处理成这个数组元素的字符串形式;遇到有多个数组的数组时,会处理成每个数组元素的字符串形式并在中间加上逗号;遇到对象时,会处理成其原型链上toString后显示的结果[object Object] 例子 console.log(undefined.toString()); console.log(null.toString()); console.log(0..toString()); console.log(1..toString()); console.log(true.toString()); console.log(false.toString()); console.log(NaN.toString()); console.log([].toString()); console.log({}.toString()); console.log([44].toString()); console.log([&quot;4n4&quot;].toString()); console.log([44, 89].toString()); console.log(&quot; &quot;.toString()); //在这里打印: //TypeError: Cannot read property &apos;toString&apos; of undefined //TypeError: Cannot read property &apos;toString&apos; of null //&quot;0&quot; //&quot;1&quot; //&quot;true&quot; //&quot;false&quot; //&quot;NaN&quot; //&quot;&quot; //[object Object] //&quot;44&quot; //&quot;4n4&quot; //&quot;44, 89&quot; //&quot; &quot; polyfill兼容模拟判断一个常量或者一个变量是否为NaN 通常我们使用内置数字函数Number上的isNaN静态方法来判断一个常量或者一个变量是否为NaN,当然当遇到不兼容Number.isNaN方法的浏览器时,我们可以手写一个polyfill兼容版的静态方法,利用NaN的特性:NaN自己不等于其本身 例子 console.log(Number.isNaN(NaN)); //在这里打印: //true if(!Number.isNaN) { Number.isNaN = function(num) { return num !== num; }; } console.log(Number.isNaN(NaN)); console.log(Number.isNaN(0)); console.log(Number.isNaN({})); console.log(Number.isNaN([])); console.log(Number.isNaN([44])); //在这里打印: //true //false //false //false //false 内置数字函数Number上的属性或者方法 Number内置数字函数的MAX_VALUE和MIN_VALUE属性代表的是JS里所能表示的最大数值和最小数值;而MAX_SAFE_INTEGER和MIN_SAFE_INTEGER代表的是JS里面最大的和最小的安全整数;isInteger是判断一个常量或者一个变量是否是整数;而isSafeInteger则是判断一个常量或者一个变量是否是安全整数;当然我们也可以polyfill兼容模拟判断一个常量或者一个变量是否为整数isInteger 例子 console.log(Number.MAX_VALUE); console.log(Number.MIN_VALUE); console.log(Number.MAX_SAFE_INTEGER); console.log(Number.MIN_SAFE_INTEGER); console.log(Number.isInteger(Number.MAX_VALUE)); console.log(Number.isInteger(Infinity)); console.log(Number.isInteger(44.7)); console.log(Number.isInteger(1.7976931348623157e+308)); console.log(Number.isSafeInteger(1.7976931348623157e+308)); console.log(Number.isSafeInteger(9007199254740991)); console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)); //在这里打印: //1.7976931348623157e+308 //5e-324 //9007199254740991 //-9007199254740991 //true //false //false //true //false //true //false //polyfill模拟判断一个常量或者一个变量是否为整数isInteger if(!Number.isInteger) { Number.isInteger = function (num) { return typeof num === &quot;number&quot; &amp;&amp; (num % 1 === 0); }; } console.log(Number.isInteger(Number.MAX_VALUE)); console.log(Number.isInteger(Infinity)); console.log(Number.isInteger(44.7)); console.log(Number.isInteger(1.7976931348623157e+308)); console.log(Number.isInteger(44)); //在这里打印: //true //false //false //true //true Infinity、-Infinity、0与-0 除了0与-0之外,任何与Infinity进行运算(除了除法运算)的数值结果全都为Infinity或者-Infinity,任何与-Infinity进行运算(除了除法运算)的数值结果全都为Infinity或者-Infinity,任何与Infinity或者-Infinity进行运算的非数值结果根据隐式类型转换(valueOf)后决定;0与Infinity进行乘法运算的结果为NaN,进行加减运算的结果为Infinity或者-Infinity;-0与Infinity进行乘法运算的结果为NaN,进行加减运算的结果为Infinity或者-Infinity;任何与Infinity进行除法运算的数值结果全都为0或者-0;任何与-Infinity进行除法运算的数值结果全都为0或者-0;除了0与-0之外,任何与0进行除法运算的数值结果全都为Infinity或者-Infinity;任何与-0进行除法运算的数值结果全都为Infinity或者-Infinity;0, -0与0, -0进行除法运算的结果为NaN; 例子 console.log(1 * Infinity); console.log(-1 * Infinity); console.log(1 / Infinity); console.log(-1 / Infinity); console.log(199 * Infinity); console.log(-199 * Infinity); console.log(&quot;1ab&quot; * Infinity); console.log(Infinity * Infinity); console.log(-Infinity * Infinity); console.log(-Infinity * -Infinity); console.log([44] * Infinity); console.log([&quot;4n4&quot;] * Infinity); console.log([99, 77, 29] * Infinity); console.log({} * Infinity); console.log([] * Infinity); console.log(NaN + Infinity); console.log(0 * Infinity); console.log(-0 * Infinity); console.log(0 - Infinity); console.log(-0 - Infinity); console.log(0 / Infinity); console.log(-0 / Infinity); console.log(Infinity / Infinity); console.log(-Infinity / Infinity); console.log(1 / 0); console.log(-1 / 0); console.log(0 / 0); console.log(-0 / 0); console.log(-0 / -0); //在这里打印: //Infinity //-Infinity //0 //-0 //Infinity //-Infinity //NaN //Infinity //-Infinity //Infinity //Infinity //NaN //NaN //NaN //NaN //NaN //NaN //NaN //-Infinity //-Infinity //0 //-0 //NaN //NaN //Infinity //-Infinity //NaN //NaN //NaN polyfill兼容模拟判断一个数值是-0 例子 if(!Number.isNagetiveZero) { Number.isNagetiveZero = function(num) { return typeof num === &quot;number&quot; &amp;&amp; (1 / num === -Infinity); }; } console.log(Number.isNagetiveZero(0)); console.log(Number.isNagetiveZero(-0)); console.log(Number.isNagetiveZero(1 / Infinity)); console.log(Number.isNagetiveZero(-99 / Infinity)); console.log(Number.isNagetiveZero(Infinity / Infinity)); //在这里打印: //false //true //false //true //false parseInt是从字符串首部开始截取字符为数值并转化为数值的函数方法 parseInt函数方法的第一个参数是要进行首部开始截取字符为数值并转化为数值的字符串,而第二个参数则是转化的进制数;parseInt函数方法当遇到并不是字符串的常量或者变量时,它会先将其隐式类型转换为字符串,再进行首部开始截取字符为数值并转化为数值 例子 console.log(parseInt(&quot;468Gary743&quot;)); console.log(parseInt(&quot;Gary468743&quot;)); console.log(parseFloat(&quot;48.6Gary733.4&quot;)); console.log(parseFloat(&quot;Gary48.6733.4&quot;)); console.log([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map((item, index) =&gt; parseInt(item, index))); console.log(parseInt([])); console.log(parseInt([44])); console.log(parseInt([89, 96, 44])); console.log(parseInt(function() {})); console.log(parseInt({})); console.log(parseInt(function() {}, 16)); console.log(parseInt(true)); console.log(parseInt(false, 16)); console.log(parseInt(true, 16)); console.log(parseInt(1/0, 19)); console.log(parseInt(function() {}, 8)); console.log(parseInt(1/-0, 19)); console.log(parseInt([1/0, &quot;68&quot;, false, true], 19)); //在这里打印: //468 //NaN //48.6 //NaN //[1, NaN, NaN] //NaN //44 //89 //NaN //NaN //15 //NaN //250 //NaN //18 //NaN //NaN //18 try {} catch(err) {} finally {} 在ES6的let、const块级作用域之前,Google的Tracer团队就是使用try {} catch(a) {}这种方式来模拟块级作用域,浏览器编译后基本上是以下表达式形式: 例子 function foo() { try { throw undefined; } catch(a) { a = 2; console.log(a); } console.log(a); } foo(); //在这里打印: //2 //ReferrenceError: a is not defined 使用try…catch()…finally了之后,try表达式中的return返回表达式语句不会被执行,会直接跳过,执行finally中的返回表达式语句: 例子 function foo(num) { try { console.log(668); console.log(num + 1); return 100; } catch(error) { console.log(error); } finally { return num; } } console.log(foo(999)); //在这里打印: //668 //1000 //999 == 与 === 的区别 在初学者阶段,被问到 == 与 === 的区别,我一般都会回答==不校验类型,只校验值,===既校验类型,还校验值;而现在的理解是,==进行隐式强制类型转换,而===不进行强制类型转换。 例子 console.log(1 == &quot;1&quot;); console.log(22 === &quot;22&quot;); console.log(true == 1); console.log(false === 0); //在这里打印: //true //false //true //false &amp;&amp; 与 ||的优先级 &amp;&amp;与||是有优先级区分的,&amp;&amp;的优先级是大于||的。 例子 var a = true, b = false, c = true; console.log(b &amp;&amp; a || c); //在这里打印: //true //说明表达式是执行(b &amp;&amp; a) || c,而不是b &amp;&amp; (a || c),如果是后者,那返回就应该是false JSON.stringify将JS对象转化为JSON字符串 JSON.stringify进行转化时,遇到非JSON语法的表达式语句,会转化成undefined或者null,当遇到undefined或者function() {}时,会转化为undefined;当遇到NaN时,会转化为null;当遇到在数组对象中的非JSON语法的表达式语句,会全部转化为null;当遇到对象中的非JSON语法的表达式语句时,会删除掉非法的属性或者属性值 例子 console.log(JSON.stringify(undefined)); console.log(JSON.stringify(null)); console.log(JSON.stringify(function() {})); console.log(JSON.stringify(NaN)); console.log(JSON.stringify([])); console.log(JSON.stringify([function() {}, NaN, null, true, {}, 66, undefined])); console.log(JSON.stringify({})); console.log(JSON.stringify({a: function() {}, b: NaN, c: null, d: true, e: 88, f: undefined, g: [], h: [undefined, NaN, function() {}]})); //在这里打印: //undefined //null //undefined //null //[] //[null, null, null, true, {}, 66, null] //{b: null, c: null, d: true, e: 88, g: [], h: [null, null, null]}]]></content>
      <categories>
        <category>你不知道的Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习图解HTTP一书笔记]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%AD%A6%E4%B9%A0%E5%9B%BE%E8%A7%A3HTTP%E4%B8%80%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTTP协议: 超文本传输协议URI:统一资源标识符URL:统一资源定位符从客户端应用层传输到服务器段应用层的过程: 客户端应用层发出HTTP请求,将数据包加上应用层的首部发送给传输层(TCP), TCP协议将数据包进行分割,分割成多个小数据包,并把小数据包进行标号(用在服务器端传输层以排序整合),之后将这些进行标号的小数据包加上传送层的首部发送给网络层(IP), IP根据地址,进行查询并加上网络层的首部发送至服务器端的网络层(IP)。 接着服务器端的网络层对客户端网络层首部进行去掉的工作,并发送给传输层, 传输层对客户端传输层的首部进行去掉,并且将标号的小数据包根据标号进行排序整合,形成大数据包,发送至服务器的应用层, 服务器的应用层将大数据包的客户端应用层的首部进行去掉的工作,这样则看到了原数据。]]></content>
      <categories>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-03 名言名句]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%90%8D%E8%A8%80%E5%90%8D%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[历史不懂得改变主意的人,什么都改变不了。 —— 温斯顿 丘吉尔上帝要毁灭一个人,必先使其发狂。 —— 西方谚语如果你问丘吉尔,为什么要做议员,他一定会说,”因为我要做大臣”;如果你再问丘吉尔,为什么要做大臣,他会斩钉截铁的说,”因为我要做首相”。 ——英国媒体,大概是《泰晤士报》 人生人们总是容易记得自己是在一条船上,人们总是容易忘记自己是在一条河上。 ——马东苟利国家生死以, 岂因祸福避趋之。 ——林则徐有时候谈理想,在社会上普遍认知是冒傻气,所以我们不要谈理想,而心中有理想,我们需要不谈理想的理想。 ——许子东 文学我们正在培养一批绝对的、精致的利己主义者。 ——钱理群我怕不再有人相信规则能战胜潜规则,我怕不再有人相信学场有别于官场,我怕不再有人相信学术不等于权术,我怕不再有人相信风骨远胜于媚骨。 ——卢新宁]]></content>
      <categories>
        <category>世界观</category>
      </categories>
      <tags>
        <tag>世界观</tag>
        <tag>历史</tag>
        <tag>军事</tag>
        <tag>经济</tag>
        <tag>文学</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-03 关于该不该让女伴侣在自己房本上加名字的理解]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%85%B3%E4%BA%8E%E8%AF%A5%E4%B8%8D%E8%AF%A5%E8%AE%A9%E4%BC%B4%E4%BE%A3%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%88%BF%E6%9C%AC%E4%B8%8A%E5%8A%A0%E5%90%8D%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于该不该让女伴侣在自己房本上加名字的理解关于这个问题,我认为男女双方结婚,就是在开一家公司,经营一家公司的业务,开公司,为了公司可以按照双方一致的目标前行,就要有保障弱势、先付出一方的制度在。很明显,在一段婚姻中,是女方先付出,男方后付出,包括女方的青春、生孩子、照顾家庭。而在现有的社会大体制度下,还远远没有形成男女平等的形势,女性还是处于劣势的,所以在婚姻中,女方也自然而然的是劣势的,所以既然男女双方要共同经营一个家庭、一个共同体,需要首先保障劣势和先付出的一方。所以我认为是该让女伴侣在自己房本上加名字的。]]></content>
      <categories>
        <category>经济学改变世界观</category>
      </categories>
      <tags>
        <tag>经济学</tag>
        <tag>世界观</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-08-25 Javascript设计模式]]></title>
    <url>%2F2018%2F08%2F25%2FJavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 单例模式有两个特点: 全局性和唯一性.全局唯一性是指在全局环境中,只创建对象一次且保证对象在创建过后不被再次创建.下面我们就来演示一下Javascript语言的普通类单例模式和透明单例模式 普通类单例模式function GetSingleton(name) { this.name = name; this.instance = null; } GetSingleton.prototype.getName = function() { return this.name; }; GetSingleton.prototype.Singleton = function(name) { return this.instance || (this.instance = new GetSingleton(name)); }; let gary_one = GetSingleton.prototype.Singleton(&quot;gary_one&quot;); let gary_two = GetSingleton.prototype.Singleton(&quot;gary_two&quot;); //在这里打印: //true console.log(gary_one === gary_two); 普通类单例模式(闭包版本)function GetSingleton(name) { this.name = name; } GetSingleton.prototype.getName = function() { return this.name; }; let Singleton = (function() { let instance; return function(name) { return instance || (instance = new GetSingleton(name)); } })(); let gary_one = Singleton(&quot;gary_one&quot;); let gary_two = Singleton(&quot;gary_two&quot;); //在这里打印: //true console.log(gary_one === gary_two); 透明单例模式let GetSingleton = (function() { let instance; return function(html) { if(instance) { return instance; } this.html = html; this.init(); return instance = this; } })(); GetSingleton.prototype.init = function() { let div = document.createElement(&quot;div&quot;); div.innerHTML = this.html; document.body.appendChild(div); return div; }; let gary_one = new GetSingleton(&quot;gary_one&quot;); let gary_two = new GetSingleton(&quot;gary_two&quot;); //页面上只有创造了一个DIV DOM节点,内容是&quot;gary_one&quot; //在这里打印: //true console.log(gary_one === gary_two); 透明单例模式(代理模式版本)function GetSingleton(html) { this.html = html; this.init(); } GetSingleton.prototype.init = function() { let div = document.createElement(&quot;div&quot;); div.innerHTML = this.html; document.body.appendChild(div); } let Singleton = (function() { let instance; return function(html) { return instance || (instance = new GetSingleton(html)); } })(); let gary_one = new Singleton(&quot;gary_one&quot;); let gary_two = new Singleton(&quot;gary_two&quot;); //页面上只有创造了一个DIV DOM节点,内容是&quot;gary_one&quot; //在这里打印: //true console.log(gary_one === gary_two); Javascript单例模式 ——— 单一对象let obj_only = { a() { console.log(&quot;a&quot;); }, b() { console.log(&quot;b&quot;); } }; //在这里打印: //a obj_only.a(); //在这里打印: //b obj_only.b(); //动态空间对象 let MyApp = {}; MyApp.namespace = function(model) { let parts = model.split(&quot;.&quot;), prototype = MyApp; for(let [key, value] of parts.entries()) { if(!prototype[value]) { prototype[value] = {}; } prototype = prototype[value]; } }; MyApp.namespace(&quot;model&quot;); MyApp.namespace(&quot;div.style&quot;); //在这里打印: //{model: {}, div: {style: {}}} console.log(MyApp); //闭包 function Person() { let _name = &quot;Gary&quot;, _age = 26; return function() { return `name: ${_name}, age: ${_age}`; } } let Gary = Person(); //在这里打印: //name: Gary, age: 26 console.log(Gary()); 惰性单例模式//首先演示的不是惰性单例模式,而是对于创造单个对象有哪几种方式 let GetSingleton = (function (){ let div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;Gary&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div; })(); function Singleton() { document.getElementById(&quot;open&quot;).onclick = function(e) { let singletonDiv = GetSingleton; singletonDiv.style.display = &quot;block&quot;; //取消冒泡事件 e.stopImmediatePropagation(); }; } //这种情况下,无论调不调用Singleton方法,界面在最开始加载时,就已经进行了DOM操作,添加了一个DIV DOM节点,并把这个节点的内容设置为Gary,显示方式设置为none,这种方式的确时创造了单个对象且不可再次创造,但是缺点还是比较明显的,创造不创造单个对象跟绑定事件并没有关系,假如我在页面上并没有触发绑定的事件,页面上在一开始还是具有已经创造好的DIV DOM节点的 Singleton(); function GetSingleton() { let div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;Gary&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div; } function Singleton() { document.getElementById(&quot;open&quot;).onclick = function(e) { let singletonDiv = GetSingleton(); singletonDiv.style.display = &quot;block&quot;; //取消冒泡 e.stopImmediatePropagation(); }; } //这种情况下,满足了调用时再创造单个对象的条件,但是并不满足创造了单个对象并不可再次创造的条件,在这种情况下,每点击一次id为open的按钮一次,就会创造一个对象,这显然是不符合单例模式的特点的 Singleton(); let GetSingleton = (function() { let res; return function() { if(!res) { res = document.createElement(&quot;div&quot;); res.innerHTML = &quot;Gary&quot;; res.style.display = &quot;none&quot;; document.body.appendChild(res); } return res; } })(); function Singleton() { document.getElementById(&quot;open&quot;).onclick = function(e) { let singletonDiv = GetSingleton(); singletonDiv.style.display = &quot;block&quot;; //取消冒泡 e.stopImmediatePropagation(); }; } //这种才是真正的惰性单例模式,在调用绑定事件时才创造单个对象,且也满足创造了单个对象并不可再次创造的条件,但是还是有优化的空间的 Singleton(); 惰性单例模式(优化版本)function GetSingleton(func) { let res; return function() { return res || (res = func.apply(this, arguments)); } } let singleton = GetSingleton(function() { let div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;Gary&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div; }); function Singleton() { document.getElementById(&quot;open&quot;).onclick = function(e) { let singletonDiv = singleton(); singletonDiv.style.display = &quot;block&quot;; //取消冒泡事件 e.stopImmediatePropagation(); }; } //这是惰性单例模式的最终优化版本,最显著的特点时它的复用性,无论是创造任何的DOM节点,只用GetSingleton函数方法,外部传入一个func函数即可,立即满足创造单一对象之后不可再次创建的特点 Singleton(); 惰性单例模式的应用 还记得jQuery工具库的.one函数方法嘛,它就是最经典的单例模式例子,我们今天来模拟一下 function GetSingleton(func) { let res; return function() { return res || (res = func.apply(this, arguments)); } } let bindEvent = GetSingleton(function () { document.getElementById(&quot;open&quot;).onclick = function(e) { alert(&quot;Gary&quot;); //取消冒泡 e.stopImmediatePropagation(); }; console.log(&quot;bind~&quot;); return true; }); function render() { console.log(&quot;开始渲染~&quot;); bindEvent(); } //切实的实现了单例模式&quot;一朝绑定,终生收益&quot;的特性 //在这里打印: //开始渲染~ //bind~ //开始渲染~ //开始渲染~ render(); render(); render(); 策略模式 策略模式的主要条件有三个: 可扩展、可复用和可替换,就让我们先演示一个非策略模式下的例子,我们要计算年终奖,首先要知晓月薪基数,然后再知道奖励倍数,就可以计算出最后的年终奖,一般我们会这么写 function getPerformance(performance, salary) { if(performance === &quot;S&quot;) { return salary * 4; } if(performance === &quot;A&quot;) { return salary * 3; } if(performance === &quot;B&quot;) { return salary * 2; } } //在这里打印: //80000 console.log(getPerformance(&quot;S&quot;, 20000)); //在这里打印: //120000 console.log(getPerformance(&quot;A&quot;, 40000)); 非策略模式的例子,存在很多缺点,首先,策略对象不可复用,策略对象逻辑全都写在一个函数对象里面,并不能拿出进行复用,其次,扩展很不方便,每一次扩展都必须去改变策略对象所处的逻辑函数对象,最后新的策略对象不可替换新的策略对象,接下来我们用传统的策略模式进行解决,首先将策略对象抽取到外面,形成一个抽象的对象 function PerformanceS() { } PerformanceS.prototype.getSalary = function(salary) { return salary * 4; }; function PerformanceA() { } PerformanceA.prototype.getSalary = function(salary) { return salary * 3; }; function PerformanceB() { } PerformanceB.prototype.getSalary = function(salary) { return salary * 2; }; function GetPerformanceSalary() { this.performance = null; this.salary = null; } GetPerformanceSalary.prototype.setPerformance = function(performance) { this.performance = performance; }; GetPerformanceSalary.prototype.setSalary = function(salary) { this.salary = salary; }; GetPerformanceSalary.prototype.getBonus = function() { return this.performance.getSalary(this.salary); }; let getPerformanceSalary = new GetPerformanceSalary(); getPerformanceSalary.setSalary(20000); getPerformanceSalary.setPerformance(new PerformanceS()); //在这里打印: //80000 console.log(getPerformanceSalary.getBonus()); getPerformanceSalary.setSalary(40000); getPerformanceSalary.setPerformance(new PerformanceA()); //在这里打印: //120000 console.log(getPerformanceSalary.getBonus()); 策略模式下的策略对象,复用性、扩展性和替换性都很强,策略对象现在是以抽象函数的形式进行的定义,可以直接拿原有的抽象函数对象进行复用,也可以定义新的抽象函数对象进行扩展,在替换性方面,薪酬基数和策略对象模式都可根据set…方法的方式进行替换,并且得到不同的结果 Javascript策略模式let categories = { S(salary) { return salary * 4; }, A(salary) { return salary * 3; }, B(salary) { return salary * 2; } }; function getPerformance(performance, salary) { return categories[performance](salary); } //在这里打印: //80000 console.log(getPerformance(&quot;S&quot;, 20000)); //在这里打印: //120000 console.log(getPerformance(&quot;A&quot;, 40000)); 策略模式 —— 表单验证 使用策略模式来进行表单验证,也是一种很好的做法,首先我们先不使用策略模式来编写表单验证 function validate() { let userAgent = document.getElementById(&quot;user-agent&quot;); if(userAgent.username.value === &quot;&quot;) { return &quot;用户名不可为空&quot;; } if(userAgent.password.value.length !== 6) { return &quot;密码长度必须为6位&quot;; } if(!/^1(3|5|8)[\d]{9}$/.test(userAgent.phone.value)) { return &quot;手机号码不符合规范&quot;; } } let userAgent = document.getElementById(&quot;user-agent&quot;); userAgent.onsubmit = function(e) { let errMsg = validate(); if(errMsg) { console.log(errMsg); } //取消冒泡事件 e.stopImmediatePropagation(); //取消默认事件 e.preventDefault(); }; 策略对象不可复用,全都处在validate函数作用域下,且不可扩展,扩展必须去更改validate源代码,不符合开放封闭原则,更不能替换在任何的表单校验上面,只能针对特定的表单(name为username,password,phone的表单)进行校验,所以不使用策略模式,效果极差,下面我们就使用策略模式来进行表单校验 let categories = { isNonUsername(value, errMsg) { if(value === &quot;&quot;) { return errMsg; } }, minLength(value, length, errMsg) { if(value.length !== parseInt(length)) { return errMsg; } }, isMobile(value, errMsg) { if(!/^1(3|5|8)[\d]{9}$/.test(value)) { return errMsg; } } }; function Validate() { this.cache = []; } Validate.prototype.add = function(dom, condition, errMsg) { this.cache.push(function() { let parts = condition.split(&quot;:&quot;); let categories_condition = parts.shift(); parts.unshift(dom.value); parts = [...parts, errMsg]; return categories[categories_condition].apply(dom, parts); }); }; Validate.prototype.start = function() { for(let [key, value] of this.cache.entries()) { let validateFunc = value; let errMsg = validateFunc(); if(errMsg) { return errMsg; } } }; function validate() { let userAgent = document.getElementById(&quot;user-agent&quot;), new_validate = new Validate(); new_validate.add(userAgent.username, &quot;isNonUsername&quot;, &quot;用户名不可为空&quot;); new_validate.add(userAgent.password, &quot;minLength:6&quot;, &quot;密码长度必须为6位&quot;); new_validate.add(userAgent.phone, &quot;isMobile&quot;, &quot;手机号码不符合规范&quot;); let errMsg = new_validate.start(); if(errMsg) { return errMsg; } } let userAgent = document.getElementById(&quot;user-agent&quot;); userAgent.onsubmit = function(e) { let errMsg = validate(); if(errMsg) { console.log(errMsg); } //取消冒泡事件 e.stopImmediatePropagation(); //取消默认事件 e.preventDefault(); }; 这样就利用策略模式的复用性、扩展性以及替换性完美的解决了表单验证,你这时可能会有疑问,假如表单里面一个表单项有多个验证条件怎么办,这套策略模式的方式不就不好使了嘛,别急,只要修改一下Validate.prototype.add函数方法,就可以既兼容一个还兼容多个验证条件 let categories = { isNonUsername(value, errMsg) { if(value === &quot;&quot;) { return errMsg; } }, minLength(value, length, errMsg) { if(value.length !== parseInt(length)) { return errMsg; } }, isMobile(value, errMsg) { if(!/^1(3|5|8)[\d]{9}$/.test(value)) { return errMsg; } } }; function Validate() { this.cache = []; } Validate.prototype.add = function(dom, rules) { for(let [key, value] of rules.entries()) { this.cache.push((function() { let condition = value[&quot;condition&quot;], errMsg = value[&quot;errMsg&quot;]; return function() { let parts = condition.split(&quot;:&quot;); let categories_condition = parts.shift(); parts.unshift(dom.value); parts = [...parts, errMsg]; return categories[categories_condition].apply(dom, parts); } })()); } }; Validate.prototype.start = function() { for(let [key, value] of this.cache.entries()) { let validateFunc = value; let errMsg = validateFunc(); if(errMsg) { return errMsg; } } }; function validate() { let userAgent = document.getElementById(&quot;user-agent&quot;), new_validate = new Validate(); new_validate.add(userAgent.username, [{ condition: &quot;isNonUsername&quot;, errMsg: &quot;用户名不可为空&quot; }, { condition: &quot;minLength:10&quot;, errMsg: &quot;用户名长度必须为10位&quot; }]); new_validate.add(userAgent.password, [{ condition: &quot;minLength:6&quot;, errMsg: &quot;密码长度必须为6位&quot; }]); new_validate.add(userAgent.phone, [{ condition: &quot;isMobile&quot;, errMsg: &quot;手机号码不和规范&quot; }]); let errMsg = new_validate.start(); if(errMsg) { return errMsg; } } let userAgent = document.getElementById(&quot;user-agent&quot;); userAgent.onsubmit = function(e) { let errMsg = validate(); if(errMsg) { console.log(errMsg); } //取消冒泡事件 e.stopImmediatePropagation(); //取消默认事件 e.preventDefault(); }; 这样就完美解决了多个验证条件的问题,这种策略模式可复用,可扩展,可替换,十分完美 代理模式 下面我们要介绍的是代理模式,顾名思义,代理模式就是通过代理层去替代实体对象处理一些信息,其实就是在保护实体对象,减少实体对象的职责,在过滤、处理、整合信息之后再交给实体对象,这样会使得实体对象很轻便,对于实体对象的扩展性、维护性以及替换性有很大的帮助 function Flower() { } let xiaoming = { sendFlower(target) { let flower = new Flower(); target.receiveFlower(flower); } }; let A = { receiveFlower(flower) { console.log(&quot;已收到花朵: &quot; + flower); } }; let B = { receiveFlower(flower) { A.receiveFlower(flower); } }; //在这里打印: //已收到花朵: [object Object] xiaoming.sendFlower(B); 这样就形成了一个小明送给女神A花朵表达想和她恋爱的心意,又不太好意思亲自送,只好让他跟A共同的好友B来进行代理送,这就是一个典型的代理模式的例子,你可能会问,这样做有什么意义呢,只不过多了一层罢了,的确这样只是多添加了一层而已,但是假如我们再改编一下剧情,你就会感觉很有意义 function Flower() { } let xiaoming = { sendFlower(target) { let flower = new Flower(); target.receiveFlower(flower); } }; let A = { receiveFlower(flower) { console.log(&quot;已收到花朵: &quot; + flower); }, listenerBeHappy(func) { let self = this; setTimeout(function() { func.apply(self); }, 1000); } }; let B = { receiveFlower(flower) { A.listenerBeHappy(function () { this.receiveFlower(flower); }); } }; //在这里打印: //已收到花朵: [object Object] xiaoming.sendFlower(B); 故事的剧情转变成了这样,小明送给女神A花朵表达想和她恋爱的心意,又不太好意思亲自送,只好让他跟A共同的好友B来进行代理送,B清楚A什么时间心情最好,什么时间可以接受别人对她的表白,所以B在A心情很好的时候将小明的花朵转交给女神A,虽然也不见得小明的追求会成功,但是B的代理工作充分表明了代理模式 虚拟代理 我们使用虚拟代理来写一个懒加载图片的例子,通常我们使用Js写加载图片时,一般会这么做 let loadImage = (function () { let Image = document.createElement(&quot;img&quot;); document.body.appendChild(Image); return { setSrc(src) { Image.src = src; } } })(); loadImage.setSrc(&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;); 但是这样做有一个用户体验的交互问题,图片还没有完全渲染的时候,图片区域是空白的,这时候我们需要使用代理来虚拟在图片还没有完全渲染完毕的时候,先在所在区域展示loading加载图,当图片完全渲染完毕之后,再将所在区域替换成图片 let loadImage = (function () { let Image = document.createElement(&quot;img&quot;); document.body.appendChild(Image); return { setSrc(src) { Image.src = src; } } })(); let proxyLoadImage = (function () { let img = new Image(); img.onload = function() { loadImage.setSrc(this.src); }; return { setSrc(src) { loadImage.setSrc(&quot;../img/zy.jpeg&quot;); img.src = src; } } })(); proxyLoadImage.setSrc(&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;); 虚拟代理模式对于用户是无感的,用户不会知道你使用的是实体对象接口还是虚拟代理对象接口,且虚拟代理对象的复用性、扩展性以及可替换性都是很完美的,完全不会破坏原有的实体对象的代码结构,下面我们来写一个使用虚拟代理模式实现批量提交文件,节省浏览器和后台服务器资源的例子 function syncReadFile(id) { console.log(&quot;开始上传文件: &quot; + id); } let checkbox = document.getElementsByName(&quot;checkbox&quot;); for(let i = 0; i &lt; checkbox.length; i ++) { checkbox[i].onclick = function(e) { if(this.checked) { syncReadFile(this.id); } //取消冒泡事件 e.stopImmediatePropagation(); }; } 这个例子,我每点一次复选框,且复选框选中,就会上传文件,在短时间内选中多个复选框,会造成大量的上传请求发出,频繁的调用上传接口,会大量浪费浏览器和后台服务器资源,所以我们设置一个函数节流函数来模拟syncReadFile函数,相当于是一个虚拟代理模式的函数,节省浏览器和后台服务器资源 function syncReadFile(id) { console.log(&quot;开始上传文件: &quot; + id); } let proxySyncReadFile = (function() { let cache = [], timer = null; return function (id) { let self = this; cache = [...cache, id]; if(timer) { return false; } timer = setTimeout(function () { let id_transform = cache.join(&quot;,&quot;); syncReadFile.call(self, id_transform); clearTimeout(timer); timer = null; cache.length = 0; }, 2000); } })(); let checkbox = document.getElementsByName(&quot;checkbox&quot;); for(let i = 0; i &lt; checkbox.length; i ++) { checkbox[i].onclick = function (e) { if(this.checked) { proxySyncReadFile(this.id); } //取消冒泡事件 e.stopImmediatePropagation(); }; } 缓存代理 我们先来写一个缓存代理计算乘积的例子,当传入的参数与上一次传入的参数相同时,就使用缓存中的乘积结果,不需要再次进行计算 function getMultiple() { let cache = {}; function multiple() { let a = 1; for(let i = 0; i &lt; arguments.length; i ++) { a *= arguments[i]; } return a; } return function() { let cache_prototype = Array.prototype.join.call(arguments, &quot;_&quot;); if(cache[cache_prototype]) { return cache[cache_prototype]; } console.log(&quot;again&quot;); return cache[cache_prototype] = multiple.apply(this, arguments); } } let multipleForReal = getMultiple(); //在这里打印: //again //168 console.log(multipleForReal(4, 6, 7)); //在这里打印: //168 console.log(multipleForReal(4, 6, 7)); 让我们将事情变得更有趣一些 function plus() { let a = 0; for(let i = 0; i &lt; arguments.length; i ++) { a += arguments[i]; } return a; } function multiple() { let a = 1; for(let i = 0; i &lt; arguments.length; i ++) { a *= arguments[i]; } return a; } function getMethod(func) { let cache = {}; return function () { let cache_prototype = Array.prototype.join.call(arguments, &quot;_&quot;); if(cache[cache_prototype]) { return cache[cache_prototype]; } console.log(&quot;again&quot;); return cache[cache_prototype] = func.apply(this, arguments); } } let getMethodResult = getMethod(plus); //在这里打印: //again //20 console.log(getMethodResult(4, 8, 8)); //在这里打印: //20 console.log(getMethodResult(4, 8, 8)); let getMethodResult_multiple = getMethod(multiple); //在这里打印: //again //256 console.log(getMethodResult_multiple(4, 8, 8)); //在这里打印: //256 console.log(getMethodResult_multiple(4, 8, 8)); 迭代器模式 除了某一些古代的语言,现代的程序语言都实现了内置迭代器,迭代器模式或许从来都没有被人所听说过,我们今天就用JavaScript来模拟迭代器模式 function each(arr, func) { for(let [key, value] of arr.entries()) { func.call(this, key, value); } } //在这里打印: //0 2 //1 6 //2 8 each([2, 6, 8], function (index, item) { console.log(index, item); }); 这只是内部迭代器模式,将迭代逻辑放在内部实现,但是这样做很不灵活,比如我要实现一个俩数组是否相等的函数compare,你会发现compare的实现方式并不美观,且很不灵活 function each(arr, func) { for(let [key, value] of arr.entries()) { func.call(this, key, value); } } function compare(arr, arrAno) { if(arr.length !== arrAno.length) { throw new Error(&quot;两个数组不相同&quot;); } each(arr, function (index, item) { if(item !== arrAno[index]) { throw new Error(&quot;两个数组不相同&quot;); } }); console.log(&quot;两个数组是相同的&quot;); } //在这里打印: //两个数组是相同的 compare([1, 2, 5], [1, 2, 5]); //在这里报错: //两个数组不相同 compare([1, 2, 8], [1, 3, 6]); 外部迭代模式 后来出现了外部迭代模式,代码如下,这种迭代模式,灵活的解决了外部传入迭代器时,一些比较复杂的需求,维护性、扩展性、灵活性都很高,且针对对象和数组,只要拥有length属性的对象都可以进行迭代 function Iterator(obj) { let index = 0, length = obj.length; function next() { index++; } function isDone() { return index &lt; length; } function getCurrentItem() { return obj[index]; } return { length, next, isDone, getCurrentItem } } let iterator_arr = Iterator([55, 66, 99, 10, 1, 11, 28, 32]); //在这里打印: //55 //66 //99 //10 //1 //11 //28 //32 while(iterator_arr.isDone()) { console.log(iterator_arr.getCurrentItem()); iterator_arr.next(); } 这样的话,我们来编写compare函数进行两个函数比对时,就会灵活,更可维护的多 function Iterator(obj) { let index = 0, length = obj.length; function next() { index++; } function getCurrentItem() { return obj[index]; } function isDone() { return index &gt;= length; } return { length, isDone, getCurrentItem, next }; } function compare(arr, arrAno) { if(arr.length !== arrAno.length) { throw new Error(&quot;两个数组不相同&quot;); } while(!arr.isDone() &amp;&amp; !arrAno.isDone()) { if(arr.getCurrentItem() !== arrAno.getCurrentItem()) { throw new Error(&quot;两个数组不相同&quot;); } arr.next(); arrAno.next(); } console.log(&quot;两个数组是相同的&quot;); } let iterator = Iterator([1, 6, 8, 10, 55, 25, 36, 96]); let iterator_ano = Iterator([1, 6, 8, 10, 55, 25, 36, 96]); let iterator_diff = Iterator([1, 6, 8, 10, 55, 25, 36, 96]); let iterator_diff_ano = Iterator([1, 6, 8, 10, 55, 28, 36, 96]); //在这里打印: //两个数组是相同的 compare(iterator, iterator_ano); //在这里报错: //两个数组不相同 compare(iterator_diff, iterator_diff_ano); jQuery中的each方法,就提供了迭代的功能,但是each方法不仅可以迭代数组,还可以迭代对象,我们来看一下each方法的源代码实现方式 $.each = function (obj, func) { let value, i = 0, length = obj.length; if(Object.prototype.toString.call(obj) === &quot;[object Array]&quot;) { for(; i &lt; length; i++) { value = func.call(this, i, obj[i]); if(value === false) { break; } } } else { for(i in obj) { value = func.call(this, i, obj[i]); if(value === false) { break; } } } } //在这里打印: //0 5 //1 8 //2 10 $.each([5, 8, 10, 3, 66], function (index, item) { if(item === 3) { return false; } console.log(index, item); }); 这期间还使用了中断迭代器模式的判断语句 if(value === false) break;当函数返回false的时候,就将迭代器终止掉,直接break出for循环,下面我们来介绍反向迭代函数,我们分分钟搞定 function reverseEach(obj, func) { let value; for(let l = obj.length - 1; l &gt;=0; l--) { value = func.call(this, l, obj[l]); if(value === false) { break; } } } //在这里打印: //4 101 //3 99 //2 66 reverseEach([10, 88, 66, 99, 101], function (index, item) { if(item === 88) { return false; } console.log(index, item); });]]></content>
      <categories>
        <category>Javascript设计模式</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-21 使用Canvas绘制圆角按钮]]></title>
    <url>%2F2018%2F05%2F21%2F%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[使用Canvas可视化工具绘制圆角按钮 最近刚接触了Canvas可视化工具,下面通过一个使用Canvas绘制的圆角按钮的例子,来实践学到的Canvas经验 //对加载完成事件的封装,在本人写的日志2018-05-06-封装的一些小工具中有详细描述,在这里不再做更多的赘述 let addEvent = (eventLoad) =&gt; { let load = window.onload; if(typeof load !== &quot;function&quot;) { window.onload = eventLoad; } else { window.onload = function() { load(); eventLoad(); }; } }; //Canvas绘制圆角按钮的函数 let canvasRadiusButton = () =&gt; { //假如DOM-Core中不存在getElementById方法,则返回false,退出函数 if(!document.getElementById) return false; //假如DOM-Core中不存在createElement方法,则返回false,退出函数 if(!document.createElement) return false; //假如DOM中不存在id名为home的元素节点,则返回false,退出函数 if(!document.getElementById(&quot;home&quot;)) return false; //获取id名为home的元素节点 let home = document.getElementById(&quot;home&quot;), //创造出canvas元素节点标签 canvas = document.createElement(&quot;canvas&quot;); //设置canvas元素节点标签的宽度和高度都为200px canvas.width = 200; canvas.height = 200; //设置canvas绘制画布的类型为: 2d(平面画布) let ctx = canvas.getContext(&quot;2d&quot;); //绘制画布开始绘制路径 ctx.beginPath(); //设置绘制画布的起点坐标为: (12, 20) ctx.moveTo(12, 20); //使用贝塞尔曲线去绘制圆角 //bezierCurveTo方法有三组坐标参数,前面两组为两个控制点位置,利用这两个控制点可以完美的画出半圆、椭圆甚至是圆角,最后一组为曲线终点的位置 ctx.bezierCurveTo(12, 16, 15, 14, 19, 14); //绘制直线至画布的(129, 14)坐标 ctx.lineTo(129, 14); //继续使用贝塞尔曲线绘制圆角 ctx.bezierCurveTo(133, 14, 136, 16, 136, 20); //绘制直线至画布的(136, 45)坐标 ctx.lineTo(136, 45); //继续使用贝塞尔曲线绘制圆角 ctx.bezierCurveTo(136, 49, 133, 51, 129, 51); //绘制直线至画布的(19, 51)坐标 ctx.lineTo(19, 51); //继续使用贝塞尔曲线绘制圆角 ctx.bezierCurveTo(15, 51, 12, 49, 12, 45); //绘制直线至画布的(12, 20)坐标 ctx.lineTo(12, 20); //绘制画布结束绘制路径 ctx.closePath(); //设置画布路径的填充样式为: rgba(255, 255, 0, 0.8) ctx.fillStyle = &quot;rgba(255, 255, 0, 0.8)&quot;; //进行画布填充 ctx.fill(); //设置画布路径的color样式为: rgba(255, 0, 0, 0.5) ctx.strokeStyle = &quot;rgba(255, 0, 0, 0.5)&quot;; //画布路径绘制完毕,实现绘制模型 ctx.stroke(); //将canvas元素节点添加到home元素节点里面,作为home元素节点的子节点 home.appendChild(canvas); }; addEvent(canvasRadiusButton);]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-21 Javascript数据结构与算法]]></title>
    <url>%2F2018%2F05%2F21%2FJavascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[栈 Stack 栈是数据结构中比较简单的顺序数据结构,特点是: 后进先出,新的元素或者你也可以理解为待删除的元素更接近与栈顶,而旧的元素更接近于栈底,生活中有很多栈的例子,比如说堆在一起的书,再比如说特别拥挤的地铁,你可以理解为任何只有一个出口的事物,都可以作为栈来使用,在Javascript中,我们可以使用数组来模拟栈的实现,首先是ES5版本 //全局声明一个数组变量: stack_mock let stack_mock = []; //声明一个函数,这里当作栈Stack的类 function Stack (){ } //向栈内添加元素 Stack.prototype.push = function(element) { return stack_mock.push(element); }; //栈顶删除元素 Stack.prototype.pop = function() { return stack_mock.pop(); }; //校验栈是否为空 Stack.prototype.isEmpty = function() { return stack_mock.length === 0; }; //获取栈顶的元素 Stack.prototype.peek = function() { let len = stack_mock.length; return stack_mock[len - 1]; }; //获取栈内元素的个数 Stack.prototype.size = function() { return stack_mock.length; }; //对栈内所有元素进行打印 Stack.prototype.print = function() { return stack_mock.toString(); }; //对栈进行清空 Stack.prototype.clear = function() { stack_mock = []; }; //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这种方式stack_mock数组变量暴露在全局中,其他人可以随意修改,很不安全,且一个类的实例只能对应一个类似stack_mock的数组变量,很不方便,所以最好放在类的内部或者与类进行映射,下面是改进之后的ES6版本 //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部定义stack_mock属性,并初始化为空数组 this[&quot;stack_mock&quot;] = []; } //向栈内添加元素 push(element) { return this[&quot;stack_mock&quot;].push(element); } //栈顶删除元素 pop() { return this[&quot;stack_mock&quot;].pop(); } //校验栈是否为空 isEmpty() { return this[&quot;stack_mock&quot;].length === 0; } //获取栈顶元素 peek() { let len = this[&quot;stack_mock&quot;].length; return this[&quot;stack_mock&quot;][len - 1]; } //获取栈内元素的个数 size() { return this[&quot;stack_mock&quot;].length; } //对栈内所有元素进行打印 print() { return this[&quot;stack_mock&quot;].toString(); } //对栈进行清空 clear() { this[&quot;stack_mock&quot;] = []; } } //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这种方式不仅避免了数组变量暴露在全局被随意修改的风险,还避免了一个数组变量只能对应一个类的实例的窘境,但是在类函数内部的属性,通过实例是可以进行获取和修改的,所以内部属性被随意修改的问题又暴露了出来,类似于这样 //声明一个栈Stack类的实例 let stack = new Stack(); //获取到类函数内部属性&quot;stack_mock&quot; let stack_mock = stack[&quot;stack_mock&quot;]; //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //设置类函数内部属性&quot;stack_mock&quot;为空数组 stack[&quot;stack_mock&quot;] = []; //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //&quot;&quot; console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //undefined console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 明明已经添加到栈内的元素,直接被外部设置内部属性为空数组,给删除掉了,这岂不是很尴尬,所以想要利用Symbol ES6中这种枚举新语法进行改进 //声明一个可公用的Symbol的枚举变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let Stack = (function (){ let stack_mock = Symbol(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部定义stack_mock Symbol属性,并初始化为空数组 this[stack_mock] = []; } //向栈内添加元素 push(element) { return this[stack_mock].push(element); } //栈顶删除元素 pop() { return this[stack_mock].pop(); } //校验栈是否为空 isEmpty() { return this[stack_mock].length === 0; } //获取栈顶元素 peek() { let len = this[stack_mock].length; return this[stack_mock][len - 1]; } //获取栈内元素的个数 size() { return this[stack_mock].length; } //对栈内所有元素进行打印 print() { return this[stack_mock].toString(); } //对栈进行清空 clear() { this[stack_mock] = []; } } //返回类函数Stack return Stack; })(); //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这时候外部类的实例,看样子好想完全拿不到内部的Symbol枚举属性,其实有两种方式可以完全拿到:getOwnPropertySymbols(仅可以拿到对象的Symbol枚举属性,包含继承)和Reflect.ownKeys(无论是Symbol枚举属性还是对象自身所拥有的属性都可以拿到,也包含继承),这时候去获取到Symbol枚举属性,并进行设置为空数组,依然可以在外部删除内部枚举属性数组的元素,类似于这样 //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //获取内部的Symbol枚举属性 //两种方式都可以 //let stack_mock = Object.getOwnPropertySymbols(stack)[0]; let stack_mock = Reflect.ownKeys(stack)[0]; //设置内部的Symbol枚举属性值为空数组 stack[stack_mock] = []; //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //&quot;&quot; console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //undefined console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 针对这种情况,尝试使用WeakMap集合来解决,WeakMap是Map的一种形式,它只能设置key为对象的属性,且在无法通过类实例的任何方法来获取并设置 let Stack = (function (){ //声明一个可公用的WeakMap的集合变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let stack_mock = new WeakMap(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 stack_mock.set(this, []); } //向栈内添加元素 push(element) { let stack_arr = stack_mock.get(this); let stack_index = stack_arr.push(element); stack_mock.set(this, stack_arr); return stack_index; } //栈顶删除元素 pop() { let stack_arr = stack_mock.get(this); let stack_item = stack_arr.pop(); stack_mock.set(this, stack_arr); return stack_item; } //校验栈是否为空 isEmpty() { let stack_arr = stack_mock.get(this); return stack_arr.length === 0; } //获取栈顶元素 peek() { let stack_arr = stack_mock.get(this), len = stack_arr.length; return stack_arr[len - 1]; } //获取栈内元素的个数 size() { let stack_arr = stack_mock.get(this); return stack_arr.length; } //对栈内所有元素进行打印 print() { let stack_arr = stack_mock.get(this); return stack_arr.toString(); } //对栈进行清空 clear() { stack_mock.set(this, []); } } //返回类函数Stack return Stack; })(); //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这样就完美的写出了一个栈 Stack类函数,内部WeakMap集合属性设置类的数组,不可获取且修改,全局下也不可轻易的拿到且进行随意的修改,具有良好的封装性、安全性、扩展性以及可维护性 使用栈解决计算机科学中的经典算法问题十进制转化为二进制 首先你要知道十进制转化二进制的原理,先从二进制转化为十进制说起,二进制中只有0和1,在相加时就是足2进1,比如说10这个十进制整数,转化为二进制就是1010,二进制分离转化十进制:1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0相加就是10这个十进制整数,所以十进制转化为二进制,就需要对2取余,取余之后再除以2到达下一位数,依次将余数添加进栈中,再依次从栈顶取出并删除栈顶元素,十进制转化为二进制是遵从栈后进先出的特点的 let Stack = (function (){ //声明一个可公用的WeakMap的集合变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let stack_mock = new WeakMap(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 stack_mock.set(this, []); } //向栈内添加元素 push(element) { let stack_arr = stack_mock.get(this); let stack_index = stack_arr.push(element); stack_mock.set(this, stack_arr); return stack_index; } //栈顶删除元素 pop() { let stack_arr = stack_mock.get(this); let stack_item = stack_arr.pop(); stack_mock.set(this, stack_arr); return stack_item; } //校验栈是否为空 isEmpty() { let stack_arr = stack_mock.get(this); return stack_arr.length === 0; } //获取栈顶元素 peek() { let stack_arr = stack_mock.get(this), len = stack_arr.length; return stack_arr[len - 1]; } //获取栈内元素的个数 size() { let stack_arr = stack_mock.get(this); return stack_arr.length; } //对栈内所有元素进行打印 print() { let stack_arr = stack_mock.get(this); return stack_arr.toString(); } //对栈进行清空 clear() { stack_mock.set(this, []); } } //返回类函数Stack return Stack; })(); /**进行十进制转化为二进制的函数 * @params decimal 传进去的十进制参数 */ let DecimalConversionBinary = (decimal)=&gt; { //声明一个栈Stack类的实例 let stack = new Stack(), //声明一个承接%2之后的余数的变量 decimal_remainder, //声明一个承接最终二进制的字符串变量,初始化为空字符串 result_binary = &quot;&quot;, //声明一个承接十进制的变量 decimal_integer = decimal; //在十进制的变量除以2还不为0时,继续执行循环 while(decimal_integer / 2){ //将十进制的变量对2进行取余,余数赋值给承接余数的变量 decimal_remainder = decimal_integer % 2; //将余数添加进栈中 stack.push(decimal_remainder); //十进制的变量取余后,再除以2向下取整,到达下一位数,复制给十进制的变量 decimal_integer = Math.floor(decimal_integer / 2); } //检测栈是否为空,如果不为空,则继续执行循环 while(!stack.isEmpty()){ //承接二进制字符串的变量不断的拼接栈顶的元素,而栈顶元素也不断在被删除 result_binary += stack.pop(); } //待到栈顶元素彻底删除完毕,栈为空栈了,就返回最终的二进制变量 return result_binary; }; let binary = DecimalConversionBinary(10); //在这里打印: //1010 console.log(binary); 十进制转化为任何进制 十进制转化为任何进制的原理跟二进制是一样的,只不过除以的数值变了,所以需要外部传入,这样做的比较通用 let Stack = (function (){ //声明一个可公用的WeakMap的集合变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let stack_mock = new WeakMap(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 stack_mock.set(this, []); } //向栈内添加元素 push(element) { let stack_arr = stack_mock.get(this); let stack_index = stack_arr.push(element); stack_mock.set(this, stack_arr); return stack_index; } //栈顶删除元素 pop() { let stack_arr = stack_mock.get(this); let stack_item = stack_arr.pop(); stack_mock.set(this, stack_arr); return stack_item; } //校验栈是否为空 isEmpty() { let stack_arr = stack_mock.get(this); return stack_arr.length === 0; } //获取栈顶元素 peek() { let stack_arr = stack_mock.get(this), len = stack_arr.length; return stack_arr[len - 1]; } //获取栈内元素的个数 size() { let stack_arr = stack_mock.get(this); return stack_arr.length; } //对栈内所有元素进行打印 print() { let stack_arr = stack_mock.get(this); return stack_arr.toString(); } //对栈进行清空 clear() { stack_mock.set(this, []); } } //返回类函数Stack return Stack; })(); /**进行十进制转化为任何进制的函数 * @params decimal 传进去的十进制参数 * @params radix 表示十进制要转化的进制类型 */ let DecimalConversionRadix = (decimal, radix)=&gt; { //声明一个栈Stack类的实例 let stack = new Stack(), //声明一个承接%radix之后的余数的变量 decimal_remainder, //声明一个承接最终外部传入进制的字符串变量,初始化为空字符串 result_radix = &quot;&quot;, //声明一个承接十进制的变量 decimal_integer = decimal, //各个进制栈中的进制位数所对应的字符文本,最多十六进制,最少二进制 radix_formatter = &quot;0123456789ABCDEF&quot;; //在十进制的变量除以radix还不为0时,继续执行循环 while(decimal_integer / radix){ //将十进制的变量对radix进行取余,余数赋值给承接余数的变量 decimal_remainder = decimal_integer % radix; //将余数添加进栈中 stack.push(decimal_remainder); //十进制的变量取余后,再除以radix向下取整,到达下一位数,复制给十进制的变量 decimal_integer = Math.floor(decimal_integer / radix); } //检测栈是否为空,如果不为空,则继续执行循环 while(!stack.isEmpty()){ //承接外部传入进制字符串的变量不断的拼接栈顶的元素所对应的字符文本,而栈顶元素也不断在被删除 result_radix += radix_formatter[stack.pop()]; } //待到栈顶元素彻底删除完毕,栈为空栈了,就返回最终的外部传入进制变量 return result_radix; }; //这里传入的进制类型是二进制 let radix = DecimalConversionRadix(10, 2); //在这里打印: //1010 console.log(radix); //这里传入的进制类型是十六进制 let radix_ano = DecimalConversionRadix(100, 16); //在这里打印: //64 console.log(radix_ano); 队列 Queue 队列也是数据结构中比较简单的顺序数据结构,和栈相似,特点是: 先进先出,新的元素都会添加到队列的末尾,等待队列中之前已经添加的元素删除掉,现实生活中也有好多队列的例子,排队就是很常见的例子,在医院排队挂号、在食堂排队打饭、在抢票软件中排队抢票等等一系列都是队列的表现,经过栈Stack一系列的对类函数Stack的优化改进,在和栈Stack相似的队列Queue这里就不再赘述,我们直接写最终的优化改进的ES6版本 let Queue = (function() { //声明一个可公用的WeakMap的集合变量: queue_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let queue_mock = new WeakMap(); //声明一个类函数,这里当作队列Queue的类 class Queue { constructor(){ //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 queue_mock.set(this, []); } //向队列末尾中添加新的元素 enqueue(element) { let queue_arr = queue_mock.get(this); let queue_index = queue_arr.push(element); queue_mock.set(this, queue_arr); return queue_index; } //将队列列头的元素删除掉 dequeue() { let queue_arr = queue_mock.get(this); let queue_item = queue_arr.shift(); queue_mock.set(this, queue_arr); return queue_item; } //检测队列是否为空 isEmpty() { return queue_mock.get(this).length === 0; } //获取队列中元素的个数 size() { return queue_mock.get(this).length; } //将队列清空 clear() { queue_mock.set(this, []); } //将队列中所有的元素进行打印 print() { return queue_mock.get(this).toString(); } //获取队列列头的元素 front() { return queue_mock.get(this)[0]; } } })(); //声明一个队列Queue类实例 let queue = new Queue(); //这里判断队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //向队列中添加元素 queue.enqueue(&quot;Gary&quot;); queue.enqueue(&quot;Lily&quot;); queue.enqueue(&quot;Simon&quot;); queue.enqueue(&quot;Aaron&quot;); //这里打印队列添加元素的返回值 //在这里打印队列中元素的个数: //5 console.log(queue.enqueue(&quot;Frank&quot;)); //这里判断队列是否为空 //在这里打印: //false console.log(queue.isEmpty()); //这里打印队列中元素的个数 //在这里打印: //5 console.log(queue.size()); //这里打印队列中列头的元素 //在这里打印: //&quot;Gary&quot; console.log(queue.front()); //这里打印队列中所有的元素 //在这里打印: //Gary,Lily,Simon,Aaron,Frank console.log(queue.print()); //这里将队列列头的元素删除 //在这里打印列头的元素: //&quot;Gary&quot; console.log(queue.dequeue()); queue.dequeue(); queue.dequeue(); //这里打印队列中元素的个数 //在这里打印: //2 console.log(queue.size()); //这里打印队列中列头的元素 //在这里打印: //&quot;Aaron&quot; console.log(queue.front()); //将队列清空 queue.clear(); //这里判断队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //这里打印队列中元素的个数 //在这里打印: //0 console.log(queue.size()); 优先队列 队列有时需要根据某些参数进行优先级处理,比如我们乘坐飞机,购买飞机票,分为头等舱、商务舱和经济舱,头等舱的优先级最高,经济舱的优先级最低,所以在进行队列处理时,需要根据优先级进行排列 let Queue = (function () { //声明一个可公用的WeakMap的集合变量: queue_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let queue_mock = new WeakMap(); //声明一个队列优先级类函数 //生成队列元素优先级实例 class Queue_Prior { constructor(element, prior) { this.element = element; this.prior = prior; } } //声明一个类函数,这里当作队列Queue的类 class Queue { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 queue_mock.set(this, []); } //根据优先级向队列中添加优先级实例元素 enqueue(element, prior) { //生成队列优先级实例元素 let queue_prior = new Queue_Prior(element, prior), //获取现状态的队列 queue_arr = queue_mock.get(this), len = queue_arr.length, index = 0; //循环现状态的队列,假如队列中存在元素优先级比实例优先级小的,就插入到小优先级队列元素之前 while(index &lt; len) { if(queue_arr[index][&quot;prior&quot;] &gt; queue_prior[&quot;prior&quot;]) { queue_arr.splice(index, 0, queue_prior); queue_mock.set(this, queue_arr); return index + 1; } index++; } //假如不存在,就直接添加到队列列尾 index = queue_arr.push(queue_prior); queue_mock.set(this, queue_arr); return index; } //对队列列头的元素进行删除 dequeue() { let queue_arr = queue_mock.get(this); let queue_index = queue_arr.shift(); queue_mock.set(this, queue_arr); return queue_index; } //判断队列是否为空 isEmpty() { return queue_mock.get(this).length === 0; } //获取队列中的元素个数 size() { return queue_mock.get(this).length; } //对队列进行清空 clear() { queue_mock.set(this, []); } //获取队列列头的元素 front() { return queue_mock.get(this)[0]; } //对队列中的所有的元素进行打印 print() { let queue_arr = queue_mock.get(this); let len = queue_arr.length; let queue_toString_arr = []; for(let i = 0; i &lt; len; i++) { queue_toString_arr.push(queue_arr[i][&quot;element&quot;]); } return queue_toString_arr.toString(); } } //返回队列Queue队列 return Queue; })(); //声明一个优先队列Queue类实例 let queue = new Queue(); //这里判断优先队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //向优先队列中添加元素 queue.enqueue(&quot;Gary&quot;, 1); queue.enqueue(&quot;Lily&quot;, 2); queue.enqueue(&quot;Simon&quot;, 1); queue.enqueue(&quot;Aaron&quot;, 3); //这里打印优先队列添加元素的返回值 //在这里打印优先队列添加元素的位置: //4 console.log(queue.enqueue(&quot;Frank&quot;, 2)); //这里判断优先队列是否为空 //在这里打印: //false console.log(queue.isEmpty()); //这里打印优先队列中元素的个数 //在这里打印: //5 console.log(queue.size()); //这里打印优先队列中列头的元素 //在这里打印: //{element: &quot;Gary&quot;, prior: 1} console.log(queue.front()); //这里打印优先队列中所有的元素 //在这里打印: //Gary,Simon,Lily,Frank,Aaron console.log(queue.print()); //这里将优先队列列头的元素删除 //在这里打印列头的元素: //{element: &quot;Gary&quot;, prior: 1} console.log(queue.dequeue()); queue.dequeue(); queue.dequeue(); //这里打印优先队列中元素的个数 //在这里打印: //2 console.log(queue.size()); //这里打印优先队列中列头的元素 //在这里打印: //{element: &quot;Frank&quot;, prior: 2} console.log(queue.front()); //将优先队列清空 queue.clear(); //这里判断优先队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //这里打印优先队列中元素的个数 //在这里打印: //0 console.log(queue.size()); 循环队列使用循环队列解决计算机经典算法 - 击鼓传花 用队列来实现击鼓传花,再合适不过了,给定一个数组以及传递的次数作为函数的参数 let Queue = (function () { //声明一个可公用的WeakMap的集合变量: queue_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let queue_mock = new WeakMap(); //声明一个类函数,这里当作队列Queue的类 class Queue { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 queue_mock.set(this, []); } //向队列末尾中添加新的元素 enqueue(element) { let queue_arr = queue_mock.get(this); let queue_index = queue_arr.push(element); queue_mock.set(this, queue_arr); return queue_index; } //将队列列头的元素删除掉 dequeue() { let queue_arr = queue_mock.get(this); let queue_item = queue_arr.shift(); queue_mock.set(this, queue_arr); return queue_item; } //检测队列是否为空 isEmpty() { return queue_mock.get(this).length === 0; } //获取队列中的元素个数 size() { return queue_mock.get(this).length; } //对队列进行清空 clear() { queue_mock.set(this, []); } //对队列中的所有的元素进行打印 print() { return queue_mock.get(this).toString(); } //对队列中的所有的元素进行打印 front() { return queue_mock.get(this)[0]; } } return Queue; })(); //击鼓传花函数 //@params queueList 数组 //@params count 传递的次数 function passThePaperFlower(queueList, count) { //声明一个循环队列Queue类的实例 let queue = new Queue(); //遍历数组,将数组元素添加到队列中 for(let i = 0; i &lt; queueList.length; i++) { queue.enqueue(queueList[i]); } //只要队列中的元素大于1,就继续循环 while(queue.size() &gt; 1) { //遍历传递的次数,将队列列头的元素(就是击鼓传花中要淘汰的人)删除掉,再添加到队列的列尾 for(let j = 0; j &lt; count; j++) { queue.enqueue(queue.dequeue()); } //获取到传递完之后,队列列头的元素 let queueItem = queue.dequeue(); console.log(`${queueItem}被淘汰~`); } //返回队列中仅剩的最后的击鼓传花大赢家 return queue.front(); } //给定的进行击鼓传花的人 let paperFlowerParticipant = [&quot;Gary&quot;, &quot;Lily&quot;, &quot;Aaron&quot;, &quot;Alice&quot;, &quot;Simon&quot;, &quot;Frank&quot;]; //队列中仅剩的最后的击鼓传花大赢家 let finallyGet = passThePaperFlower(paperFlowerParticipant, 10); //对最后的击鼓传花大赢家进行打印 console.log(&quot;最后的赢家是:&quot; + finallyGet); 链表 LinkList 前面说了栈和队列简单的顺序数据结构,下面介绍一下最后的顺序数据结构: 链表 LinkList,链表相比于栈和队列的优点在于: 栈和队列会直接对内部元素进行添加、修改以及删除的操作,使得其他内存元素的位置发生改变(其他元素前移或者后移),大量的消耗内存,而链表不会破坏内存元素的位置,假如进行添加、修改以及删除的操作,直接断开中间的一个环节,将这个环节的前一个环节以及后一个环节重连就可以了,生活中也有很多链表的例子: 比如说火车,火车的车厢都是一环连着一环的,和链表差不多 let LinkList = (function() { //定义链表头部的链表元素,并在初始化时设置为null //定义链表的长度,并在初始化时设置为0 let head = new WeakMap(), length = new WeakMap(); //声明链表元素Node对象的类函数 //初始化有两个参数 //@param node 现链表元素的值 //@param next 用来链接下一个链表元素 class Node { constructor(node) { this.node = node; this.next = null; } } //声明链表LinkList对象的类函数 class LinkList { constructor() { head.set(this, null); length.set(this, 0); } //向链表中添加链表元素 insert(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, node = new Node(element); if(!headElement) { headElement = node; } else { while(current.next) { current = current.next; } current.next = node; } lengths++; head.set(this, headElement); length.set(this, lengths); return lengths; } //向链表的指定位置添加链表元素 insertAt(element, position) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, previous, node = new Node(element); if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!headElement) { headElement = node; } else { if(position === 0) { node.next = current; headElement = node; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.next = current; } } lengths++; head.set(this, headElement); length.set(this, lengths); return position; } return false; } //删除链表中的指定链表元素 remove(element) { const {indexOf, removeAt} = this; let index = indexOf.bind(this)(element); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : index; } //获取指定链表元素的位置 indexOf(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(element === current.node) { return index - 1; } current = current.next; } return false; } //删除链表中指定位置的链表元素 removeAt(position) { let headElement = head.get(this), lengths = length.get(this), index = 0, previous, current = headElement; if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!head) { return false; } else { if(lengths === 1) { headElement = null; } else { if(position === 0) { headElement = current.next; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; } } } lengths--; head.set(this, headElement); length.set(this, lengths); return position; } return false; } //获取链表中所有的链表结构 toString() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result = ``; while(index++ &lt; lengths) { result = `${result}${current.node}|~`; current = current.next; } return result; } //获取链表的头部链表元素 headElement() { return head.get(this).node; } //获取链表的长度 size() { return length.get(this); } //判断链表是否为空 isEmpty() { return length.get(this) === 0; } //获取链表的真实结构 valueOf() { return head.get(this); } //将链表清空 clear() { head.set(this, null); length.set(this, 0); } } //返回链表LinkList类函数 return LinkList; })(); //声明链表类函数的实例 let link_list = new LinkList(); //这里判断链表是否是空链表 //在这里打印: //true console.log(link_list.isEmpty()); //这里获取链表的长度 //在这里打印: //0 console.log(link_list.size()); //这里打印链表元素的数量: //在这里打印: //1 console.log(link_list.insert(104)); link_list.insert(99); link_list.insert(155); link_list.insert(34); link_list.insert(16); //这里判断链表是否是空链表 //在这里打印: //false console.log(link_list.isEmpty()); //这里获取链表的长度 //在这里打印: //5 console.log(link_list.size()); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //155 //34 //16 console.log(link_list.toString()); //这里获取链表的头部链表元素 //在这里打印: //104 console.log(link_list.headElement()); //这里在链表下标为2处插入链表元素 //在这里打印: //2 console.log(link_list.insertAt(88, 2)); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //88 //155 //34 //16 console.log(link_list.toString()); //这里打印链表中所有的链表结构 //在这里打印: //{element: 104, next: {element: 99, next: {element: 88, next: {element: 155, next: {element: 34, next: {element: 16, next: null}}}}}} console.log(link_list.valueOf()); //这里删除链表下标为3处的链表元素 //在这里打印: //3 console.log(link_list.removeAt(3)); link_list.removeAt(4); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //88 //34 console.log(link_list.toString()); //这里删除链表中链表元素为88的链表元素 //在这里打印: //2 console.log(link_list.remove(88)); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //34 link_list.toString(); //这里打印链表中的头部链表元素 //在这里打印: //104 console.log(link_list.headElement()); link_list.clear(); //这里判断链表是否是空链表 //在这里打印: //true console.log(link_list.isEmpty()); //这里获取链表的长度 //在这里打印: //0 console.log(link_list.size()); 双向链表 DoublyLinkList 双向链表和单向链表的模式,唯一的区别: 双向链表多出了一个尾部链表元素,且链表元素类实例不仅仅有next属性,还有prev属性,next指向下一个链表元素,prev指向上一个链表元素 let DoublyLinkList = (function() { //定义链表头部的链表元素,并在初始化时设置为null //定义链表尾部的链表元素,并在初始化时设置为null //定义链表的长度,并在初始化时设置为0 let head = new WeakMap(), tail = new WeakMap(), length = new WeakMap(); //声明链表元素Node对象的类函数 //初始化有三个参数 //@param node 现链表元素的值 //@param next 用来链接下一个链表元素 //@param prev 用来链接上一个链表元素 class Node { constructor(node) { this.node = node; this.next = null; this.prev = null; } } //声明双向链表DoublyLinkList对象的类函数 class DoublyLinkList { constructor() { head.set(this, null); tail.set(this, null); length.set(this, 0); } //向链表中添加链表元素 insert(element) { let headElement = head.get(this), tailElement = tail.get(this), lengths = length.get(this), current = headElement, node = new Node(element); if(!headElement) { headElement = node; tailElement = node; } else { while(current.next) { current = current.next; } current.next = node; node.prev = current; tailElement = node; } lengths++; head.set(this, headElement); tail.set(this, tailElement); length.set(this, lengths); return lengths; } //向链表的指定位置添加链表元素 insertAt(element, position) { let headElement = head.get(this), tailElement = tail.get(this), current = headElement, lengths = length.get(this), node = new Node(element), previous, index = 0; if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!headElement) { headElement = node; tailElement = node; } else { if(position === 0) { node.next = current; current.prev = node; headElement = node; } else if(position === lengths - 1) { node.prev = tailElement; tailElement.next = node; tailElement = node; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.prev = previous; node.next = current; current.prev = node; } } lengths++; head.set(this, headElement); tail.set(this, tailElement); length.set(this, lengths); return position; } return false; } //删除链表中指定位置的链表元素 removeAt(position) { let headElement = head.get(this), tailElement = tail.get(this), lengths = length.get(this), current = headElement, index = 0, previous; if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!headElement) { return false; } else { if(lengths === 1) { headElement = null; tailElement = null; } else { if(position === 0) { headElement = current.next; headElement.prev = null; } else if (position === lengths - 1) { tailElement = tailElement.prev; tailElement.next = null; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; current.next.prev = previous; } } lengths--; head.set(this, headElement); tail.set(this, tailElement); length.set(this, lengths); return position; } } return false; } //获取链表指定的元素位置 indexOf(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(current.node === element) { return index - 1; } current = current.next; } return false; } //删除链表中的指定链表元素 remove(element) { const {indexOf, removeAt} = this; let index = indexOf.bind(this)(element); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : false; } //获取链表的长度 size() { return length.get(this); } //判断链表是否为空数组 isEmpty() { return length.get(this) === 0; } //打印链表中所有的链表元素 toString() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result = ``; while(index++ &lt; lengths) { result = `${result}${current.node}~|~`; current = current.next; } return result; } //获取链表中所有的链表结构 valueOf() { return head.get(this); } //将链表清空 clear() { head.set(this, null); tail.set(this, null); length.set(this, 0); } //获取链表的头部链表元素 headElement() { return head.get(this).node; } //获取链表的尾部链表元素 tailElement() { return tail.get(this).node; } } //返回双向链表DoublyLinkList类函数 return DoublyLinkList; })(); let doubly_link = new DoublyLinkList(); //这里打印链表是否为空链表 //在这里打印: //true console.log(doubly_link.isEmpty()); //这里打印链表的长度 //在这里打印: //0 console.log(doubly_link.size()); //这里打印插入新的链表元素后链表的长度 //在这里打印: //1 console.log(doubly_link.insert(111)); doubly_link.insert(88); doubly_link.insert(99); doubly_link.insert(77); doubly_link.insert(222); //这里打印链表是否为空链表 //在这里打印: //false console.log(doubly_link.isEmpty()); //这里打印链表的长度 //在这里打印: //5 console.log(doubly_link.size()); //这里打印链表的头部链表元素 //在这里打印: //111 console.log(doubly_link.headElement()); //这里打印链表的尾部链表元素 //在这里打印: //222 console.log(doubly_link.tailElement()); //这里打印链表的所有链表元素 //在这里打印: //111~|88~|99~|77~|222~| console.log(doubly_link.toString()); //这里打印链表的所有链表结构 //在这里打印: //{prev: null, element: 111, next: {prev: {//上一个链表元素 ...}, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 77, next: {//上一个链表元素 ...}, element: 222, next: null}}}}} console.log(doubly_link.valueOf()); //这里打印插入到3号位置的新的链表元素的下标位置 //在这里打印: //3 console.log(doubly_link.insertAt(66, 3)); //这里打印链表的所有链表元素 //在这里打印: //111~|88~|99~|66~|77~|222~| console.log(doubly_link.toString()); //这里打印链表的所有链表结构 //在这里打印: //{prev: null, element: 111, next: {prev: {//上一个链表元素 ...}, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 66, next: {prev: {//上一个链表元素 ...}, element: 77, next: {//上一个链表元素 ...}, element: 222, next: null}}}}}} console.log(doubly_link.valueOf()); //这里打印删除4号位置的链表元素的下标位置 //在这里打印: //4 console.log(doubly_link.removeAt(4)); doubly_link.removeAt(0); //这里打印删除指定的链表元素的下标位置 //在这里打印: //2 doubly_link.remove(66); //这里打印链表的所有链表元素 //在这里打印: //88~|99~|222~| console.log(doubly_link.toString()); //这里打印链表的所有链表结构 //在这里打印: //{prev: null, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 222, next: null}}} console.log(doubly_link.valueOf()); //这里打印链表的头部链表元素 //在这里打印: //88 console.log(doubly_link.headElement()); //这里打印链表的尾部链表元素 //在这里打印: //222 console.log(doubly_link.tailElement()); doubly_link.clear(); //这里打印链表是否为空链表 //在这里打印: //true console.log(doubly_link.isEmpty()); //这里打印链表的长度 //在这里打印: //0 console.log(doubly_link.size()); 集合自己封装Set集合 接下来学习下一种非顺序线性数据结构,那就是集合。在实义上指的是具有某种特定性质的事物的总体,俗话讲的好,”物以类聚,人以群分”,这是对集合相当恰当的写照,在ES6中,新语法对象Set也是用来实现集合的,下面我们也来封装一下Set集合,并封装一些ES6 Set语法中不存在的方法,比如:交集、并集、差集和子集 let Set = (function () { //设置集合的容器,并在初始化时设置为空对象{} let set = new WeakMap(); //设置集合类 class Set { constructor() { set.set(this, {}); } //在集合中添加集合项 add(value) { let set_add = set.get(this); set_add[value] = value; set.set(this, set_add); return true; } //判断集合中是否存在此集合项 has(value) { let set_has = set.get(this); return set_has.hasOwnProperty(value); } //删除集合中的指定集合项 delete(value) { let set_delete = set.get(this); if(set_delete.hasOwnProperty(value)) { delete set_delete[value]; set.set(this, set_delete); return true; } return false; } //获取集合的长度 size() { let set_size = set.get(this), index = 0; for(let [key, value] of Object.entries(set_size)) { index++; } return index; } //判断集合是否为空 isEmpty() { let set_isEmpty = set.get(this); for(let [key, value] of Object.entries(set_isEmpty)) { if(set_isEmpty.hasOwnProperty(key)) { return false; } } return true; } //获取集合的属性值数组 values() { let set_values = set.get(this); return Object.values(set_values); } //清空集合 clear() { set.set(this, {}); return true; } //并集 union(union_ano) { let union_this = this, union_new = new Set(); for(let [key_this, value_this] of union_this.values().entries()) { union_new.add(value_this); } for(let [key_ano, value_ano] of union_ano.values().entries()) { union_new.add(value_ano); } return union_new.values(); } //交集 intersection(intersection_ano) { let intersection_this = this, intersection_new = new Set(); for(let [key_this, value_this] of intersection_this.values().entries()) { if(intersection_ano.has(value_this)) { intersection_new.add(value_this); } } return intersection_new.values(); } //差集 differenceSet(differenceSet_ano) { let differenceSet_this = this, differenceSet_new = new Set(); for(let [key, value] of differenceSet_this.values().entries()) { if(!differenceSet_ano.has(value)) { differenceSet_new.add(value); } } return differenceSet_new.values(); } //子集 subset(subset_ano) { let subset_this = this; for(let [key, value] of subset_this.values().entries()) { if(!subset_ano.has(value)) { return false; } } return true; } } //返回集合类 return Set; })(); let set = new Set(); //这里判断集合是否为空 //在这里打印: //true console.log(set.isEmpty()); //这里查看集合的长度 //在这里打印: //0 console.log(set.size()); //这里在集合中添加集合项,并返回true //在这里打印: //true console.log(set.add(&quot;Gary&quot;)); set.add(&quot;Simon&quot;); set.add(&quot;Frank&quot;); set.add(&quot;Lily&quot;); set.add(&quot;Alice&quot;); set.add(&quot;Tom&quot;); set.add(&quot;Tommy&quot;); //这里判断集合是否为空 //在这里打印: //false console.log(set.isEmpty()); //这里查看集合的长度 //在这里打印: //7 console.log(set.size()); //这里判断集合中是否存在此集合项&quot;Gary&quot; //在这里打印: //true console.log(set.has(&quot;Gary&quot;)); //这里判断集合中是否存在此集合项&quot;Alice&quot; //在这里打印: //true console.log(set.has(&quot;Alice&quot;)); //这里判断集合中是否存在此集合项&quot;Clay&quot; //在这里打印: //false console.log(set.has(&quot;Clay&quot;)); //这里获取集合的属性值数组 //在这里打印: //[&quot;Gary&quot;, &quot;Simon&quot;, &quot;Frank&quot;, &quot;Lily&quot;, &quot;Alice&quot;, &quot;Tom&quot;, &quot;Tommy&quot;] console.log(set.values()); //这里删除集合中的指定集合项 //在这里打印: //true console.log(set.delete(&quot;Simon&quot;)); set.delete(&quot;Alice&quot;); //这里查看集合的长度 //在这里打印: //5 console.log(set.size()); //这里获取集合的属性值数组 //在这里打印: //[&quot;Gary&quot;, &quot;Frank&quot;, &quot;Lily&quot;, &quot;Tom&quot;, &quot;Tommy&quot;] console.log(set.values()); set.clear(); //这里判断集合是否为空 //在这里打印: //true console.log(set.isEmpty()); //这里打印集合的长度 //在这里打印: //0 console.log(set.size()); let _set = new Set(); let _set_ano = new Set(); _set.add(45); _set.add(66); _set.add(100); _set.add(52); _set.add(28); _set.add(89); _set_ano.add(28); _set_ano.add(52); _set_ano.add(111); _set_ano.add(120); _set_ano.add(18); //这里查询两个集合属于_set集合或者属于_set_ano集合的并集 //在这里打印: //[45, 66, 100, 52, 28, 89, 111, 120, 18] console.log(_set.union(_set_ano)); //这里查询两个集合既属于_set集合又属于_set_ano集合的交集 //在这里打印: //[28, 52] console.log(_set.intersection(_set_ano)); //这里查询两个集合属于_set集合但不属于_set_ano集合的差集 //在这里打印: //[45, 66, 100, 89] console.log(_set.differenceSet(_set_ano)); //这里查询_set集合是否是_set_ano的子集 //在这里打印: //false console.log(_set.subset(_set_ano)); ES6 Set集合 之前说过ES6中使用Set来表现集合,ES6的Set也有add、has、delete和clear等方法,当然size是以属性来存储集合的长度,而也拥有keys、values和entries等遍历的方式来返回属性数组、属性值数组以及[属性, 属性值]数组,但是Set并没有封装union(并集)、intersection(交集)、differenceSet(差集)和subset(子集)等方法,我们可以利用它现有的属性和方法来封装一下 //封装ES6 Set集合union并集方法 Set.prototype.union = function(set_ano) { let set_this = this, set_new = new Set(), set_union = []; for(let [key, value] of set_this.entries()) { set_new.add(key); } for(let [key, value] of set_ano.entries()) { set_new.add(key); } for(let [key, value] of set_new.entries()) { set_union = [...set_union, key]; } return set_union; }; //封装ES6 Set集合intersection交集方法 Set.prototype.intersection = function(set_ano) { let set_this = this, set_new = new Set(), set_intersection = []; for(let [key, value] of set_this.entries()) { if(set_ano.has(key)) { set_new.add(key); } } for(let [key, value] of set_new.entries()) { set_intersection = [...set_intersection, key]; } return set_intersection; }; //封装ES6 Set集合differenceSet差集方法 Set.prototype.differenceSet = function(set_ano) { let set_this = this, set_new = new Set(), set_differenceSet = []; for(let [key, value] of set_this.entries()) { if(!set_ano.has(key)) { set_new.add(key); } } for(let [key, value] of set_new.entries()) { set_differenceSet = [...set_differenceSet, key]; } return set_differenceSet; }; //封装ES6 Set集合subset子集方法 Set.prototype.subset = function(set_ano) { let set_this = this; for(let [key, value] of set_this.entries()) { if(!set_ano.has(key)) { return false; } } return true; }; let set = new Set(), set_ano = new Set(); set.add(45); set.add(66); set.add(100); set.add(52); set.add(28); set.add(89); set_ano.add(28); set_ano.add(52); set_ano.add(111); set_ano.add(120); set_ano.add(18); //这里查询属于set集合或者属于set_ano集合的并集 //在这里打印: //[45, 66, 100, 52, 28, 89, 111, 120, 18] console.log(set.union(set_ano)); //这里查询既属于set集合又属于set_ano集合的交集 //在这里打印: //[52, 28] console.log(set.intersection(set_ano)); //这里查询属于set集合但不属于set_ano集合的差集 //在这里打印: //[45, 66, 100, 89] console.log(set.differenceSet(set_ano)); //这里查询set集合是否是set_ano集合的子集 //在这里打印: //false console.log(set.subset(set_ano)); 字典 除了集合这种线性的非顺序结构以外,还有两种线性的非顺序结构: 字典和散列表,如果说集合是具有某种特征性质事物的总量的话,那字典就是具有某种特征性质事物的分集(分类集合),ES6中用Map来表现字典,下面我们就来介绍一下字典 let Map = (function () { //设置字典的容器,并在初始化时设置为空对象{} let map = new WeakMap(); //定义Map字典类 class Map { constructor() { map.set(this, {}); } //在字典中添加字典项 set(key, value) { let map_set = map.get(this); map_set[key] = value; map.set(this, map_set); return true; } //获取字典指定的字典项 get(key) { let map_get = map.get(this); if(map_get.hasOwnProperty(key)) { return map_get[key]; } return false; } //判断字典是否存在指定的字典项 has(key) { let map_has = map.get(this); return map_has.hasOwnProperty(key); } //删除字典指定的字典项 delete(key) { let map_delete = map.get(this); if(map_delete.hasOwnProperty(key)){ delete map_delete[key]; map.set(this, map_delete); return true; } return false; } //清空字典 clear() { map.set(this, {}); return true; } //获取字典的属性数组 keys() { let map_keys = map.get(this); return Object.keys(map_keys); } //获取字典的属性值数组 values() { let map_values = map.get(this); return Object.values(map_values); } //获取字典的长度 size() { let map_size = map.get(this); return Object.keys(map_size).length; } //判断字典是否为空 isEmpty() { let map_isEmpty = map.get(this); return Object.keys(map_isEmpty).length === 0; } } //返回Map字典类 return Map; })(); let map = new Map(); //这里判断字典是否为空 //在这里打印: //true console.log(map.isEmpty()); //这里获取字典的长度 //在这里打印: //0 console.log(map.size()); //这里在字典中添加制定的字典项 //在这里打印: //true console.log(map.set(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); map.set(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); map.set(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); map.set(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); map.set(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); //这里判断字典是否为空 //在这里打印: //false console.log(map.isEmpty()); //这里获取字典的长度 //在这里打印: //5 console.log(map.size()); //这里获取字典指定的字典项 //在这里打印: //gary@gmail.com console.log(map.get(&quot;Gary&quot;)); //这里获取字典指定的字典项 //在这里打印: //lily@gmail.com console.log(map.get(&quot;Alice&quot;)); //这里判断是否存在指定的字典项 //在这里打印: //true console.log(map.has(&quot;Lily&quot;)); //这里获取字典的属性数组 //在这里打印: //[&quot;Gary&quot;, &quot;Simon&quot;, &quot;Lily&quot;, &quot;Alice&quot;, &quot;Aaron&quot;] console.log(map.keys()); //这里获取字典的属性值数组 //在这里打印: //[&quot;gary@gmail.com&quot;, &quot;simon@gmail.com&quot;, &quot;lily@gmail.com&quot;, &quot;alice@gmail.com&quot;, &quot;aaron@gmail.com&quot;] console.log(map.values()); //这里删除字典的执行字典项 //在这里打印: //true console.log(map.delete(&quot;Alice&quot;)); //这里判断是否存在指定的字典项 //在这里打印: //false console.log(map.has(&quot;Alice&quot;)); //这里清空字典 //在这里打印: //true console.log(map.clear()); //这里获取字典指定的字典项 //在这里打印: //false console.log(map.get(&quot;Gary&quot;)); //这里判断字典是否为空 //在这里打印: //true console.log(map.isEmpty()); //这里获取字典的长度 //在这里打印: //0 console.log(map.size()); 散列表 另外一种线性非顺序数据结构就是散列表了,也就是我们在Java中常用的HashTable,当然单纯的用HashTable会出现很多问题,最显著的一点就是容易一个值被另外一个值所覆盖,下面我们来介绍一下HashTable散列表 let HashTable = (function () { //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //定义散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为loseLose算法 //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数 //然后对任何一个质数取余 //最后进行返回 loseLoseHashTable(key) { let hash_key = 13, result_index = 0; for(let i = 0; i &lt; key.length; i++) { result_index += i * hash_key + key.charCodeAt(i); } return result_index % 37; } //在散列表中添加散列表项 put(key, value) { let hashTable = hash_table.get(this); const {loseLoseHashTable} = this; let index = loseLoseHashTable.bind(this)(key); hashTable[index] = value; hash_table.set(this, hashTable); return true; } //获取散列表指定的散列表项 get(key) { let hashTable = hash_table.get(this); const {loseLoseHashTable} = this; let index = loseLoseHashTable.bind(this)(key); if(hashTable[index] !== undefined) { return hashTable[index]; } return false; } //删除散列表中指定的散列表项 remove(key) { let hashTable = hash_table.get(this); const {loseLoseHashTable} = this; let index = loseLoseHashTable.bind(this)(key); if(hashTable[index] !== undefined) { hashTable[index] = undefined; hash_table.set(this, hashTable); return true; } return false; } //获取散列表拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}${value} -&gt; `; } } return result_str; } //获取散列表的具体结构 valueOf() { let hashTable = hash_table.get(this); return hashTable; } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里获取散列表指定的散列表项 //在这里打印: //tommy@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里获取散列表指定的散列表项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //martin@gmail.com -&gt; lily@gmail.com -&gt; tom@gmail.com -&gt; alice@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; helen@gmail.com -&gt; tommy@gmail.com -&gt; frank@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[&quot;martin@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 2, &quot;tom@gmail.com&quot;, empty × 5, &quot;alice@gmail.com&quot;, empty × 2, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 8, &quot;helen@gmail.com&quot;, empty × 4, &quot;tommy@gmail.com&quot;, &quot;frank@gmail.com&quot;] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); //这里获取散列表中指定的散列表项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //martin@gmail.com -&gt; lily@gmail.com -&gt; alice@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; helen@gmail.com -&gt; frank@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[&quot;martin@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 2, undefined, empty × 5, &quot;alice@gmail.com&quot;, empty × 2, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 8, &quot;helen@gmail.com&quot;, empty × 4, undefined, &quot;frank@gmail.com&quot;] console.log(hash_table.valueOf()); 不知道你们注意到了没,有一些散列表项被覆盖了,比如说key属性为Aaron的散列表项的value属性值竟然是tommy@gmail.com,再比如说我将key属性为Aaron的散列表项删除掉,key属性为Tommy的散列表项也消失了,变为了undefined,说明key属性为Tommy和key属性为Aaron的散列表项经过loseLose算法解析散列表项后是同一个散列表项,所以散列表项被覆盖了,所以用单纯的用HashTable是不适当的,要解决这个比较显著的问题,有两种解决方式:链表查询以及散列表巡航迭代 链表查询 链表查询就是用链表来作为散列表项,假如已经存在loseLose算法解析散列表项后的散列表项,就添加到此位置链表的最后,这样的话就不会发生覆盖的事情了,下面我们就用链表查询来解决散列表项覆盖的问题吧 let LinkList = (function () { //定义链表头部的链表元素,并在初始化时设置为null //定义链表的长度,并在初始化时设置为0 let head = new WeakMap(), length = new WeakMap(); //声明链表元素Node对象的类函数 //初始化有两个参数 //@param node 现链表元素的值 //@param next 用来链接下一个链表元素 class Node { constructor(node) { this.node = node; this.next = null; } } //定义链表类 class LinkList { constructor() { head.set(this, null); length.set(this, 0); } //向链表中添加链表元素 insert(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, node = new Node(element); if(!headElement) { headElement = node; } else { while(current.next) { current = current.next; } current.next = node; } lengths++; head.set(this, headElement); length.set(this, lengths); return lengths; } //向链表的指定位置添加链表元素 insertAt(element, position) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, previous, node = new Node(element); if(position &gt;= 0 &amp;&amp; position &lt; lengths) { if(!headElement) { headElement = node; } else { if(position === 0) { node.next = current; headElement = node; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.next = current; } } lengths++; head.set(this, headElement); length.set(this, lengths); return position; } return false; } //删除链表中指定位置的链表元素 removeAt(position) { let headElement = head.get(this), lengths = length.get(this), index = 0, current = headElement, previous; if(position &gt;= 0 &amp;&amp; position &lt; lengths) { if(!headElement) { return false; } else { if(lengths === 1) { headElement = null; } else { if(position === 0) { headElement = current.next; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; } } lengths--; head.set(this, headElement); length.set(this, lengths); return position; } } return false; } //删除链表中的指定链表元素 remove(element) { const {indexOf, removeAt} = this; let index = indexOf.bind(this)(element); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : false; } //删除链表中散列表链表查询中的链表项 removeKey(key) { const {indexOfKeyPosition, removeAt} = this; let index = indexOfKeyPosition.bind(this)(key); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : index; } //获取链表指定的元素位置 indexOf(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(current.node === element) { return index - 1; } current = current.next; } return false; } //判断链表中是否存在散列表链表查询中的key indexOfKey(key) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(key === current.node.key) { return true; } current = current.next; } return false; } //获取链表指定的散列表链表查询中的链表项位置 indexOfKeyPosition(key) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(key === current.node.key) { return index - 1; } current = current.next; } return false; } //获取链表中散列表链表查询中的链表项 indexOfNode(key) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(key === current.node.key) { return current.node; } current = current.next; } return false; } //获取链表的长度 size() { return length.get(this); } //判断链表是否为空 isEmpty() { return length.get(this) === 0; } //获取链表的头部链表元素 headElement() { return head.get(this).node; } //获取链表中所有的链表结构 toString() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result_str = ``; while(index++ &lt; lengths) { result_str = `${result_str}${current.node} =&gt; `; current = current.next; } return result_str; } //获取链表中所有散列表查询的链表结构 toStringKey() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result_str = ``; while(index++ &lt; lengths) { result_str = `${result_str}{key: ${current.node.key}, value: ${current.node.value}} =&gt; `; current = current.next; } return result_str; } //获取链表的真实结构 valueOf() { return head.get(this); } //将链表清空 clear() { head.set(this, null); length.set(this, 0); } } //返回链表类 return LinkList; })(); let HashTable = (function (){ //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //设置散列表中的链表类 //@params key //@params value class Node { constructor(key, value) { this.key = key; this.value = value; } } //设置散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为loseLose算法 //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数 //然后对任何一个质数取余 //最后进行返回 loseLoseHashTable(key) { let hash_key = 13, index = 0; for(let i = 0; i &lt; key.length; i++) { index += i * hash_key + key.charCodeAt(i); } return index % 37; } //在散列表中添加散列表链表查询项 put(key, value) { const {loseLoseHashTable} = this; let hashTable = hash_table.get(this), index = loseLoseHashTable.bind(this)(key), node = new Node(key, value), linkList; if(hashTable[index] === undefined) { linkList = new LinkList(); linkList.insert(node); hashTable[index] = linkList; } else { linkList = hashTable[index]; if(linkList.indexOfKey(key)) { return false; } else { linkList = hashTable[index]; linkList.insert(node); hashTable[index] = linkList; } } hash_table.set(this, hashTable); return true; } //获取散列表指定的散列表链表查询项 get(key) { const {loseLoseHashTable} = this; let hashTable = hash_table.get(this), index = loseLoseHashTable.bind(this)(key), linkList, node; if(hashTable[index] !== undefined) { linkList = hashTable[index]; if(linkList.indexOfKey(key)) { node = linkList.indexOfNode(key); return node.value; } else { return false; } } return false; } //删除散列表中指定的散列表链表查询项 remove(key) { const {loseLoseHashTable} = this; let hashTable = hash_table.get(this), index = loseLoseHashTable.bind(this)(key), linkList; if(hashTable[index] !== undefined) { linkList = hashTable[index]; if(linkList.indexOfKey(key)) { linkList.removeKey(key); if(linkList.isEmpty()){ hashTable[index] = undefined; } else { hashTable[index] = linkList; } return true; } else { return false; } } return false; } //获取散列表链表查询拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}${value.toStringKey()} -&gt; `; } } return result_str; } //获取散列表链表查询的具体结构 valueOf() { return hash_table.get(this); } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表链表查询项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里在散列表中获取散列表链表查询项 //在这里打印: //aaron@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里在散列表中获取散列表链表查询项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表链表查询拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} =&gt; {key: Martin, value: martin@gmail.com} =&gt; -&gt; {key: Lily, value: lily@gmail.com} =&gt; -&gt; {key: Tom, value: tom@gmail.com} =&gt; -&gt; {key: Alice, value: alice@gmail.com} =&gt; -&gt; {key: Simon, value: simon@gmail.com} =&gt; -&gt; {key: Betty, value: betty@gmail.com} =&gt; -&gt; {key: Helen, value: helen@gmail.com} =&gt; -&gt; {key: Aaron, value: aaron@gmail.com} =&gt; {key: Tommy, value: tommy@gmail.com} =&gt; -&gt; {key: Frank, value: frank@gmail.com} =&gt; -&gt; console.log(hash_table.toString()); //这里获取散列表链表查询的具体结构 //在这里打印: //[LinkList, empty × 6, LinkList, empty × 2, LinkList, empty × 5, LinkList, empty × 2, LinkList, empty, LinkList, empty × 8, LinkList, empty × 4, LinkList, LinkList] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表链表查询项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); hash_table.remove(&quot;Tommy&quot;); //这里在散列表中获取散列表链表查询项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表链表查询拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} =&gt; {key: Martin, value: martin@gmail.com} =&gt; -&gt; {key: Lily, value: lily@gmail.com} =&gt; -&gt; {key: Alice, value: alice@gmail.com} =&gt; -&gt; {key: Simon, value: simon@gmail.com} =&gt; -&gt; {key: Betty, value: betty@gmail.com} =&gt; -&gt; {key: Helen, value: helen@gmail.com} =&gt; -&gt; {key: Frank, value: frank@gmail.com} =&gt; -&gt; console.log(hash_table.toString()); //这里获取散列表链表查询的具体结构 //在这里打印: //[LinkList, empty × 6, LinkList, empty × 2, undefined, empty × 5, LinkList, empty × 2, LinkList, empty, LinkList, empty × 8, LinkList, empty × 4, undefined, LinkList] console.log(hash_table.valueOf()); 散列表巡航迭代 散列表巡航迭代其实就是利用位置迭代解决问题,假如根据loseLose算法解析散列表项后的散列表项,所在位置已经存在散列表项,就去查询所在位置的下一个位置,依次迭代下去,直到查询到位置的散列表项为没有定义的值为止,下面我们就用散列表巡航迭代来解决散列表项覆盖的问题吧 let HashTable = (function () { //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //设置散列表中的对象类 //@params key //@params value class Node { constructor(key, value) { this.key = key; this.value = value; } } //设置散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为loseLose算法 //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数 //然后对任何一个质数取余 //最后进行返回 loseLoseHashTable(key) { let hash_key = 13, index = 0; for(let i = 0; i &lt; key.length; i++) { index += i * hash_key + key.charCodeAt(i); } return index % 37; } //在散列表中添加散列表巡航迭代项 put(key, value) { const {loseLoseHashTable} = this; let hash_key = loseLoseHashTable.bind(this)(key), hashTable = hash_table.get(this), node = new Node(key, value); if(hashTable[hash_key] === undefined) { hashTable[hash_key] = node; } else { while(hashTable[hash_key] !== undefined) { if(hashTable[hash_key].key === key) { return false; } hash_key++; } if(hashTable[hash_key] === undefined) { hashTable[hash_key] = node; } } hash_table.set(this, hashTable); return true; } //获取散列表指定的散列表巡航迭代项 get(key) { const {loseLoseHashTable} = this; let hash_key = loseLoseHashTable.bind(this)(key), hashTable = hash_table.get(this); if(hashTable[hash_key] === undefined) { return false; } else { while(hashTable[hash_key] !== undefined) { if(hashTable[hash_key].key === key) { return hashTable[hash_key].value; } hash_key++; } } return false; } //删除散列表中指定的散列表巡航迭代项 remove(key) { const {loseLoseHashTable} = this; let hash_key = loseLoseHashTable.bind(this)(key), hashTable = hash_table.get(this); if(hashTable[hash_key] === undefined) { return false; } else { while(hashTable[hash_key] !== undefined) { if(hashTable[hash_key].key === key) { hashTable[hash_key] = undefined; hash_table.set(this, hashTable); return true; } hash_key++; } } return false; } //获取散列表巡航迭代拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}{key: ${value[&quot;key&quot;]}, value: ${value[&quot;value&quot;]}} -&gt; `; } } return result_str; } //获取散列表巡航迭代的具体结构 valueOf() { return hash_table.get(this); } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表巡航迭代项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里在散列表中获取散列表巡航迭代项 //在这里打印: //aaron@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里在散列表中获取散列表巡航迭代项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表巡航迭代拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} -&gt; {key: Martin, value: martin@gmail.com} -&gt; {key: Lily, value: lily@gmail.com} -&gt; {key: Tom, value: tom@gmail.com} -&gt; {key: Alice, value: alice@gmail.com} -&gt; {key: Simon, value: simon@gmail.com} -&gt; {key: Betty, value: betty@gmail.com} -&gt; {key: Helen, value: helen@gmail.com} -&gt; {key: Aaron, value: aaron@gmail.com} -&gt; {key: Tommy, value: tommy@gmail.com} -&gt; {key: Frank, value: frank@gmail.com} -&gt; console.log(hash_table.toString()); //这里获取散列表巡航迭代的具体结构 //在这里打印: //[Node, Node, empty × 5, Node, empty × 2, Node, empty × 5, Node, empty × 2, Node, empty, Node, empty × 8, Node, empty × 4, Node, Node, Node] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表巡航迭代项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); //这里在散列表中获取散列表巡航迭代项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表巡航迭代拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} -&gt; {key: Martin, value: martin@gmail.com} -&gt; {key: Lily, value: lily@gmail.com} -&gt; {key: Alice, value: alice@gmail.com} -&gt; {key: Simon, value: simon@gmail.com} -&gt; {key: Betty, value: betty@gmail.com} -&gt; {key: Helen, value: helen@gmail.com} -&gt; {key: Tommy, value: tommy@gmail.com} -&gt; {key: Frank, value: frank@gmail.com} -&gt; console.log(hash_table.toString()); //这里获取散列表巡航迭代的具体结构 //在这里打印: //[Node, Node, empty × 5, Node, empty × 2, undefined, empty × 5, Node, empty × 2, Node, empty, Node, empty × 8, Node, empty × 4, undefined, Node, Node] console.log(hash_table.valueOf()); djb2算法解决一切问题 还有一种既不使用链表查询,也不使用巡航迭代的方法,那就是展示散列表更广的djb2算法,使用djb2算法就可以直接解决loseLose算法解析后散列表项覆盖的问题,下面我们就用djb2算法来解决散列表项覆盖的问题吧 let HashTable = (function() { //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //设置散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为djb2算法 //djb2算法和loseLose算法相近,都是定义一个质数(数值比较大的质数)乘以属性的每一个字符所在的位置,再加上属性每一个字符所对应的ASCII码值 //然后对任何一个质数(数值比较大的质数)取余 //最后再返回 djb2HashTable(key) { let hash_key = 5381, index = 0; for(let i = 0; i &lt; key.length; i++) { index += i * hash_key + key.charCodeAt(i); } return index % 1013; } //在散列表中添加散列表项 put(key, value) { const {djb2HashTable} = this; let hashTable = hash_table.get(this), hash_key = djb2HashTable.bind(this)(key); if(hashTable[hash_key] !== undefined) { return false; } hashTable[hash_key] = value; return true; } //获取散列表指定的散列表项 get(key) { const {djb2HashTable} = this; let hashTable = hash_table.get(this), hash_key = djb2HashTable.bind(this)(key); if(hashTable[hash_key] === undefined) { return false; } return hashTable[hash_key]; } //删除散列表中指定的散列表项 remove(key) { const {djb2HashTable} = this; let hashTable = hash_table.get(this), hash_key = djb2HashTable.bind(this)(key); if(hashTable[hash_key] === undefined) { return false; } hashTable[hash_key] = undefined; return true; } //获取散列表拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}${value} -&gt; `; } } return result_str; } //获取散列表的具体结构 valueOf() { return hash_table.get(this); } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里获取散列表中指定的散列表项 //在这里打印: //aaron@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里获取散列表中指定的散列表项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //tom@gmail.com -&gt; gary@gmail.com -&gt; lily@gmail.com -&gt; martin@gmail.com -&gt; alice@gmail.com -&gt; helen@gmail.com -&gt; aaron@gmail.com -&gt; frank@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; tommy@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[empty × 239, &quot;tom@gmail.com&quot;, empty × 33, &quot;gary@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 13, &quot;martin@gmail.com&quot;, empty × 304, &quot;alice@gmail.com&quot;, empty × 13, &quot;helen@gmail.com&quot;, empty × 4, &quot;aaron@gmail.com&quot;, &quot;frank@gmail.com&quot;, empty × 19, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 13, &quot;tommy@gmail.com&quot;] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); //这里获取散列表中指定的散列表项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //gary@gmail.com -&gt; lily@gmail.com -&gt; martin@gmail.com -&gt; alice@gmail.com -&gt; helen@gmail.com -&gt; frank@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; tommy@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[empty × 239, undefined, empty × 33, &quot;gary@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 13, &quot;martin@gmail.com&quot;, empty × 304, &quot;alice@gmail.com&quot;, empty × 13, &quot;helen@gmail.com&quot;, empty × 4, undefined, &quot;frank@gmail.com&quot;, empty × 19, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 13, &quot;tommy@gmail.com&quot;] console.log(hash_table.valueOf()); 二叉树 这是我们学习的第一种非线性非顺序的数据结构 —— 树,后面还会学到更多,比如说图。树只有一个根节点,每一个节点都可能有一个或者多个子节点 —— 子叶,今天我们实现的二叉树,每个节点最多只能有两个子叶,left的子叶比其父节点数值小,right的子叶比其父节点数值大,下面我们来介绍一下二叉树 let Tree = (function () { //设置二叉树的容器,并初始化为null let head = new WeakMap(); //定义二叉树子叶节点类 //@params node //@params left //@params right class Node { constructor(node) { this.node = node; this.left = null; this.right = null; } } //定义二叉树类 class Tree { constructor() { head.set(this, null); } //在二叉树中添加子叶节点 insert(node) { const {insertNode} = this; let head_tree = head.get(this); head_tree = insertNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //二叉树中添加子叶节点执行方法 //利用当前的子叶节点和添加的子叶节点数值进行比较 //假如小于添加的子叶节点数值,就查询当前子叶节点的右子叶节点 //假如大于添加的子叶节点数值,就查询当前子叶节点的左子叶节点 //直到查询到节点为null为止,然后添加新的子叶节点 insertNode(node, node_key) { const {insertNode} = this; if(!node) { node = new Node(node_key); } else if(node.node &gt; node_key) { node.left = insertNode.bind(this)(node.left, node_key); } else { node.right = insertNode.bind(this)(node.right, node_key); } return node; } //在二叉树中删除指定的子叶节点 remove(node) { const {removeNode} = this; let head_tree = head.get(this); if(!head_tree) { return false; } head_tree = removeNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //二叉树中删除指定的子叶节点执行方法 //利用当前的子叶节点和删除的子叶节点数值进行比较 //假如小于删除的子叶节点,就查询当前子叶节点的右子叶节点 //假如大于删除的子叶节点,就查询当前子叶节点的左子叶节点 //直到等于删除的子叶节点数值,分为三种情况 //第一种,删除的子叶节点底下没有其左右子叶节点,就直接将删除的子叶节点置为null //第二种,删除的子叶节点底下的左右子叶节点有一边为null,就直接将删除的子叶节点置为左右子叶节点不为null的一边 //第三种,删除的子叶节点底下其左右子叶节点都不为null,就直接去查询删除的子叶节点其右子叶节点底下的最小的子叶节点,并将删除的子叶节点的数值置为这个最小的子叶节点的数值,再将删除的子叶节点其右子叶节点底下的最小的子叶节点删除 removeNode(node, node_key) { const {removeNode, findTheLeftNode} = this; if(node.node &gt; node_key) { node.left = removeNode.bind(this)(node.left, node_key); } else if(node.node &lt; node_key){ node.right = removeNode.bind(this)(node.right, node_key); } else { if(!node.left &amp;&amp; !node.right) { node = null; } else if (!node.left) { node = node.right; } else if (!node.right) { node = node.left; } else { let aux = findTheLeftNode.bind(this)(node.right); node.node = aux.node; node.right = removeNode.bind(this)(node.right, aux.node); } } return node; } //查询子叶节点底下的最小的(最左边的)子叶节点 findTheLeftNode(node) { const {findTheLeftNode} = this; if(node.left) { return findTheLeftNode.bind(this)(node.left); } return node; } //在二叉树中获取最小的(最左边的)子叶节点数值 min() { const {minNode} = this; let head_tree = head.get(this); console.log(&quot;最小的子叶:&quot;); return minNode.bind(this)(head_tree).node; } //二叉树中获取最小的(最左边的)子叶节点执行方法 minNode(node) { const {minNode} = this; if(node.left) { return minNode.bind(this)(node.left); } return node; } //在二叉树中获取最大的(最右边的)子叶节点数值 max() { const {maxNode} = this; let head_tree = head.get(this); console.log(&quot;最大的子叶:&quot;); return maxNode.bind(this)(head_tree).node; } //二叉树中获取最大的(最右边的)子叶节点执行方法 maxNode(node) { const {maxNode} = this; if(node.right) { return maxNode.bind(this)(node.right); } return node; } //在二叉树获取先序遍历 preorderTraversal(method) { const {preorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;先序遍历:&quot;); preorderTraversalNode.bind(this)(head_tree, method); } //二叉树先序遍历执行方法 preorderTraversalNode(node, method) { const {preorderTraversalNode} = this; if(node) { method.bind(this)(node); preorderTraversalNode.bind(this)(node.left, method); preorderTraversalNode.bind(this)(node.right, method); } } //在二叉树中获取中序遍历 inorderTraversal(method) { const {inorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;中序遍历:&quot;); inorderTraversalNode.bind(this)(head_tree, method); } //二叉树中序遍历执行方法 inorderTraversalNode(node, method) { const {inorderTraversalNode} = this; if(node) { inorderTraversalNode.bind(this)(node.left, method); method.bind(this)(node); inorderTraversalNode.bind(this)(node.right, method); } } //在二叉树中获取后序遍历 postorderTraversal(method) { const {postorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;后序遍历:&quot;); postorderTraversalNode.bind(this)(head_tree, method); } //二叉树后序遍历执行方法 postorderTraversalNode(node, method) { const {postorderTraversalNode} = this; if(node) { postorderTraversalNode.bind(this)(node.left, method); postorderTraversalNode.bind(this)(node.right, method); method.bind(this)(node); } } //在二叉树中获取二叉树的具体结构 valueOf() { let head_tree = head.get(this); return head_tree; } } //返回二叉树类 return Tree; })(); let tree = new Tree(); //这里在二叉树中添加子节点 //在这里打印: //true console.log(tree.insert(15)); tree.insert(10); tree.insert(18); tree.insert(20); tree.insert(17); tree.insert(16); tree.insert(25); tree.insert(5); tree.insert(8); tree.insert(55); tree.insert(30); tree.insert(35); tree.insert(40); tree.insert(45); tree.insert(50); //这里在二叉树中获取最小的(最左边的)子叶节点数值 //在这里打印: //最小的子叶: //5 console.log(tree.min()); //这里在二叉树中获取最大的(最右边的)子叶节点数值 //在这里打印: //最大的子叶: //55 console.log(tree.max()); //这里在二叉树中获取中序遍历 //在这里打印: //中序遍历: //5 //8 //10 //15 //16 //17 //18 //20 //25 //30 //35 //40 //45 //50 //55 tree.inorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在二叉树中获取先序遍历 //在这里打印: //先序遍历: //15 //10 //5 //8 //18 //17 //16 //20 //25 //55 //30 //35 //40 //45 //50 tree.preorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在二叉树中获取后序遍历 //在这里打印: //后序遍历: //8 //5 //10 //16 //17 //50 //45 //40 //35 //30 //55 //25 //20 //18 //15 tree.postorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 15, left: Node, right: Node} console.log(tree.valueOf()); //这里在二叉树中删除指定的子叶节点 //在这里打印: //true console.log(tree.remove(50)); tree.remove(40); tree.remove(15); //这里在二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 16, left: Node, right: Node} console.log(tree.valueOf()); 平衡二叉树 介绍并封装完了二叉树之后,我们来介绍一下平衡二叉树,其实平衡二叉树就是每一个二叉树上面的节点的平衡因子的绝对值不可以超过1,也就是说-1 &lt;= 平衡因子 &lt;= 1,所谓的平衡因子就是二叉树节点子树节点级数,-1 &lt;= 左子树级数 - 右子树级数 &lt;= 1,下面就让我们来介绍一下平衡二叉树吧 let AVLTree = (function () { //设置平衡二叉树的容器,并初始化为null let head = new WeakMap(); //定义平衡二叉树子叶节点类 //@params node //@params left //@params right class Node { constructor(node) { this.node = node; this.left = null; this.right = null; } } //定义平衡二叉树类 class AVLTree { constructor() { head.set(this, null); } //在平衡二叉树中添加子叶节点 insert(node) { const {insertNode} = this; let head_tree = head.get(this); head_tree = insertNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //平衡二叉树中添加子叶节点执行方法 //利用当前的子叶节点和添加的子叶节点数值进行比较 //假如小于添加的子叶节点数值,就查询当前子叶节点的右子叶节点 //假如大于添加的子叶节点数值,就查询当前子叶节点的左子叶节点 //直到查询到节点为null为止,然后添加新的子叶节点 insertNode(node, node_key) { const {insertNode, findBalanceFactor, LLBalanceNode, LRBalanceNode, RRBalanceNode, RLBalanceNode} = this; if(!node) { node = new Node(node_key); } else if(node.node &gt; node_key) { node.left = insertNode.bind(this)(node.left, node_key); if(findBalanceFactor.bind(this)(node.left) - findBalanceFactor.bind(this)(node.right) &gt; 1) { if(node_key &lt; node.left.node) { node = LLBalanceNode.bind(this)(node); } else { node = LRBalanceNode.bind(this)(node); } } } else { node.right = insertNode.bind(this)(node.right, node_key); if(findBalanceFactor.bind(this)(node.right) - findBalanceFactor.bind(this)(node.left) &gt; 1) { if(node_key &gt; node.right.node) { node = RRBalanceNode.bind(this)(node); } else { node = RLBalanceNode.bind(this)(node); } } } return node; } //平衡二叉树使用LL算法来解决添加的新的子叶节点数值小于其父子叶节点(左边父子叶节点)的数值的平衡问题 LLBalanceNode(node) { let target = node.left; node.left = target.right; target.right = node; return target; } //平衡二叉树使用LL算法来解决添加的新的子叶节点数值大于其父子叶节点(左边父子叶节点)的数值的平衡问题 LRBalanceNode(node) { const {RRBalanceNode, LLBalanceNode} = this; node.left = RRBalanceNode.bind(this)(node.left); return LLBalanceNode.bind(this)(node); } //平衡二叉树使用RR算法来解决添加的新的子叶节点数值大于其父子叶节点(右边父子叶节点)的数值的平衡问题 RRBalanceNode(node) { let target = node.right; node.right = target.left; target.left = node; return target; } //平衡二叉树使用RR算法来解决添加的新的子叶节点数值小于其父子叶节点(右边父子叶节点)的数值的平衡问题 RLBalanceNode(node) { const {RRBalanceNode, LLBalanceNode} = this; node.right = LLBalanceNode.bind(this)(node.right); return RRBalanceNode.bind(this)(node); } //获取每个平衡二叉树节点的平衡因子 findBalanceFactor(node) { const {findBalanceFactor} = this; if(!node) { return -1; } else { return Math.max(findBalanceFactor.bind(this)(node.left), findBalanceFactor.bind(this)(node.right)) + 1; } } //在平衡二叉树中删除指定的子叶节点 remove(node) { const {removeNode} = this; let head_tree = head.get(this); if(!head_tree) { return false; } head_tree = removeNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //平衡二叉树中删除指定的子叶节点执行方法 //利用当前的子叶节点和删除的子叶节点数值进行比较 //假如小于删除的子叶节点,就查询当前子叶节点的右子叶节点 //假如大于删除的子叶节点,就查询当前子叶节点的左子叶节点 //直到等于删除的子叶节点数值,分为三种情况 //第一种,删除的子叶节点底下没有其左右子叶节点,就直接将删除的子叶节点置为null //第二种,删除的子叶节点底下的左右子叶节点有一边为null,就直接将删除的子叶节点置为左右子叶节点不为null的一边 //第三种,删除的子叶节点底下其左右子叶节点都不为null,就直接去查询删除的子叶节点其右子叶节点底下的最小的子叶节点,并将删除的子叶节点的数值置为这个最小的子叶节点的数值,再将删除的子叶节点其右子叶节点底下的最小的子叶节点删除 removeNode(node, node_key) { const {removeNode, findTheLeftNode} = this; if(node.node &gt; node_key) { node.left = removeNode.bind(this)(node.left, node_key); } else if(node.node &lt; node_key){ node.right = removeNode.bind(this)(node.right, node_key); } else { if(!node.left &amp;&amp; !node.right) { node = null; } else if (!node.left) { node = node.right; } else if (!node.right) { node = node.left; } else { let aux = findTheLeftNode.bind(this)(node.right); node.node = aux.node; node.right = removeNode.bind(this)(node.right, aux.node); } } return node; } //查询子叶节点底下的最小的(最左边的)子叶节点 findTheLeftNode(node) { const {findTheLeftNode} = this; if(node.left) { return findTheLeftNode.bind(this)(node.left); } return node; } //在平衡二叉树中获取最小的(最左边的)子叶节点数值 min() { const {minNode} = this; let head_tree = head.get(this); console.log(&quot;最小的子叶:&quot;); return minNode.bind(this)(head_tree).node; } //平衡二叉树中获取最小的(最左边的)子叶节点执行方法 minNode(node) { const {minNode} = this; if(node.left) { return minNode.bind(this)(node.left); } return node; } //在平衡二叉树中获取最大的(最右边的)子叶节点数值 max() { const {maxNode} = this; let head_tree = head.get(this); console.log(&quot;最大的子叶:&quot;); return maxNode.bind(this)(head_tree).node; } //平衡二叉树中获取最大的(最右边的)子叶节点执行方法 maxNode(node) { const {maxNode} = this; if(node.right) { return maxNode.bind(this)(node.right); } return node; } //在平衡二叉树获取先序遍历 preorderTraversal(method) { const {preorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;先序遍历:&quot;); preorderTraversalNode.bind(this)(head_tree, method); } //平衡二叉树先序遍历执行方法 preorderTraversalNode(node, method) { const {preorderTraversalNode} = this; if(node) { method.bind(this)(node); preorderTraversalNode.bind(this)(node.left, method); preorderTraversalNode.bind(this)(node.right, method); } } //在平衡二叉树中获取中序遍历 inorderTraversal(method) { const {inorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;中序遍历:&quot;); inorderTraversalNode.bind(this)(head_tree, method); } //平衡二叉树中序遍历执行方法 inorderTraversalNode(node, method) { const {inorderTraversalNode} = this; if(node) { inorderTraversalNode.bind(this)(node.left, method); method.bind(this)(node); inorderTraversalNode.bind(this)(node.right, method); } } //在平衡二叉树中获取后序遍历 postorderTraversal(method) { const {postorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;后序遍历:&quot;); postorderTraversalNode.bind(this)(head_tree, method); } //平衡二叉树后序遍历执行方法 postorderTraversalNode(node, method) { const {postorderTraversalNode} = this; if(node) { postorderTraversalNode.bind(this)(node.left, method); postorderTraversalNode.bind(this)(node.right, method); method.bind(this)(node); } } //在平衡二叉树中获取二叉树的具体结构 valueOf() { let head_tree = head.get(this); return head_tree; } } //返回平衡二叉树类 return AVLTree; })(); let tree = new AVLTree(); //这里在平衡二叉树中添加子节点 //在这里打印: //true console.log(tree.insert(15)); tree.insert(10); tree.insert(18); tree.insert(20); tree.insert(17); tree.insert(16); tree.insert(25); tree.insert(5); tree.insert(8); tree.insert(55); tree.insert(30); tree.insert(35); tree.insert(40); tree.insert(45); tree.insert(50); //这里在平衡二叉树中获取最小的(最左边的)子叶节点数值 //在这里打印: //最小的子叶: //5 console.log(tree.min()); //这里在平衡二叉树中获取最大的(最右边的)子叶节点数值 //在这里打印: //最大的子叶: //55 console.log(tree.max()); //这里在平衡二叉树中获取中序遍历 //在这里打印: //中序遍历: //5 //8 //10 //15 //16 //17 //18 //20 //25 //30 //35 //40 //45 //50 //55 tree.inorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在平衡二叉树中获取先序遍历 //在这里打印: //先序遍历: //17 //15 //8 //5 //10 //16 //30 //20 //18 //25 //40 //35 //50 //45 //55 tree.preorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在平衡二叉树中获取后序遍历 //在这里打印: //后序遍历: //5 //10 //8 //16 //15 //18 //25 //20 //35 //45 //55 //50 //40 //30 //17 tree.postorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在平衡二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 17, left: Node, right: Node} console.log(tree.valueOf()); //这里在平衡二叉树中删除指定的子叶节点 //在这里打印: //true console.log(tree.remove(50)); tree.remove(40); tree.remove(15); //这里在平衡二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 17, left: Node, right: Node} console.log(tree.valueOf());]]></content>
      <categories>
        <category>Javascript数据结构和算法</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-07 浅谈使用jQuery和react的区别]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%B5%85%E8%B0%88%E4%BD%BF%E7%94%A8jQuery%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-07 查漏补缺]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%2F</url>
    <content type="text"><![CDATA[赋值操作的返回 最近在读一本《JavaScript DOM 编程艺术》的书,其中有一句话引起了我的好奇,假如if判断语句中存在赋值语句,则赋值语句的返回总是true。我对此结果进行了检验 var a; //这种情况下,if判断语句中返回&quot;good&quot;,为true //打印&quot;good result&quot; if(a = &quot;good&quot;) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回false,为false //什么都不打印 if(a = false) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回undefined,为false //什么都不打印 if(a = undefined) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回0,为false //什么都不打印 if(a = 0) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回null,为false //什么都不打印 if(a = null) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回{},为true //打印&quot;good result&quot; if(a = {}) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回[],为true //打印&quot;good result&quot; if(a = []) { console.log(&quot;good result&quot;); } 实践是检验真理的唯一标准,由此检验到赋值操作的返回就是其本身,本身类型转换后为true,则为true;转换后为false,则为false,并不总是返回true,书中的那句话实践出是不妥当的。 模板字符串的换行功能 学模板字符串时,本来只是以为模板字符串所带来的只不过是一个外部变量引入的功能,这几天发现换行不直接写\n,直接换行编写,就可以实现换行功能 let name = &quot;Gary&quot;, sentence = `Hi, ${name} is my name, I&apos;m 25 year&apos;s old~`; //这里打印 //Hi, Gary is my name, //I&apos;m 25 year&apos;s old~ console.log(sentence); ES6类的存取函数 在ES6中实现了类的表象,虽然还是基于原型链来实现的,但是大致的功能正在向着C、Java类的方式逐渐靠近,比如类的存取函数 class Book { constructor(name = &quot;Gary&quot;) { this._name = name; } //类的取值函数 get getBook() { return this._name; } //类的存储函数 set setBook(value) { this._name = `Hi, ${value}`; } } //获取到&quot;书&quot;这个类的实例 let book = new Book(&quot;Yinwk&quot;); //调用实例的取值函数 //这里打印: //Yinwk console.log(book.getBook); //调用实例的存储函数 book.setBook = &quot;yinwenkai&quot;; //再次调用实例的取值函数 //这里打印: //yinwenkai console.log(book.getBook); 各类型比较运算符时的转化 if(“package” == true) console.log(“package == true”);是会打印”package == true”呢,还是不会打印呢,很多人的答案肯定是会打印,理由是:因为”package”返回true啊,所以true == true啊。请看这里判断语句中是一个比较表达式,并不是if(“package”),是需要在比较语句两边进行转化的,普通类型进行toNumber,引用类型进行valueOf或者toString之后的原始值比较 if(null == undefeind) {...} //返回true if(undefined == null) {...} //返回true if(&quot;package&quot; == true) {...} //将string和boolean类型进行number转化, //&quot;package&quot;转化为NaN,true转化为1, //NaN == 1吗?答案当然是false,返回false if(&quot;0&quot; == false){...} //将string和boolean类型进行number转化, //&quot;0&quot;转化为0,false转化为0, //0 == 0吗?答案当然是true,返回true if(&quot;package&quot; == 1){...} //将string和number类型进行number转化, //将&quot;package&quot;转化为NaN,1还是转化为1, //NaN == 1吗?答案当然是false,返回false let _obj = {name: &apos;Gary&apos;}, _objAno = {name: &apos;Gary&apos;}; if(_obj == _objAno){...} //将两个object类型进行valueOf方法或者toString方法的转化,哪个方法转化为原始值,就用转化为的原始值进行比较 //{name: &apos;Gary&apos;}在valueOf方法转化为{name: &apos;Gary&apos;},在toString方法转化为&quot;[object Object]&quot; //原始值当然是valueOf方法转化的值 //{name: &apos;Gary&apos;} == {name: &apos;Gary&apos;}吗？答案当然是false,返回false ES6新增Array.prototype.include ES6数组新增了一个判断是否包含数组元素的方法,用来检索数组中是否存在某个数组元素,基本有两种方式进行检索 let number_arr = [26, 18, 10, 55, 88, 100, 38, 44]; //数组中的确包含 88 这个元素 //在这里打印: //true console.log(number_arr.includes(88)); //从数组下标为 5 的元素后面去寻找 88 这个元素 //在这里打印: //false console.log(number_arr.includes(88, 5)); ES6类型数组 在ES6中引入了一些类型数组,他们的属性以及方法和普通的数组并无二致,只是对类型做了一些限制,比如Int8Array(8位二进制补码整数)、Uint8Array(8位无符号整数)、Int16Array(16位二进制补码整数)、Uint16Array(16位无符号整数)、Int32Array(32位二进制补码整数)、Uint32Array(32位无符号整数)等等 对具有着重符的字符串数组进行排序 假如需要对具有着重符号的字符串数组进行排序,需要用localCompare let string_arr = [&quot;Maève&quot;, &quot;Maeve&quot;]; string_arr.sort(function sort_arr(a, b){ return a.localCompare(b); }); //没有着重符号的数组元素会比有着重符号的数组元素小 //这里打印: //[&quot;Maeve&quot;, &quot;Maève&quot;] console.log(string_arr); apply、call硬绑定小经验function Person() { this.name = &quot;Gary&quot;; this.age = 26; console.log(this.name); console.log(this.age); } let clay = { name: &quot;Clay&quot;, age: 27 }; //这里充分证明了new绑定实现构造函数对象的优先级大于call或者apply硬绑定 //Person函数的this指向并没有指向clay,还保持着初始值 //而对象clay的属性name和age的值都改变为Person函数this指向的值 //在这里打印: //Gary //26 //Gary //26 Person.call(clay); console.log(clay.name); console.log(clay.age); function Person() { console.log(this.name); console.log(this.age); } let clay = { name: &quot;Clay&quot;, age: 27 }; //这里Person函数的this指向clay //而对象clay的属性name和age的值还是保持着初始值 //在这里打印: //Clay //27 //Clay //27 Person.call(clay); console.log(clay.name); console.log(clay.age); 从上面的例子,我们可以得出this的绑定优先级: new绑定 &gt; apply、call和bind硬绑定 &gt; 普通对象软绑定 &gt; 默认绑定,当this对象上面的属性进行定义声明,再使用apply、call或者bind硬绑定时,new绑定this对象上面的属性的优先级就大于apply、call或者bind硬绑定对象上面的属性的优先级,这时候显示的就是this对象上面的属性值,当this对象上面的属性没有进行定义声明,这时候apply、call或者bind硬绑定对象上面的属性的优先级就是最大的,这时候显示的就是硬绑定对象上面的属性的属性值]]></content>
      <categories>
        <category>Html or Css Or Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Html</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-06 封装的一些小工具]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[debounce函数节流 函数节流通常被用于输入下拉框、滚动懒加载等场景,目的只有一个,在短时间内,限制多次调用后台接口,浪费大量资源,防止接口响应数据时间上的误差造成的页面显示数据的错误。 //设置一个timer变量,用来承接setTimeout返回的延时对象 const timer = null; //函数节流方法 function debounce(fuc, delay) { //每一次进行输入或者拉动滚动条的时候,都会对延时对象进行判断,假如存在延时对象,就停止延时对象,并把延时对象置为空,释放内存,使得垃圾回收机制能更快的对延时对象进行回收 if(timer) { clearTimeout(timer); timer = null; } //给延时对象赋予一个延时方法,fuc就是请求后台接口的函数,delay就是延时时间 timer = setTimeout(fuc, delay); } //函数节流方法,只要在delay时间内,再次触发此方法,延时对象就会被停止且置空,后台的接口函数就不会被调用。 //做到了在短时间内输入或者滚动限制了多次调用后台接口,防止了接口响应数据时间上的误差造成页面数据显示的错误。 bind函数绑定 bind绑定是一种硬绑定,和apply函数、call函数一样的作用,且更加简便,其作用也是为了改变函数或者”类”函数this的指向,大多数浏览器都是已经实现了内置bind方法,我们今天来模拟一下bind方法的实现 if(Function.prototype.bind === undefined) { Function.prototype.bind = function(context) { //首先判断调用bind方法的是否是函数类型 //假如不是函数类型,直接抛出错误异常 if(typeof this !== &quot;function&quot;) { throw new Error(&quot;bind函数必须应用在函数上面&quot;); } //获取arguments参数,除了要绑定的对象第一个参数之外的所有的参数,并生成数组 let args = Array.prototype.slice.call(arguments, 1), self = this, fBind; function F() {} //在闭包中进行硬绑定,假如闭包不作为new绑定的函数对象使用,则其中的this指向window,假如作为new绑定的函数对象使用,则其中的this指向闭包函数对象 fBind = function () { let args_fBind = Array.prototype.slice.call(arguments); return self.apply(this instanceof fBind ? this : context, args.concat(args_fBind)); } //假如闭包作为new绑定的函数对象使用,就要继承bind绑定函数对象的显式原型 //即闭包函数对象的隐式原型指向其bind绑定函数对象的显式原型 F.prototype = self.prototype; fBind.prototype = new F(); fBind.constructor = fBind; return fBind; } } window.name = &quot;Gary&quot;; function Person(age) { console.log(this.name); this.age = age; console.log(this.age); } //此时this默认绑定在window上面 //在这里打印: //Gary //24 Person(24); let clay = { name: &quot;Clay&quot; }; //此时进行硬绑定,this指向clay对象 //而闭包函数对象中的this则指向window //在这里打印: //Clay //25 let me = Person.bind(clay); me(25); Person.prototype.introduce = function () { console.log(`name: ${this.name}, age: ${this.age}`); }; //此时进行硬绑定,this本指向clay对象 //但是闭包函数对象却进行了new绑定构造函数操作,使得this指向闭包函数本身 //闭包函数本身并不存在name对象,所以打印this.name为undefined,无定义的 //在这里打印: //undefined //26 //undefined //26 //name: undefined, age: 26 let me_bind = Person.bind(clay); let Clay = new me_bind(26); console.log(Clay.name); console.log(Clay.age); Clay.introduce(); new绑定实现构造函数对象 Javascript中存在一种特定的设计模式:原型设计模式,每一个对象都具有一个隐式原型,每一个函数对象都具有一个显式原型,通过new绑定实现构造函数对象返回的引用对象进行串联,也就是说每一个引用对象的隐式原型指向其构造函数的显式原型,所有的对象都是通过一个空对象复制出来的,也就是Object.prototype,现在我们模拟模拟一下new绑定实现构造函数对象 function ObjectNew() { let obj_prototype = {}, Constructor = Array.prototype.slice.call(arguments, 0, 1)[0]; obj_prototype.__proto__ = Constructor.prototype; let res = Constructor.apply(obj_prototype, Array.prototype.slice.call(arguments, 1)); return typeof res === &quot;object&quot; ? res : obj_prototype; } function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`name: ${this.name}, age: ${this.age}`); }; //这里和new绑定实现构造函数对象的效果一模一样 //在这里打印: //Gary //26 //name: Gary, age: 26 let gary = ObjectNew(Person, &apos;Gary&apos;, 26); console.log(gary.name); console.log(gary.age); gary.introduce(); getElementsByClassName封装 getElementsByClassName是HTML5 DOM引入的一个获取class样式节点的方法,有一些不支持HTML5 DOM的浏览器可能不存在这个方法,所以需要对这个方法进行封装 //html code &lt;!Doctype html&gt; &lt;html lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;getElemetnsByClassName封装&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;home&quot;&gt; &lt;p class=&quot;number&quot;&gt;first&lt;/p&gt; &lt;p class=&quot;number second&quot;&gt;second&lt;/p&gt; &lt;p class=&quot;number&quot;&gt;third&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;boxesByClassName.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; //boxesByClassName.js function getElementsByClassName(node, className) { //判断DOM是否有getElementsByClassName方法,假如有,就返回node节点下的所有className子节点 if(node.getElementsByClassName) { return node.getElementsByClassName(className); } else { //假如没有,就先去获取node节点下的所有子节点元素,然后根据子节点元素的className属性进行匹配外部传入的className,假如包含此className,就传入返回的数组中,最后返回数组 let _get_className_arr = [], _tag_arr = node.getElementsByTagName(&quot;*&quot;), _tag_arr_length = _tag_arr.length; for(let i = 0; i &lt; _tag_arr_length; i++) { if(_tag_arr[i].className.includes(className)){ _get_className_arr[_get_className_arr.length] = _tag_arr[i]; } } return _get_className_arr; } } addEvent加载完成事件封装 对于window.onload事件,再熟悉不过了,用于在页面DOM全部加载完毕之后执行Javascript,防止在页面DOM渲染过程中对DOM进行操作,使得页面卡顿,降低用户体验。window.onload的挂载一个或者多个的方式于实际情况而定,所以需要对window.onlaod加载完成事件进行封装 function addEvent(eventLoad) { //将window.onload事件函数赋值给一个变量 let load = window.onload; //判断window.onload加载完成事件上面,是否挂载了事件函数 //假如挂载了事件函数,就将新的事件函数添加到window.onload加载完成事件队列中 //假如没有挂载事件函数,就直接将新的事件函数挂载上去 if (typeof load !== &quot;function&quot;) { window.onload = eventLoad; } else { window.onload = function() { load(); eventLoad(); } } } insertAfter插入到某个元素节点之后封装 parentNode.insertBefore(newElement, targetElement),insertBefore方法是在某一个元素节点之前插入新的元素节点,而DOM-Core并没有提供insertAfter方法,旨在在某一个元素节点之后插入新的元素节点,于是进行insertAfter封装 function insertAfter(newElement, targetElement) { //获取目标节点的父节点 let parent = targetElement.parentNode; //判断父节点的最后一个子节点是否是目标节点,假如是,就直接将新的元素节点,添加到父节点下 //假如不是,就将新的元素节点插入到目标节点兄弟节点之前 if(parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement, targetElement.nextSibling); } } isEmpty判断对象是否为空的封装 Javascript的对象判断是否为空,并没有原生的方法,所以需要封装一下,成为自己的库 function isEmpty(obj) { //判断对象是否为空的标识符,默认为true,判断对象为空 let flag = true; //使用ES6遍历对象,假如对象中有遍历的对象属性,就说明对象不为空,设置flag为false,判断对象不为空 for(let [key, value] of Object.entries(obj)) { if(obj.hasOwnProperty(key)) { flag = false; break; } } return flag; } getNextElementSibling获取元素节点的下一个兄弟元素节点 node.nextSibling是获取某一个元素节点的下一个兄弟节点,但是节点类型可能是元素、属性以及文本,是不确定的,而通常,我们希望获取下一个兄弟节点的时候为元素节点,所以需要对获取元素节点的下一个兄弟元素节点进行封装 function getNextElementSibling(node) { //判断元素节点是否有下一个兄弟节点,如果没有返回false if(!node.nextSibling) return false; //获取元素节点的下一个兄弟节点 let nextSibling = node.nextSibling; //假如元素节点的下一个兄弟节点的节点类型为1,也就是元素节点,就返回元素节点的下一个兄弟节点 if(nextSibling.nodeType === 1) { return nextSibling; } //假如元素节点的下一个兄弟节点的节点类型为除了1以外的其他数字,就再次递归元素节点的下一个兄弟节点,直到找到下一个兄弟元素节点位置 return getNextElementSibling(nextSibling); } moveElement动态的元素节点 通过原生的Javascript来生成动画,是解决CSS3不兼容低版本浏览器的最好的平稳退化方案,利用setTimeout生成的通用动画效果的函数方法在此 //设置一个承接时间对象的变量 let timer = null; //函数传递四个参数,要产生移动的元素节点,将要移动到的x轴位置,将要移动到的y轴位置,以及移动元素节点的时间(单位: 毫秒) function moveElement(node, x, y, speed) { //首先校验是否存在移动元素的节点,假如不存在,直接返回false,退出函数 if(!document.getElementById(node)) return false; let elem = document.getElementById(node); //然后判断是否有时间对象,假如有的话,直接清理掉,并把时间对象置为空,以便浏览器垃圾回收机制更快的回收内存中的不需要的数据 if(timer) { clearTimeout(timer); timer = null; } //判断移动元素节点样式的top和left属性是否存在,如果不存在,初始化top和left的属性为0px if(!elem.style.top) { elem.style.top = &quot;0px&quot;; } if(!elem.style.left) { elem.style.left = &quot;0px&quot;; } //获取移动元素节点样式的top和left属性值,并转化为绝对值的数值类型 let xpo = Math.abs(parseInt(elem.style.left)), ypo = Math.abs(parseInt(elem.style.top)); //假如移动元素节点样式的left的绝对值与要移动到的x轴位置相等,且移动元素节点样式的top的绝对值与要移动到的y轴位置相等,则返回true,退出递归函数 if(xpo === x &amp;&amp; ypo === y) { return true } let dist; //假如移动元素节点样式的left的绝对值小于要移动到的x轴位置,就将移动元素节点样式的left的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果 if(xpo &lt; x) { dist = Math.ceil((x - xpo) / 10); xpo += dist; } //假如移动元素节点样式的left的绝对值大于要移动到的x轴位置... if(xpo &gt; x) { dist = Math.ceil((xpo - x) / 10); xpo -= dist; } //假如移动元素节点样式的top的绝对值小于要移动到的y轴位置,就将移动元素节点样式的top的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果 if(ypo &lt; y) { dist = Math.ceil((y - ypo) / 10); ypo += dist; } //假如移动元素节点样式的top的绝对值大于要移动到的y轴位置... if(ypo &gt; y) { dist = Math.ceil((ypo - y) / 10); ypo -= dist; } //将移动元素节点样式的top和left的绝对值取反,赋值重新赋值给移动元素节点样式 elem.style.left = `${-xpo}px`; elem.style.top = `${-ypo}px`; //未到目标位置,设置时间处理函数继续递归动态的元素节点函数,并把时间对象赋值给timer变量 timer = setTimeout(function timer() { moveElement(node, x, y, speed); }, speed); } getGreyGeneral根据图片利用canvas制作灰度图 利用canvas画布可以制作各种各样的图片以及动画效果,包括二维、三维等图片和动画,灰度图就是二维图片中一个比较难处理的例子,由此对其进行封装 function getGreyGeneral(img) { //假如Modernizr检测兼容的全局对象中查找不到canvas属性,就返回false,退出函数 if(!Modernizr.canvas) return false; //假如document对象中不存在createElement方法,也返回false,退出函数 if(!document.createElement) return false; //创建一个canvas元素节点对象 let canvas = document.createElement(&quot;canvas&quot;); //设置canvas元素节点对象的宽和高为图片的宽和高 canvas.width = img.width; canvas.height = img.height; //获取canvas二维画布绘图环境 let ctx = canvas.getContext(&quot;2d&quot;); //在二维画布绘图环境上面,根据图片DOM对象进行绘制,从图片DOM对象坐标的(0, 0)位置开始绘制 ctx.drawImage(img, 0, 0); //获取到二维绘图环境的图片数据,从坐标(0, 0)位置开始,到图片的(img.width, img.height)宽度和高度位置截止 let c = ctx.getImageData(0, 0, img.width, img.height); //对图片数据进行灰度处理,获取到每个像素的rgb值,每四个像素(最后一个像素永远是255)数据一组,求rgb的平均值,并重新赋值给rgb for(let i = 0;i &lt; c.height;i ++) { for(let j = 0;j &lt; c.width;j ++) { let x = i * 4 * c.height + j * 4, data = c.data, r = data[x], g = data[x + 1], b = data[x + 2]; data[x] = data[x + 1] = data[x + 2] = (r + g + b) / 3; } } //将灰度处理好的二维绘图环境图片数据,重新赋予到原来的二维绘图环境上面,且设置二维绘图环境的偏移位置(0, 0),以及绘图处理渲染的偏移位置(0, 0),最后设置二维绘图环境图片数据的宽度和高度 ctx.putImageData(c, 0, 0, 0, 0, img.width, img.height); //返回canvas生成的图片数据URL return canvas.toDataURL(); } setVideoControl配置video视频播放器的默认播放和暂停按键 HTML5中新加了video和audio标签,以前都是使用object和embed标签来插入视频和音频插件,有好多繁琐的配置,现在有了video和audio标签使得我们在编写视频和音频代码时,方便快捷了很多,下面是对video播放和暂停键重置的封装 function setVideoControl(video) { //首先先将video视频元素节点的controls属性删掉,这样controls一系列默认的播放、暂停键以及滑动条等配置就被剔除掉了 video.removeAttribute(&quot;controls&quot;); //设置video视频元素节点的宽度和高度,分别为视频的实际宽度和高度 video.width = video.videoWidth; video.height = video.videoHeight; //设置video视频元素节点的宽度和高度,分别也为视频的实际宽度和高度 video.parentNode.width = video.videoWidth; video.parentNode.height = video.videoHeight; //创建一个承接播放/暂停按钮的div容器,再创建一个播放/暂停按钮 let play = document.createElement(&quot;div&quot;), button = document.createElement(&quot;button&quot;); //设置div容器的title标题属性默认为&quot;Play&quot; play.setAttribute(&quot;title&quot;, &quot;Play&quot;); //设置播放/暂停按钮默认的文本节点为&amp;#x25BA;(播放按钮) button.innerHTML = &quot;&amp;#x25BA;&quot;; //将播放/暂停按钮放入到div容器中 play.appendChild(button); //并将承接播放/暂停按钮的div容器插入到video视频元素节点之前 video.parentNode.insertBefore(play, video); //设置承接播放/暂停按钮的div容器点击事件: //假如video视频元素节点的暂停属性为true,则执行video视频元素节点的play播放方法 //否则执行vedio视频元素节点的pause暂停方法 play.onclick = function (e){ if(video.paused) { video.play(); } else { video.pause(); } }; //设置video视频元素节点的play播放方法,将承载播放/暂停按钮的div容器title标题属性设置为Pause,并设置播放/暂停按钮的文本节点设置为&amp;#x2590;&amp;#x2590;(暂停按钮) video.addEventListener(&quot;play&quot;, function (e) { button.innerHTML = &quot;&amp;#x2590;&amp;#x2590;&quot;; play.setAttribute(&quot;title&quot;, &quot;Pause&quot;); }); //设置video视频元素节点的pause暂停方法,将承载播放/暂停按钮的div容器title标题属性设置为Play,并设置播放/暂停按钮的文本节点设置为&amp;#x25BA;;(播放按钮) video.addEventListener(&quot;pause&quot;, function (e) { button.innerHTML = &quot;&amp;#x25BA&quot;; play.setAttribute(&quot;title&quot;, &quot;Play&quot;); }); //设置video视频元素节点的ended视频结束方法,将video视频元素节点的currentTime属性(当前滑动条进度)设置为:起始位置,并执行video视频元素节点pause暂停方法 video.addEventListener(&quot;ended&quot;, function (e) { video.currentTime = 0; video.pause(); }); } Symbol.iterator迭代对象 说起Symbol.iterator,就会想到ES6新引进的迭代器,像Array.keys(),Array.values(),Array.entries(),都是Symbol.iterator迭代对象实现的,每一次迭代(.next())都会返回一个对象: {value: 迭代的值, done: 迭代的状态},当迭代结束,就会返回{value: undefined, done: true},但是这个迭代对象只存在于数组、Object对象以及Generator等迭代器里,要想迭代对象,需要手动去添加它的Symbol.iterator方法 let yinwk = { name: &quot;Gary&quot;, age: 25, hobby: [&quot;basketball&quot;, &quot;tennis&quot;], [Symbol.iterator]() { //首先将this对象赋值给一个变量 let that = this, //然后获取this对象指向的本对象的属性数组 that_key = Object.keys(that), //接着获取本对象的属性数组的长度 len = that_key.length, //最后定义一个递增变量,用来遍历本对象的属性值 index = 0; //返回一个对象,对象中有一个next函数方法,在其中判断递增变量index是否大于属性数组的长度, //假如不大于,说明没有迭代完成,则返回{value: 属性值(that[that_key[index++]]), done: false} //假如大于,说明迭代完成,则返回{value: 属性值(that[that_key[index++]]), done: true} return { next() { if(index &gt; len){ return { value: that[that_key[index++]], done: true } } else { return { value: that[that_key[index++]], done: false } } } } } }; //对添加好迭代对象的对象进行遍历 //这里打印: // &quot;Gary&quot; // 25 // [&quot;basketball&quot;, &quot;tennis&quot;] for(let value of yinwk) { console.log(value); } 闭包实现缓存机制 有时一些函数内的重复循环、判断甚至是普通的同步定义赋值,对于浏览器来说或大或小都是损耗,现在我们使用闭包对重复的操作缓存起来,减少重复的操作和损耗,提高浏览器的性能 function cache() { //进行存储的对象 let res_obj = {}; //进行运算的操作函数 function operation() { let a = 1; for(let i = 0; i &lt; arguments.length; i++) { a *= arguments[i]; } return a; } return function() { let args = Array.prototype.join.call(arguments, &quot;_&quot;); if(res_obj[args]) { return res_obj[args]; } console.log(&quot;first cache~&quot;); return res_obj[args] = operation.apply(this, arguments); } } let cache_control = cache(); //在这里打印: //first cache~ let cache_result = cache_control(3, 4, 5); //在这里打印: //60 console.log(cache_result); //在这里打印: //60 console.log(cache_control(3, 4, 5)); 使用命令模式实现模拟的开关Tv的功能 将开关Tv对象封装至函数内部,以构造函数的引用对象或者闭包函数的方式导出,调用新的函数方法控制模拟开关Tv,首先以构造函数的引用对象方式导出 let Tv = { open() { console.log(&quot;open the Tv&quot;); }, close() { console.log(&quot;close the Tv&quot;); } }; //以构造函数的引用对象方式导出 function CommandInOrder(command) { this.command = command; } //原型链函数方法: 打开Tv CommandInOrder.prototype.openTheTv = function() { this.command.open(); }; //原型链函数方法: 关闭Tv CommandInOrder.prototype.closeTheTv = function() { this.command.close(); }; function CommandInOrderOutput(command) { document.getElementById(&quot;open&quot;).onclick = function(e) { command.openTheTv(); //取消冒泡 e.stopImmediatePropagation(); }; document.getElementById(&quot;close&quot;).onclick = function(e) { command.closeTheTv(); //取消冒泡 e.stopImmediatePropagation(); } } //点击id为open的元素 //在这里打印: //open the Tv //点击id为close的元素 //在这里打印: //close the Tv CommandInOrderOutput(new CommandInOrder(Tv)); 接着是以闭包的方式导出 let Tv = { open() { console.log(&quot;open the Tv&quot;); }, close() { console.log(&quot;close the Tv&quot;); } }; //以闭包的方式导出 function CommandInOrder(command) { function openTheTv() { command.open(); } function closeTheTv() { command.close(); } return { openTheTv, closeTheTv } } function CommandInOrderOutput(command) { document.getElementById(&quot;open&quot;).onclick = function(e) { command.openTheTv(); //取消冒泡 e.stopImmediatePropagation(); }; document.getElementById(&quot;close&quot;).onclick = function(e) { command.closeTheTv(); //取消冒泡 e.stopImmediatePropagation(); }; } //点击id为open的元素 //在这里打印: //open the Tv //点击id为close的元素 //在这里打印: //close the Tv CommandInOrderOutput(CommandInOrder(Tv)); 高阶函数 回调高阶函数事例: xhr请求回调高阶函数 //xhr请求回调高阶函数 function xhr_request(callback) { let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;../data/code.json&quot;); xhr.onreadystatechange = function () { callback.apply(xhr, arguments); }; xhr.send(null); } //在这里打印: //{code: &quot;000000&quot;} xhr_request(function (e) { if(this.readyState === 4) { if(this.status === 200) { console.log(JSON.parse(this.responseText)); } } //取消冒泡 e.stopImmediatePropagation(); }); 回调函数高阶函数事例: 创建DOM节点回调高阶函数 //创建DOM节点回调高阶函数 function createDOMNode(callback) { for(let i = 0; i &lt; 10; i++) { let div = document.createElement(&quot;div&quot;); callback.call(div, i); document.body.appendChild(div); } } createDOMNode(function (number) { let text = document.createTextNode(number); this.appendChild(text); }); 闭包高阶函数: 单例模式 //单例函数 function getSingle(func) { let res; return function() { return res || (res = func.apply(this, arguments)); } } let Single = getSingle(function () { return document.createElement(&quot;script&quot;); }); let single_one = Single(); let single_two = Single(); //在这里打印: //true console.log(single_one === single_two); 闭包高阶函数: AOP装饰者模式 /** * 在某个函数之前执行 */ Function.prototype.before = function(before) { let self = this; return function() { before.apply(this, arguments); return self.apply(this, arguments); } }; /** * 在某个函数之后执行 */ Function.prototype.after = function(after) { let self = this; return function() { let res_func = self.apply(this, arguments); after.apply(this, arguments); return res_func; } }; function mid() { console.log(&quot;this is middle~&quot;); } //AOP装饰者模式完成并执行 let res = mid.before(function() { console.log(&quot;this is before~&quot;); }).after(function() { console.log(&quot;this is after~&quot;); }); //在这里打印: //this is before~ //this is middle~ //this is after~ res(); 高阶函数实用 curry化,柯里化高阶函数 /** * 柯里化高阶函数 */ function Currying() { let res_arr = []; function curry_result() { let m = 0; for(let i = 0; i &lt; arguments.length; i++) { m += arguments[i]; } return m; } return function() { if(arguments.length &gt; 0) { let args = Array.prototype.slice.call(arguments, 0); res_arr = [...res_arr, ...args]; } else { return curry_result.apply(this, ...res_arr); } } } let currying_res = Currying(); currying_res(300); currying_res(255); currying_res(244); currying_res(344); currying_res(88); //在这里打印: //1231 console.log(currying_res()); uncurry化,非柯里化高阶函数,直接将原型函数方法外用 /** * 非柯里化高阶函数 */ Function.prototype.uncurrying = function() { let self = this; return function() { let obj = Array.prototype.slice.call(arguments, 0, 1)[0], args = Array.prototype.slice.call(arguments, 1); return self.apply(obj, args); } }; let push = Array.prototype.push.uncurrying(); //在这里打印: //[1, 2, 3, 4] (function() { push(arguments, 4); console.log(arguments); })(1, 2, 3); let obj = { length: 3, 0: 1, 1: 2, 2: 3 }; push(obj, &quot;4&quot;); //在这里打印: //{0: 1, 1: 2, 2: 3, 3: &quot;4&quot;} console.log(obj); uncurry化拓展,非柯里化高阶函数 /** * 非柯里化高阶函数 */ Function.prototype.uncurrying = function() { let self = this; return function() { let obj = Array.prototype.slice.call(arguments, 0, 1)[0], args = Array.prototype.slice.call(arguments, 1); return self.apply(obj, args); } }; let method_arr = [&quot;push&quot;, &quot;shift&quot;, &quot;forEach&quot;]; for(let i = 0; i &lt; method_arr.length; i ++) { Array[method_arr[i]] = Array.prototype[method_arr[i]].uncurrying(); } let obj = { length: 3, 0: 1, 1: 2, 2: 3 }; Array.push(obj, &quot;44&quot;); //在这里打印: //{0: 1, 1: 2, 2: 3, 3: &quot;44&quot;, length: 4} console.log(obj); Array.shift(obj); //在这里打印: //{0: 2, 1: 3, 2: &quot;44&quot;, length: 3} console.log(obj); //在这里打印: //2 //3 //&quot;44&quot; Array.forEach(obj, function(item, index){ console.log(item); }); uncurry化拓展call与apply,非柯里化高阶函数 /** * 非柯里化高阶函数 */ Function.prototype.uncurrying = function() { let self = this; return function() { let obj = Array.prototype.slice.call(arguments, 0, 1)[0], args = Array.prototype.slice.call(arguments, 1); return self.apply(obj, args); } }; let call = Function.prototype.call.uncurrying(); let name = &quot;Gary&quot;; window.name = &quot;Clay&quot;; function introduce() { console.log(name); console.log(this.name); } //在这里打印: //&quot;Gary&quot; //&quot;Clay&quot; call(introduce, window); let apply = Function.prototype.apply.uncurrying(); function Gary_myself() { console.log(arguments); console.log(this.name); } //在这里打印: //[&quot;simon&quot;] //&quot;wenkai yin&quot; apply(Gary_myself, {name: &quot;wenkai yin&quot;}, [&quot;simon&quot;]); 函数节流高阶函数,我们在前面整理过函数节流,只是这次的函数节流与上次不同,这次在延时的时间内不能再执行调用方法的操作,只有等到延时处理器执行完才停止延时处理器,而上次无论是是否是在延时的时间内,只要再次执行调用方法的操作,就直接停止延时处理器 /** * 函数节流 */ function throttle(func, speed) { let first_time = true, timer; return function() { let self = this, args = arguments; if(first_time) { func.apply(self, args); first_time = false; } if(timer) { return false; } timer = setTimeout(function time() { clearTimeout(timer); timer = null; func.apply(self, args); }, speed); } } //在这里打印: //Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} //Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …} //800 window.onresize = throttle(function(e) { console.log(this); console.log(e); console.log(800); }, 800); 分时高阶函数,有时为了防止大量的DOM操作,比如一次性创建几万个DOM节点,一起添加到页面上,使得浏览器卡顿甚至是卡down,分时函数就是解决这个问题的比较不错的方法,将这几万个DOM节点,分为很多份,在一定的时间内,只去处理一份内的节点数据,添加到页面上,这样比较大的优化了浏览器的性能 /** * 分时函数 */ function timeShare(share_arr, func, count) { let timer, inner_arr = share_arr; function resolve_res() { for(let i = 1; i &lt;= Math.min(count || 1, inner_arr.length); i ++) { let inner_shift = inner_arr.shift(); func.call(this, inner_shift); } } return function() { let self = this, args = arguments; timer = setInterval(function time() { if(inner_arr.length &lt;= 0) { clearInterval(timer); timer = null; } resolve_res.apply(self, args); }, 100); } } let share_arr = Array.from(Array.apply(null, {length: 1000}), function map(item, index) { return index + 1; }); timeShare(share_arr, function(i) { let div = document.createElement(&quot;div&quot;), text = document.createTextNode(i); div.appendChild(text); document.body.appendChild(div); }, 8); 惰性加载高阶函数 /** * 普通惰性加载函数,调用时,每一次都要去判断哪种事件方式浏览器可用,这样虽对于性能没有什么大影响,但是还是很不优雅的 */ function addEvent(elem, type, func) { if(window.addEventListener) { elem.addEventListener(type, function() { func.apply(this, arguments); }); } if(window.attachEvent) { elem.attachEvent(`on${type}`, function() { func.apply(this, arguments); }); } } addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) { console.log(e.target); }); /** * 这样省去了在调用时的判断哪种事件方式浏览器可用,换成了在浏览器加载时判断,只判断一次,这样在调用时就可以直接使用判断后的事件方式了,但是假如页面没有使用到事件,还是进行了判断哪种事件方式浏览器可用,这样浪费了浏览器的性能,还是不能这样做的 */ let addEvent = (function (){ if(window.addEventListener) { return function(elem, type, func) { elem.addEventListener(type, function() { func.apply(this, arguments); }); } } if(window.attachEvent) { return function(elem, type, func) { elem.attachEvent(`on${type}`, function() { func.apply(this, arguments); }); } } })(); addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) { console.log(e.target); }); /** * 这样只有在第一次调用addEvent函数方法的时候,才回去判断哪种事件方式浏览器可用,在第一次调用之后,就直接将判断后的那种事件方式以另外一种函数方法的方式赋值给addEvent变量,然后再继续执行调用addEvent函数方法,再一次调用时,就不需要判断哪种方式浏览器可用了,直接调用第一次判断过后赋值给addEvent变量的函数方法即可,这就是惰性加载函数 */ let addEvent = function(elem, type, func) { let args = Array.prototype.slice.call(arguments); if(window.addEventListener) { addEvent = function(elem, type, func) { elem.addEventListener(type, function() { func.apply(this, arguments); }); } } if(window.attachEvent) { addEvent = function(elem, type, func) { elem.attachEvent(`on${type}`, function() { func.apply(this, arguments); }); } } addEvent(elem, type, func); }; addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) { console.log(e.target); });]]></content>
      <categories>
        <category>封装的一些小工具</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-30 webpack打包如何防止第三方依赖包体积过大造成打包速度慢的问题]]></title>
    <url>%2F2018%2F04%2F30%2Fwebpack%E6%89%93%E5%8C%85%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BF%87%E5%A4%A7%E9%80%A0%E6%88%90%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为何第三方依赖包会引起打包的体积过大 ES6的模块化机制,当引入外部第三方依赖包时,无论是否已经引入,都会再次将其引入进来,这时候就会存在重复引入导致打包体积过大、打包速度过慢的问题。 如何解决重复引入第三方依赖包,引起的打包体积过大以及打包速度过慢的问题 使用CommonsChunkPlugin提取公共模块,理想状态下是将第三方外部依赖包、业务代码、业务代码中的重复引入的公共部分和webpack的引导程序以及manifest 加载运行外部依赖包都分别打成一个包,减小打包体积,提高打包的速度。 const webpack = require(&quot;webpack&quot;), HtmlWebpackIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;), HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;; module.exports = { entry: { //login入口有引入testConfig.js以及reactConfig.js login: `${APP_DIR}/login.js`, //index入口也有引入testConfig.js以及reactConfig.js index: `${APP_DIR}/index.js`, //app入口没有引入testConfig.js,也没有引入reactConfig.js app: `${APP_DIR}/app.js`, //mobile入口有引入testConfig.js,却没有引入reactConfig.js mobile: `${APP_DIR}/mobule.js` }, plugins: [ //... //首先我想把四个入口中的公共模块,包括引入的第三方外部依赖包都提取出来 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;login.html&quot;, template: `${ROOT_DIR}/login.html`, chunks: [&quot;common&quot;, &quot;login&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;index.html&quot;, template: `${ROOT_DIR}/index.html`, chunks: [&quot;common&quot;, &quot;index&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;app.html&quot;, template: `${ROOT_DIR}/app.html`, chunks: [&quot;common&quot;, &quot;app&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;mobile.html&quot;, template: `${ROOT_DIR}/mobile.html`, chunks: [&quot;common&quot;, &quot;mobile&quot;], inject: &quot;body&quot; }) //发现这样行不通,打包之后,common.[hash].js中只有webpack引导程序以及manifest 加载运行模块的代码,公共部分并没有办法提取出来。 //后来查找原因,原来是CommonsChunkPlugin中的minChunks属性默认设置为公共模块部分最小在全部入口全部引入,才会被提取合成公共代码。 //知道了原因,那就简单了,直接设置minChunks: 2,也就是说只要公共模块最小在两个入口引入,就可以被提取出来作为公共模块部分。 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos;, minChunks: 2 }), ... //这样设置之后发现是可以的,将公共的第三方的外部依赖包、testConfig.js、reactConfig.js、webpack引导程序以及manifest 加载运行模块部分都提取出来,打包至common.[hash].js中,减小了打包的体积,加快了打包速度。 //试想假如我只想提取testConfig.js模块 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos;, //minChunks还可以是一个函数,接收两个参数,module是指入口所引入的每一个模块,count则是指module被几个入口所调用 //module有两个属性: context和resource //context: 模块所存储的目录位置 //resource: 模块所执行的文件名称 //这里就是使用resource模块所执行的文件名称去匹配testConfig,且模块至少被两个入口所引入,这样就可以单独提取testConfig.js文件了 minChunks: function(module, count) { return module.resource &amp;&amp; /testConfig/.test(module.resource) &amp;&amp; count &gt;= 2; } }), ... ], //将第三方公共依赖包与testConfig.js、reactConfig.js这种业务开发所使用的公共模块分离开,使得第三方公共依赖包分离在另一个包下 entry: { //login入口有引入testConfig.js以及reactConfig.js login: `${APP_DIR}/login.js`, //index入口也有引入testConfig.js以及reactConfig.js index: `${APP_DIR}/index.js`, //app入口没有引入testConfig.js,也没有引入reactConfig.js app: `${APP_DIR}/app.js`, //mobile入口有引入testConfig.js,却没有引入reactConfig.js mobile: `${APP_DIR}/mobule.js`, //设置一个第三方外部依赖包的入口 vendor: [&apos;react&apos;, &apos;react-redux&apos;, &apos;redux&apos;, &apos;react-router&apos;, &apos;redux-thunk&apos;, &apos;redux-logger&apos;, &apos;react-dom&apos;, &apos;react-addons&apos;, &apos;prop-types&apos;, &apos;moment&apos;, &apos;antd&apos;, &apos;babel-polyfill&apos;] }, plugins: [ ... //这里无论入口是否引入了vendor入口数组里面的第三方依赖包,它都会对数组里面的第三方外部依赖包进行提取,当然这里的第三方外部依赖包是有限制的,module.context在这里起到了作用,只有模块所存储的路径含有&quot;node_modules&quot;的情况下,也就是说只有是在npm下载的第三方外部依赖包,才会被提取出来。 new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, filename: &apos;js/vendor.[hash].js&apos;, minChunks: function(module, count) { return module.context &amp;&amp; module.context.includes(&quot;nodule_modules&quot;); } }), //这样提取第三方外部依赖包是可以的,直接提取到js文件夹里面的vendor.[hash].js //上面以及所有的提取的公共模块文件加hash的原因,是为了防止浏览器的永久缓存机制,使得文件更新过后,使用的还是原来文件的内容。 //提取出了第三方外部依赖包之后,由于想到它们不是业务代码,很少进行修改,尽量的多利用浏览器永久缓存机制,所以为了防止每一次构建都会引起它们hash值的改变,不能利用浏览器永久缓存机制,要把webpack引导程序以及manifest 加载运行文件提取到另一个模块包中。 //这里manifest就是隐藏的webpack引导程序以及manifest 加载和运行模块文件的入口 new webpack.optimize.CommonsChunkPlugin({ name: &apos;manifest&apos;, filename: &apos;js/manifest.[hash].js&apos;, minChunks: Infinity }), //这样提取webpack引导程序以及manifest 加载和运行文件是可以的,直接提取到js文件夹里面的manifest.[hash].js //再提取出业务使用的像testConfig.js、reactConfig.js公共模块,想着应该可以满足需求,业务代码的公共部分一个模块包,第三方外部依赖包一个模块包,以及webpack引导程序和manfiest 加载运行模块文件一个模块包 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos;, minChunks: 2 }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;login.html&quot;, template: `${ROOT_DIR}/login.html`, chunks: [&quot;manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;login&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;index.html&quot;, template: `${ROOT_DIR}/index.html`, chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;index&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;app.html&quot;, template: `${ROOT_DIR}/app.html`, chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;app&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;mobile.html&quot;, template: `${ROOT_DIR}/mobile.html`, chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;mobile&quot;], inject: &quot;body&quot; }) //发现这样实现是不可以的,第三方外部依赖包的模块包,webpack引导程序以及manifest 加载和运行模块文件的模块包被打出来了。 //但是common.[hash].js中却没有至少两个入口共同引入业务代码公共模块的部分,还是被分别打进了业务代码模块包中。 //且common.[hash].js中的代码实际上是webpack运行文件以及manfiest 加载和运行模块的文件部分,manfiest.[hash].js也不见了,好像common.[hash].js替换掉了。 //原因到现在还没有找到... //CommonsChunkPlugin的缺点就在于:即使我使用了vendor的方式去提取公共的第三方外部依赖包模块,还是在每一次构建的时候,都会去进行打包,像我前面说的,第三方外部依赖包模块不像业务代码,很少进行修改。 //所以每一次都去进行打包,还是不妥当的,花费了很多时间在打包第三方外部依赖包上面。 ] }; 使用DllPlugin、DllReferencePlugin、CommonsChunkPlugin以及HtmlWebpackIncludeAssetsPlugin实现对第三方外部依赖包模块、业务代码公共模块以及webpack引导程序和manifest 加载和运行模块文件都分别打成一个包,减小打包体积,提高打包的速度。 //使用DllPlugin和DllReferencePlugin,就不需要像CommonsChunkPlugin那样,对于第三方外部依赖包模块,每次都要去构建打包了,只需要另外配置一个webpack配置文件,就可以实现一劳永逸的体验。 //只要没有下载新的第三方外部依赖包模块,就不需要利用webpack.dll.config配置文件去打dll包,总体上减少了每次都构建第三方外部依赖包模块的时间。 //webpack.dll.config配置 const webpack = require(&quot;webpack&quot;), path = require(&quot;path&quot;); const PUBLIC_DIR = &quot;/&quot;, DLL_DIR = path.resolve(__dirname, &quot;../dll&quot;), ROOT_DIR = path.resolve(__dirname, &quot;../..&quot;); const webpackDllConfig = { devtool: &quot;source-map&quot;, entry: { vendor: [&quot;react&quot;, &quot;react-router&quot;, &quot;redux&quot;, &quot;react-redux&quot;, &quot;redux-thunk&quot;, &quot;redux-logger&quot;, &quot;react-dom&quot;, &quot;react-addons&quot;, &quot;prop-types&quot;, &quot;antd&quot;, &quot;babel-polyfill&quot;] }, output: { publicPath: PUBLIC_DIR, path: DLL_DIR, filename: &quot;[name].dll.js&quot;, library: &quot;[name]_[chunkhash]&quot; }, plugins: [ //防止打包过程中出现错误,中断打包 new webpack.NoEmitOnErrorsPlugin(), //谈一下DllPlugin,DllPlugin的机制是根据webpack制定的id映射到vendor入口中的第三方外部依赖包模块的路径上,生成映射关系,打包后,生成vendor.dll.js文件和vendor_manifest.dll.json文件,这个文件的内容是webpack制定的id与vendor入口中的第三方外部依赖包模块的映射数据,之后再使用DllReferencePlugin将vendor_manifest.dll.json文件引入到业务代码打包的配置文件的manfiest 加载和运行模块文件中,最后只要将vendor.dll.js引入到你所选择的业务代码入口就可以了。 //vendor.dll.js的作用是,根据vendor_manifest.dll.json中webpack制定的id与vendor入口中第三方外部依赖包模块路径的映射关系,业务代码入口所引入的第三方外部依赖包模块,都会通过vendor.dll.js全局函数进行处理,并根据所引入的第三方外部依赖包模块的id进行使用,且这样并不会把库文件中的代码也打包进去 new webpack.DllPlugin({ path: path.join(DLL_DIR, &quot;[name]_manifest.dll.json&quot;), //name必须和output的library属性保持一致 name: &quot;[name]_[chunkhash]&quot;, context: ROOT_DIR }), //对打包代码进行压缩 new webpack.optimize.UglifyJsPlugin({ uglifyOptions: { sourceMap: true, compress: { unused: false, dead_code: false, warnings: true }, output: { comments: true } } }) ] }; export default webpackDllConfig; //业务代码webpack打包配置文件 const webpack = require(&quot;webpack&quot;), path = require(&quot;path&quot;), //用来复制目录或者目录下的文件的插件 CopyWebpackPlugin = require(&quot;copy-webpack-config&quot;), //用来将vendor.dll.js插入到业务代码入口的插件,但不可选择插入的入口业务代码文件,默认会将所有的入口业务代码都插入vendor.dll.js AddAssetHtmlPlugin = require(&quot;add-asset-html-webpack-plugin&quot;), //用来将vendor.dll.js插入到业务代码入口的插件,可选择插入的入口业务代码文件 HtmlWebpackIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;), HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;, ROOT_DIR = path.resolve(__dirname, &quot;../&quot;), BUILD_DIR = path.resolve(__dirname, &quot;../build&quot;), DLL_DIR = path.resolve(__dirname, &quot;../dll&quot;), IMAGE_DIR = path.resolve(__dirname, &quot;../images&quot;), MANIFEST_DIR = require(path.resolve(__dirname, `${DLL_DIR}/vendor_manifest.dll.json`)); const webpackProdConfig = { entry: { //login入口有引入testConfig.js以及reactConfig.js login: `${APP_DIR}/login.js`, //index入口也有引入testConfig.js以及reactConfig.js index: `${APP_DIR}/index.js`, //app入口没有引入testConfig.js,也没有引入reactConfig.js app: `${APP_DIR}/app.js`, //mobile入口有引入testConfig.js,却没有引入reactConfig.js mobile: `${APP_DIR}/mobule.js` }, ... plugins: [ ... //这里就是将vendor_manfiest.dll.json第三方外部依赖包模块引入到业务代码的打包配置文件的manifest 加载和运行模块文件中 new webpack.DllReferencePlugin({ manifest: MANIFEST_DIR, context: ROOT_DIR }), new CopyWebpackPlugin([{ context: ROOT_DIR, from: IMAGE_DIR, to: `${BUILD_DIR}/images` },{ context: ROOT_DIR, from: DLL_DIR, to: `${BUILD_DIR}/dll` }, { context: ROOT_DIR, from: &quot;./dll/vendor.dll.js&quot;, to: &quot;js/&quot; }]), //这里的AddAssetHtmlPlugin会将所有的业务代码入口都引入vendor.dll.js文件 //new AddAssetHtmlPlugin({ // filepath: &quot;js/vendor.dll.js&quot;, // hash: true //}), //这里的HtmlWebpackIncludeAssetsPlugin会有选择的将login、index、app入口文件引入vendor.dll.js,可实现按需加载 //append属性设置为false,是确保vendor.dll.js文件在业务代码包模块之前引入 new HtmlWebpackIncludeAssetsPlugin({ assets: [&quot;js/vendor.dll.js&quot;], files: [&quot;login.html&quot;, &quot;index.html&quot;, &quot;app.html&quot;], append: false, hash: true }), //这样第三方外部依赖包模块就生成了,当每次没有新的第三方外部依赖包模块下载时,就可以直接利用vendor.dll.js全局函数处理对引入的webpack制定的id与vendor_manfiest.dll.json中的第三方外部依赖包模块路径的映射进行调用 new webpack.optimize.CommonsChunkPlugin({ name: &quot;common&quot;, filename: &quot;js/common.[hash].js&quot;, minChunks: 2 }), //这里上面在CommonsChunkPlugin部分有介绍过,直接对业务代码中的公共模块部分进行提取,且至少在两个入口中有公共模块的引入 new webpack.optimize.CommonsChunkPlugin({ name: &quot;manifest&quot;, filename: &quot;js/manifest.[hash].js&quot;, minChunks: Infinity }), //再将webpack引导程序以及manfiest 加载运行模块文件从common.[hash].js文件中提取出来,这样就完成配置了 new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;login.html&quot;, template: `${ROOT_DIR}/login.html`, chunks: [&quot;manifest&quot;, &quot;common&quot;, &quot;login&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;index.html&quot;, template: `${ROOT_DIR}/index.html`, chunks: [manifest&quot;, &quot;common&quot;, &quot;index&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;app.html&quot;, template: `${ROOT_DIR}/app.html`, chunks: [manifest&quot;, &quot;common&quot;, &quot;app&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;mobile.html&quot;, template: `${ROOT_DIR}/mobile.html`, chunks: [manifest&quot;, &quot;common&quot;, &quot;mobile&quot;], inject: &quot;body&quot; }) ] }; 这种由DllPlugin、DllReferencePlugin和HtmlWebpackIncludAssetsPlugin(可实现按需加载)打包第三方外部依赖包模块,由CommonsChunkPlugin提取业务代码公共模块部分和webpack引导程序以及manifest 加载运行模块文件的方式,很好的实现了对第三方外部依赖包模块、业务代码公共模块以及webpack引导程序和manifest 加载和运行模块文件的打包,减小了打包体积,提高了打包的速度。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-30 关于闭包]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是回调函数 A函数作为B函数的参数,并在B函数中执行,A函数就是回调函数。 function setTimer(fn, timer) { fn(timer); } //function timer就是function setTimer的回调函数 setTimer(function timer(time) { console.log(time); }, 1000); 回调函数也分同步和异步,上例就是同步,而像setTimeout,setInterval中这种牵扯到消息队列(异步队列),Event Loop的回调函数来说,就是异步。 什么是闭包 “A函数中包含B函数,并返回B函数,调用B函数可以使用A函数作用域中定义的变量”,B函数就是闭包,示例如下: function foo() { let _name = &quot;Gary&quot;; function bar() { console.log(`name: ${_name}`); } return bar; } //foo函数执行之后,作用域会被销毁,随之而然的作用域中定义的变量应该会被销毁,并被引擎垃圾回收机制回收, //但是在这里神奇的事情发生了,foo函数作用域并没有被销毁之后回收,而是还存在于内存中,并被bar使用,这里就形成了闭包。 let bar = foo(); bar(); 还有一种形式是这样 function foo() { let _name = &quot;Gary&quot;; function bar() { console.log(`name: ${_name}`); } baz(bar); } //这里在foo函数执行之后,按理来说,foo函数中作用域,以及其中_name变量,都会被销毁,并随后被引擎垃圾回收机制回收。 //但是神奇的是,这里的作用域并没有被销毁,而其中的_name变量也没有被销毁,当然也没有被引擎垃圾回收机制回收,而还是存储于内存中,并被bar使用,这里就形成了闭包。 function baz(fn) { fn(); } foo();]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于异步]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是异步 异步在JS中的表现分为三类: 时间延迟,比如setTimeout,setInterval这种时间处理函数 事件处理,比如onClick(点击事件),onChange(输入框内容改变回调),onMouseover(鼠标移入事件),onMouseout(鼠标移出事件),onMouseEnter(鼠标移入事件),onMouseLeave(鼠标移出事件)等等 xhr、fetch请求等等 为什么会出现异步 由于JS是单线程(同一时间,只能做一件事情)的语言,为了实现时间延迟、事件处理和xhr、fetch请求处理这些必须是异步的操作,JS必须处理单线程怎样异步的问题。 为什么JS要使用单线程 JS使用单线程,是由于JS中不仅仅有ECMAScript,还有DOM(Document Object Modal),html渲染DOM,JS也可以动态改变DOM,假如JS不是单线程,同一时间可以处理多件事情,html渲染DOM和JS动态改变DOM就会混乱,浏览器会不知道是先渲染html DOM,还是先执行JS动态改变DOM,即使是实现了多线程的WebWorker,也没有触及DOM部分。 关于异步 JS使用单线程,运行时,先会运行同步代码,如果遇到异步代码,就会先将异步代码放进内存的异步队列中,待到同步代码运行完毕,就会去轮询异步队列中的异步代码。 假如异步闭包中还存在异步闭包,在异步队列中,就会将里层的异步闭包push到外层的异步闭包后面,待到外层的异步闭包执行完毕之后,再执行里层的异步闭包。 使用异步出现的问题 JS使用异步解决了JS单线程的问题,但是异步却又引起了另外一个问题,就是异步情况下的同步执行,尤其是xhr、fetch的请求,由于响应时间不确定,很容易引起异步执行混乱的问题。 异步的演变过程setTimeout callback 之前还没有使用nodejs的时候,解决异步问题基本上使用的是setTimeout使用异步闭包去解决异步的方式,比如在react中,setState就是异步执行的,假如name的初始值为Gary componentWillMount() { this.setState({ name: &quot;Yinwk&quot; }); this.setState({ name: &quot;CLAY&quot; }); //这时候由于setState是异步的,所以会先执行同步代码,也就是说这时候this.state.name的值依然为Gary console.log(this.state.name); } componentWillMount() { setTimeout(function timer(){ this.setState({ name: &quot;Yinwk&quot; }); //这时候this.state.name的值就变为了Yinwk console.log(this.state.name); setTimeout(function timer(){ this.setState({ name: &quot;CLAY&quot; }); //这时候this.state.name的值就变为了CLAY console.log(this.state.name); }.bind(this), 0); }.bind(this), 0) } EventEmitter(并不是异步问题的解决方案) nodejs出现之后,event模块有一个类——EventEmitter,一直以为它是一个消息管理模块,跟Event Loop异步队列有着千丝万缕的关系,后来看了源码,发现它并不是一个消息管理模块,跟消息队列没有任何关系,on/emit只是一个监听的观察者模式,on时添加/删除listener,emit时运行回调函数。还是拿上一个例子进行举例,假如name的初始值为Gary import {EventEmitter} from &quot;events&quot;; const eventEmitter = new EventEmitter(); componentWillMount(){ eventEmitter.on(&quot;gary&quot;, () =&gt; { this.setState({ name: &quot;Yinwk&quot; }); console.log(this.state.name); }); //这里打印出的this.state.name还是Gary,由于EventEmitter跟消息队列没有任何关系,所以并不是异步,只是一个监听的观察者模式,所以是同步的 eventEmitter.emit(&quot;gary&quot;); } Promise ES6语法发布之后,Promise成为了新的解决异步问题的方案,实质的也是利用异步闭包来解决异步问题。还是拿最初的例子进行举例,假如name的初始值为Gary ComponentWillMount() { (function iifeSetName() { return new Promise(function promise(resolve, reject) { this.setState({ name: &quot;Yinwk&quot; }); resolve(); }.bind(this)); }.bind(this))().then(function resolve() { //这里打印出的this.state.name就是Yinwk console.log(this.state.name); }.bind(this), function reject() { }.bind(this)); } yield and * 再到后来最新的解决异步的方案:yield *配合Promise,也就是Generator控制迭代器,执行时每执行到yield时,就会停止执行并返回一个Iterator迭代器,且会保留上下文,直到下次运行,社区tj大神的co函数同步读取文件就是使用了yield *配合Promise const fs = require(&quot;fs&quot;); function readFile(file){ return new Promise((resolve, reject) =&gt; { fs.readFile((err, data) =&gt; { if(err) reject(err); resolve(data); }); }); } function *gc() { let a = yield readFile(&quot;../data/file_first.txt&quot;); console.log(a); let b = yield readFile(&quot;../data/file_second.txt&quot;); console.log(b); return b; } co(gc).then(function resolve(data){ console.log(data); }.bind(this), function reject(){ }.bind(this)); //co函数利用yield * + Promise同步读取文件 function co(gc_co){ let gc = gc_co(); return new Promise((resolve, reject) =&gt; { //这里实现一个Generator控制迭代器的迭代循环 (function readData(data){ let gcNext = gc.next(data), value = gcNext.value, done = gcNext.done; if(done) { resolve(value); } else { value.then(readData, reject); } })(); }); } async and await 现如今的推出的解决异步问题的最终解决方案:async和await,很好的解决了异步的问题,且当await Promise时,返回的是fulfilled和rejected返回的结果。还是拿最初的例子进行举例,假如name的初始值为Gary ComponentWillMount() { (async function iifeSetName() { await this.setState({ name: &quot;Yinwk&quot; }); //这里打印出的this.state.name就是Yinwk await console.log(this.state.name); }.bind(this))(); } 还可以这样 ComponentWillMount() { (async function iifeSetName() { let name = await new Promise((resolve, reject) =&gt; { this.setState({ name: &quot;Yinwk&quot; }); resolve(); }).then(()=&gt;{ return this.state.name; }, ()=&gt;{ }); //这里打印出的this.state.name就是Yinwk await console.log(name); //这里打印出的this.state.name还是Yinwk await console.log(this.state.name); }.bind(this))(); }]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于webpack]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8Ewebpack%2F</url>
    <content type="text"><![CDATA[关于webpack 使用webpack已有大半年,从webpack 1.0直到4.0,都有尝试过,每次升级都比较痛苦,今天梳理一下不同点 webpack 1.0 webpack是现如今非常流行、易用语义化很明显的打包压缩工具,废话不多说,直接上代码(会有明确的注释)。PS：react使用的是CommonJS模块化语法 const webpack = require(&quot;webpack&quot;), //对于路径管理的外部依赖包 path = require(&quot;path&quot;), //自动添加css扩展头以兼容低版本浏览器的外部依赖包 autoprefixer = require(&quot;autoprefixer&quot;), //处理打包css的webpack plugin插件 ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;), //处理打包html的webpack plugin插件 HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;, //路径巡航,先进入webpack文件所在的路径,然后再进入根路径,我这里是把webpack配置文件放在了根路径底下的一个文件夹里面 ROOT_DIR = path.resolve(__dirname, &quot;../&quot;)]]></content>
      <categories>
        <category>webpack or webpack-dev-server</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>webpack-dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于webstorm]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8Ewebstorm%2F</url>
    <content type="text"><![CDATA[webstorm license server 从毕业就开始使用webstorm,从webstorm 11到webstorm 2017,再到现在的webstorm 2018,webstorm IDE功能越来越强大,但是我从来不使用正版,而今天就给大家介绍一下,在使用盗版过程中最大的困难——license server。在最初的时候,我也是百度的一些Activation code,后来发现这些Activation code极不稳定,可能是一个Activation code只能在一个终端使用吧,我放弃了使用Activation code的方式。 后来,在Webstorm吧找到了一种可以设置试用期到2099年的方法:改变本地的日期时间至2099年11月30日,然后安装webstorm,选择试用,试用期一个月,这时候你的试用期就到了2099年的12月31日。假如你已经安装了webstorm,直接找到WINDOWS系统,C:/Users(用户)/你的WINDOWS电脑用户名/.Webstorm2017.2/config/eval,直接将eval文件删掉,重新打开webstorm,更改本地日期,后面的操作就同上了。直到2017.3版本之前,使用的很舒服,到了2017.3版本,JetBrains发现了这个漏洞,进行了修补,由此也放弃了使用这种方式。 再之后,就开始使用license server,使用的license server如下: http://idea.imsxm.com (2017.3.3版本极其之前版本可用) http://idea.iteblog.com/key.php (2017.1可用) http://www.aku.vn/idea (2017.1可用) http://idea.ibdyr.com (2017.3.3版本极其之前版本可用) 再后来,就开始使用本地nginx反向代理http://idea.imsxm.com,将下面的配置放进server中: location /rpc { proxy_pass http://idea.imsxm.com/rpc; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 现在连本地nginx反向代理都失效了,jetbrains在2017.3.4版本使用了ip地址动态封禁,经过我很长时间的寻找,找到了现在在2018版本之后都可使用的license server: http://www.activejetbrains.ml 最新的license server转自网上的一篇文章,来源于https://www.imsxm.com/jetbrains-license-server.html]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react思想]]></title>
    <url>%2F2018%2F04%2F26%2Freact%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[React主体思想 React的主体思想:数据驱动。就是利用数据的变化,来引起View视图的变化。React使用的是jsx(js + xml)语法和虚拟DOM,虚拟DOM是React做的一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,来进行View视图的渲染,虚拟DOM节点发生变化时,React首先会利用diff算法对前后的虚拟DOM树进行对比,一旦发现有所不同,就会引起虚拟DOM从根结点进行重新刷新,而浏览器实际操作DOM的仅仅是diff部分,尽管每一次虚拟DOM都会从根结点进行重新刷新,但是由于是内存数据,所以性能很高,而浏览器实际操作DOM的仅仅是diff的部分,所以很大程度上提高了web网站的性能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-26 Javascript 0.1 + 0.2 !== 0.3]]></title>
    <url>%2F2018%2F04%2F26%2Fjavascript-0-1-0-2-0-3%2F</url>
    <content type="text"><![CDATA[为什么0.1 + 0.2 !== 0.3 Javascript的浮点数类型不够精确,双精度浮点数类型的二进制位数加上符号位为53位,也就是说0.1的二进制树加上0.2的二进制数,转化为十进制数为0.30000000000000004,所以0.1 + 0.2 !== 0.3 怎么解决0.1 + 0.2 !== 0.3的问题 最好的方法是设置一个误差”机器精度”的范围值,与0.1 + 0.2 - 0.3的值进行比较,假如不超过这个范围就返回true,如果超过这个范围就返回false,可以利用ES6给开发者提供的一个新属性EPSILON,这个属性正好等于2^-52,无限接近于0,但不等于0 0.1 + 0.2 - 0.3 &lt; Number.EPSILON 也可以利用保留小数的方式进行解决,比如toFixed和toPrecision parseFloat((0.1 + 0.2).toFixed(1)) === 0.3]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-25 react优化]]></title>
    <url>%2F2018%2F04%2F25%2Freact%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[React性能优化 由于React使用的虚拟DOM在其节点发生变化时,React会使用Diff算法对前后的虚拟DOM树进行对比,一旦发现不同,虚拟DOM树就会从根结点进行重新刷新,而浏览器进行实际操作DOM的仅仅是diff的部分,尽管每次虚拟DOM都会从根结点进行重新刷新,但是由于javascript是存储在内存中,所以性能很高,但是每一次都会从虚拟DOM的根结点进行重新刷新,会造成一些无谓的虚拟DOM树的重新刷新,比如父组件的虚拟DOM节点修改发生了变化,虚拟DOM节点根据diff算法进行对比之后,就会从虚拟DOM根结点进行重新刷新,但是其子组件并没有发生虚拟DOM的修改,这是子组件也会跟着父组件一起进行虚拟DOM树的diff算法对比和虚拟DOM节点的重新刷新,也耗费了比较多的时间。为了避免无谓的虚拟DOM树diff算法对比和虚拟DOM根结点的重新刷新,React给开发者提供了shouldComponentUpdate进行判断,shouldComponentUpdate是运行在虚拟DOM树diff算法对比和虚拟DOM树根结点重新渲染之前的,假如返回true就说明,数据发生了变化,需要进行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新,否则就返回false,不执行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新。 避免无谓的虚拟DOM树重新刷新 假如有一个组件仅仅渲染一个字符串,利用shouldComponentUpdate进行判断,避免无谓的虚拟DOM树重新刷新 class TextView extends React.Component{ static propTypes = { value: PropTypes.string.isRequired }; constructor(props){ super(props); this.state = { }; } shouldComponentUpdate(nextProps, nextState){ return this.props.value !== nextProps.value; } render(){ let {value} = this.props; return ( &lt;h1&gt; {value} &lt;/h1&gt; ) } }]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-25 react-router 3.0 browserHistory配置]]></title>
    <url>%2F2018%2F04%2F25%2Freact-router-3-0-browserHistory%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为什么推荐使用browserHistory,舍弃hashHistory 首先browserHistory从表现来看,比较舒服和语义化,更易读。 browserHistory使用的是HTML5的History API,根据路由路径的变化引起浏览器历史记录的变化;hashHistory则是依靠hash的改变,来使得浏览器的历史记录发生改变。hashHistory的hash部分不会请求到服务端,服务端获取不到URL的细节部分,而browserHistory使用的History API需要服务端的支持,服务端可以完全的掌握URL中的细节部分。 有一些浏览器会把hashHistory URL当中的hash部分删除掉,记起之前进行分享的时候,URL传到微信中,hash部分遭到丢失。 browserHistory配置 路由上面除了引入不同,基本上和hashHistory配置相同 import {Router, browserHistory} from &quot;react-router&quot;; &lt;Router history={browserHistory}&gt; &lt;/Router&gt; 配置路径为空时,callback的处理,使用webpack-dev-server时,在配置文件内部添加 historyApiFallback: true 使用nginx时,在配置文件内部添加 location / { root ... index index.html index.htm try_files $uri /index.html }]]></content>
      <categories>
        <category>react-router</category>
      </categories>
      <tags>
        <tag>react-router</tag>
        <tag>browserHistory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-24 react原理]]></title>
    <url>%2F2018%2F04%2F24%2Freact%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[React原理 React的主体思想:数据驱动。React根据数据的变化,使得View视图rerender,也就是重新渲染。React使用的是jsx(js + xml)语法和虚拟DOM,React引入虚拟DOM,是一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,使得View进行渲染,当虚拟DOM节点发生修改时,React使用diff算法进行比对,一旦发现不同,React虚拟DOM就会从根节点进行rerender,而浏览器实际的DOM操作仅仅是diff部分,尽管每次的虚拟DOM都是从根节点进行刷新,但由于是内存数据,性能很高,而浏览器实际的DOM操作仅仅是diff部分,从而很大程度上提高了web网站的性能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-24 hexo搭建自己的博客]]></title>
    <url>%2F2018%2F04%2F24%2Fhexo%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[git建库 首先要先建立一个以dreamthen(我的用户名).github.io结尾的repository,作为hexo托管代码的库,github默认.github.io结尾作为用户的网站二级域名。所以github用户搭建自己的个人网站很容易。 hexo安装 首先要用npm外部依赖包管理工具安装全局命令hexo-cli npm install hexo-cli -g 然后使用hexo初始化博客文件夹,比如blog文件夹 hexo init blog 之后,进入生成的blog文件夹,下载外部依赖包 npm i/npm install 最后启动hexo自身搭建的服务,生成本地的博客网站,默认端口在本地ip地址下的4000端口,假如你不想启动在4000端口,也可使用-p 其他端口号进行配置,比如-p 9977 hexo server hexo server -p 9977 默认的主题风格theme是landscape,假如你想更换,可以通过https://hexo.io/themes/进行筛选,筛选之后进行配置,主题配置见下文 hexo配置 hexo git配置 要想部署到自己搭建的个人网站github库里面,首先要下载hexo-git插件 npm install hexo-deployer-git --save 然后就要在你自己的本地hexo博客的项目里面,更改根目录底下的_config.yml文件,全局搜索git,更改deploy配置 deploy: type: git repo: git@github.com:dreamthen/dreamthen.github.io.git(你的个人网站github库的链接地址,最好使用git:开头的,https:开头的会报错) branch: master(分支名) hexo theme主题配置 筛选好自己选中的主题之后,就需要在项目里面进行配置更换。首先需要下载远程github库里面的主题项目到项目根目录里面的themes文件夹底下,比如本人用的是next主题的hexo git clone https://github.com/iissnan/hexo-theme-next.git themes/next 随后更改根目录里面的_config.yml文件,全局搜索theme,更改theme配置 theme: next 接着选择主题展示的方式,需要在主题的项目目录下,更改_config.yml文件,全局搜索Scheme,更改Scheme配置,比如next主题底下的Scheme配置 scheme: #scheme: Muse scheme: Mist #scheme: Pisces #scheme: Gemini hexo language语言配置 每个主题的语言都是根据作者的母语来配置的,要想配置开发者自己国家的语言,还是更改项目根目录底下的_config.yml文件,全局搜索language,更改language配置 language: zh-CN 再更改主题项目目录底下的language文件夹底下的zh-Hans.yml文件,将其重命名为zh-CN.yml,再更改其目录底下的_config.yml文件,全局搜索language,更改language配置 language: zh-CN hexo page 页面配置 hexo提供了几个可供筛选的页面,常用的有这么几个：home(首页)、tags(标签)、about(关于我)、archives(档案)和categories(分类),首先要创建页面 hexo new page tags hexo new page about hexo new page archives hexo new page categories 接着在主题项目目录下,更改_config.yml文件,全局搜索menu,更改menu配置,当然每个主题的配置不尽相同 menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 随后更改source目录底下创建的页面,以tags为例 ---------------------------- title: about date: 2018-04-24 17:57:26 type: &quot;tags&quot; comments: false ---------------------------- hexo avatar 头像配置 配置自己个人博客网站的头像,需要更改hexo博客项目底下的_config.yml文件,添加avatar配置 avatar: https://avatars1.githubusercontent.com/u/13704681?s=400&amp;u=bfc4636397a7c4384f63d4836a33d1797cd2c660&amp;v=4(头像url链接) hexo search 全站搜索配置 假如想要配置自己hexo个人博客网站的全站搜索配置,首先要下载hexo search外部依赖包 npm install hexo-generator-search --save npm install hexo-generator-searchdb --save 更改hexo博客项目根目录底下的_config.yml文件,添加search配置 search: path: search.xml field: post format: html limit: 10000 开启主题项目目录底下的_config.yml文件中的local_search配置 local_search: enable: true hexo new_post_name配置 假如想要更改每一篇博客的文件名称,不再是默认的:title.md的文件名,需要更改hexo博客项目根目录底下的_config.yml文件,更改new_post_name配置 new_post_name: :year-:month-:day-:title.md hexo auto_excerpt阅读全文配置 博客文章一般都会很长的,所以在首页要对博客进行超长截断,要想看所有的内容,点击阅读全文或者文章标题进入全文查看,需要更改主题项目目录底下的_config.yml文件,全局搜索auto_excerpt,更改auto_excerpt配置 auto_excerpt: enable: true length: 200 hexo 其他配置 更改hexo博客项目根目录底下的_config.yml文件,更改网站title(标题)、author(作者)、keywords(关键字)、description(描述)配置,比如本人的配置 title: yinwk_Gary Blog author: yinwk_Gary keywords: hexo,hexo-cli,hexo博客,hexo博客个人网站 description: Gary&apos;s blog,记录_从今天开始 设置个人的github(github托管代码网址)、google(google个人资料网址)、gmail(gmail邮箱网址)、twitter(twitter个人微博网址)等等,比如本人的配置 social: GitHub: https://github.com/dreamthen || github E-Mail: https://dreamthen.00@gmail.com || envelope Google: https://plus.google.com/u/0/103833130011211353424 || google #hexo命令 首先建立一篇名为hexo配置的博客 hexo new hexo配置 在hexo博客项目source目录底下的_post目录下找到名为hexo配置的博客文件,在里面用markdown进行记录自己的博客,当然可以在hexo server自带的服务器运行监听的情况下,进行添加和修改自己的博客。之后，进行生成静态文件 hexo generate 生成静态文件之后,进行部署 hexo deploy 生成静态文件和部署可以使用一句命令执行 hexo generate -deploy hexo deploy -generate 为了防止存在静态文件和缓存,造成没有重新渲染页面的问题,在每一次部署之前,要运行一下清理静态文件和缓存的命令 hexo clean hexo generate hexo deploy hexo deploy部署之后,根据hexo博客项目根目录底下_config.yml配置文件的deploy git配置,会提交到远程github repository库]]></content>
      <categories>
        <category>hexo博客搭建工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-cli</tag>
      </tags>
  </entry>
</search>
