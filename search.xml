<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018-05-21 使用Canvas绘制圆角按钮]]></title>
    <url>%2F2018%2F05%2F21%2F%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[使用Canvas可视化工具绘制圆角按钮 最近刚接触了Canvas可视化工具,下面通过一个使用Canvas绘制的圆角按钮的例子,来实践学到的Canvas经验 //对加载完成事件的封装,在本人写的日志2018-05-06-封装的一些小工具中有详细描述,在这里不再做更多的赘述 let addEvent = (eventLoad) =&gt; { let load = window.onload; if(typeof load !== &quot;function&quot;) { window.onload = eventLoad; } else { window.onload = function() { load(); eventLoad(); }; } }; //Canvas绘制圆角按钮的函数 let canvasRadiusButton = () =&gt; { //假如DOM-Core中不存在getElementById方法,则返回false,退出函数 if(!document.getElementById) return false; //假如DOM-Core中不存在createElement方法,则返回false,退出函数 if(!document.createElement) return false; //假如DOM中不存在id名为home的元素节点,则返回false,退出函数 if(!document.getElementById(&quot;home&quot;)) return false; //获取id名为home的元素节点 let home = document.getElementById(&quot;home&quot;), //创造出canvas元素节点标签 canvas = document.createElement(&quot;canvas&quot;); //设置canvas元素节点标签的宽度和高度都为200px canvas.width = 200; canvas.height = 200; //设置canvas绘制画布的类型为: 2d(平面画布) let ctx = canvas.getContext(&quot;2d&quot;); //绘制画布开始绘制路径 ctx.beginPath(); //设置绘制画布的起点坐标为: (12, 20) ctx.moveTo(12, 20); //使用贝塞尔曲线去绘制圆角 //bezierCurveTo方法有三组坐标参数,前面两组为两个控制点位置,利用这两个控制点可以完美的画出半圆、椭圆甚至是圆角,最后一组为曲线终点的位置 ctx.bezierCurveTo(12, 16, 15, 14, 19, 14); //绘制直线至画布的(129, 14)坐标 ctx.lineTo(129, 14); //继续使用贝塞尔曲线绘制圆角 ctx.bezierCurveTo(133, 14, 136, 16, 136, 20); //绘制直线至画布的(136, 45)坐标 ctx.lineTo(136, 45); //继续使用贝塞尔曲线绘制圆角 ctx.bezierCurveTo(136, 49, 133, 51, 129, 51); //绘制直线至画布的(19, 51)坐标 ctx.lineTo(19, 51); //继续使用贝塞尔曲线绘制圆角 ctx.bezierCurveTo(15, 51, 12, 49, 12, 45); //绘制直线至画布的(12, 20)坐标 ctx.lineTo(12, 20); //绘制画布结束绘制路径 ctx.closePath(); //设置画布路径的填充样式为: rgba(255, 255, 0, 0.8) ctx.fillStyle = &quot;rgba(255, 255, 0, 0.8)&quot;; //进行画布填充 ctx.fill(); //设置画布路径的color样式为: rgba(255, 0, 0, 0.5) ctx.strokeStyle = &quot;rgba(255, 0, 0, 0.5)&quot;; //画布路径绘制完毕,实现绘制模型 ctx.stroke(); //将canvas元素节点添加到home元素节点里面,作为home元素节点的子节点 home.appendChild(canvas); }; addEvent(canvasRadiusButton);]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-21 Javascript数据结构与算法]]></title>
    <url>%2F2018%2F05%2F21%2FJavascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[栈 Stack 栈是数据结构中比较简单的顺序数据结构,特点是: 后进先出,新的元素或者你也可以理解为待删除的元素更接近与栈顶,而旧的元素更接近于栈底,生活中有很多栈的例子,比如说堆在一起的书,再比如说特别拥挤的地铁,你可以理解为任何只有一个出口的事物,都可以作为栈来使用,在Javascript中,我们可以使用数组来模拟栈的实现,首先是ES5版本 //全局声明一个数组变量: stack_mock let stack_mock = []; //声明一个函数,这里当作栈Stack的类 function Stack (){ } //向栈内添加元素 Stack.prototype.push = function(element) { return stack_mock.push(element); }; //栈顶删除元素 Stack.prototype.pop = function() { return stack_mock.pop(); }; //校验栈是否为空 Stack.prototype.isEmpty = function() { return stack_mock.length === 0; }; //获取栈顶的元素 Stack.prototype.peek = function() { let len = stack_mock.length; return stack_mock[len - 1]; }; //获取栈内元素的个数 Stack.prototype.size = function() { return stack_mock.length; }; //对栈内所有元素进行打印 Stack.prototype.print = function() { return stack_mock.toString(); }; //对栈进行清空 Stack.prototype.clear = function() { stack_mock = []; }; //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这种方式stack_mock数组变量暴露在全局中,其他人可以随意修改,很不安全,且一个类的实例只能对应一个类似stack_mock的数组变量,很不方便,所以最好放在类的内部或者与类进行映射,下面是改进之后的ES6版本 //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部定义stack_mock属性,并初始化为空数组 this[&quot;stack_mock&quot;] = []; } //向栈内添加元素 push(element) { return this[&quot;stack_mock&quot;].push(element); } //栈顶删除元素 pop() { return this[&quot;stack_mock&quot;].pop(); } //校验栈是否为空 isEmpty() { return this[&quot;stack_mock&quot;].length === 0; } //获取栈顶元素 peek() { let len = this[&quot;stack_mock&quot;].length; return this[&quot;stack_mock&quot;][len - 1]; } //获取栈内元素的个数 size() { return this[&quot;stack_mock&quot;].length; } //对栈内所有元素进行打印 print() { return this[&quot;stack_mock&quot;].toString(); } //对栈进行清空 clear() { this[&quot;stack_mock&quot;] = []; } } //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这种方式不仅避免了数组变量暴露在全局被随意修改的风险,还避免了一个数组变量只能对应一个类的实例的窘境,但是在类函数内部的属性,通过实例是可以进行获取和修改的,所以内部属性被随意修改的问题又暴露了出来,类似于这样 //声明一个栈Stack类的实例 let stack = new Stack(); //获取到类函数内部属性&quot;stack_mock&quot; let stack_mock = stack[&quot;stack_mock&quot;]; //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //设置类函数内部属性&quot;stack_mock&quot;为空数组 stack[&quot;stack_mock&quot;] = []; //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //&quot;&quot; console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //undefined console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 明明已经添加到栈内的元素,直接被外部设置内部属性为空数组,给删除掉了,这岂不是很尴尬,所以想要利用Symbol ES6中这种枚举新语法进行改进 //声明一个可公用的Symbol的枚举变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let Stack = (function (){ let stack_mock = Symbol(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部定义stack_mock Symbol属性,并初始化为空数组 this[stack_mock] = []; } //向栈内添加元素 push(element) { return this[stack_mock].push(element); } //栈顶删除元素 pop() { return this[stack_mock].pop(); } //校验栈是否为空 isEmpty() { return this[stack_mock].length === 0; } //获取栈顶元素 peek() { let len = this[stack_mock].length; return this[stack_mock][len - 1]; } //获取栈内元素的个数 size() { return this[stack_mock].length; } //对栈内所有元素进行打印 print() { return this[stack_mock].toString(); } //对栈进行清空 clear() { this[stack_mock] = []; } } //返回类函数Stack return Stack; })(); //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这时候外部类的实例,看样子好想完全拿不到内部的Symbol枚举属性,其实有两种方式可以完全拿到:getOwnPropertySymbols(仅可以拿到对象的Symbol枚举属性,包含继承)和Reflect.ownKeys(无论是Symbol枚举属性还是对象自身所拥有的属性都可以拿到,也包含继承),这时候去获取到Symbol枚举属性,并进行设置为空数组,依然可以在外部删除内部枚举属性数组的元素,类似于这样 //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //获取内部的Symbol枚举属性 //两种方式都可以 //let stack_mock = Object.getOwnPropertySymbols(stack)[0]; let stack_mock = Reflect.ownKeys(stack)[0]; //设置内部的Symbol枚举属性值为空数组 stack[stack_mock] = []; //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //&quot;&quot; console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //undefined console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //undefined console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 针对这种情况,尝试使用WeakMap集合来解决,WeakMap是Map的一种形式,它只能设置key为对象的属性,且在无法通过类实例的任何方法来获取并设置 let Stack = (function (){ //声明一个可公用的WeakMap的集合变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let stack_mock = new WeakMap(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 stack_mock.set(this, []); } //向栈内添加元素 push(element) { let stack_arr = stack_mock.get(this); let stack_index = stack_arr.push(element); stack_mock.set(this, stack_arr); return stack_index; } //栈顶删除元素 pop() { let stack_arr = stack_mock.get(this); let stack_item = stack_arr.pop(); stack_mock.set(this, stack_arr); return stack_item; } //校验栈是否为空 isEmpty() { let stack_arr = stack_mock.get(this); return stack_arr.length === 0; } //获取栈顶元素 peek() { let stack_arr = stack_mock.get(this), len = stack_arr.length; return stack_arr[len - 1]; } //获取栈内元素的个数 size() { let stack_arr = stack_mock.get(this); return stack_arr.length; } //对栈内所有元素进行打印 print() { let stack_arr = stack_mock.get(this); return stack_arr.toString(); } //对栈进行清空 clear() { stack_mock.set(this, []); } } //返回类函数Stack return Stack; })(); //声明一个栈Stack类的实例 let stack = new Stack(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //向栈中添加元素 stack.push(&quot;Gary&quot;); stack.push(&quot;Lily&quot;); stack.push(&quot;Frank&quot;); stack.push(&quot;Simon&quot;); //在这里打印添加元素之后的返回值 //这里打印栈内的元素个数: //5 console.log(stack.push(&quot;Aaron&quot;)); //在这里打印栈是否为空 //这里打印: //false console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //5 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Aaron&quot; console.log(stack.peek()); //在这里打印栈内所有的元素 //这里打印: //Gary,Lily,Frank,Simon,Aaron console.log(stack.print()); //在这里对栈内元素从栈顶进行删除 //这里打印: //Aaron console.log(stack.pop()); //在这里打印栈内元素的个数 //这里打印: //4 console.log(stack.size()); //在这里打印栈顶的元素 //这里打印: //&quot;Simon&quot; console.log(stack.peek()); //对栈进行清空 stack.clear(); //在这里打印栈是否为空 //这里打印: //true console.log(stack.isEmpty()); //在这里打印栈内元素的个数 //这里打印: //0 console.log(stack.size()); 这样就完美的写出了一个栈 Stack类函数,内部WeakMap集合属性设置类的数组,不可获取且修改,全局下也不可轻易的拿到且进行随意的修改,具有良好的封装性、安全性、扩展性以及可维护性 使用栈解决计算机科学中的经典算法问题十进制转化为二进制 首先你要知道十进制转化二进制的原理,先从二进制转化为十进制说起,二进制中只有0和1,在相加时就是足2进1,比如说10这个十进制整数,转化为二进制就是1010,二进制分离转化十进制:1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0相加就是10这个十进制整数,所以十进制转化为二进制,就需要对2取余,取余之后再除以2到达下一位数,依次将余数添加进栈中,再依次从栈顶取出并删除栈顶元素,十进制转化为二进制是遵从栈后进先出的特点的 let Stack = (function (){ //声明一个可公用的WeakMap的集合变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let stack_mock = new WeakMap(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 stack_mock.set(this, []); } //向栈内添加元素 push(element) { let stack_arr = stack_mock.get(this); let stack_index = stack_arr.push(element); stack_mock.set(this, stack_arr); return stack_index; } //栈顶删除元素 pop() { let stack_arr = stack_mock.get(this); let stack_item = stack_arr.pop(); stack_mock.set(this, stack_arr); return stack_item; } //校验栈是否为空 isEmpty() { let stack_arr = stack_mock.get(this); return stack_arr.length === 0; } //获取栈顶元素 peek() { let stack_arr = stack_mock.get(this), len = stack_arr.length; return stack_arr[len - 1]; } //获取栈内元素的个数 size() { let stack_arr = stack_mock.get(this); return stack_arr.length; } //对栈内所有元素进行打印 print() { let stack_arr = stack_mock.get(this); return stack_arr.toString(); } //对栈进行清空 clear() { stack_mock.set(this, []); } } //返回类函数Stack return Stack; })(); /**进行十进制转化为二进制的函数 * @params decimal 传进去的十进制参数 */ let DecimalConversionBinary = (decimal)=&gt; { //声明一个栈Stack类的实例 let stack = new Stack(), //声明一个承接%2之后的余数的变量 decimal_remainder, //声明一个承接最终二进制的字符串变量,初始化为空字符串 result_binary = &quot;&quot;, //声明一个承接十进制的变量 decimal_integer = decimal; //在十进制的变量除以2还不为0时,继续执行循环 while(decimal_integer / 2){ //将十进制的变量对2进行取余,余数赋值给承接余数的变量 decimal_remainder = decimal_integer % 2; //将余数添加进栈中 stack.push(decimal_remainder); //十进制的变量取余后,再除以2向下取整,到达下一位数,复制给十进制的变量 decimal_integer = Math.floor(decimal_integer / 2); } //检测栈是否为空,如果不为空,则继续执行循环 while(!stack.isEmpty()){ //承接二进制字符串的变量不断的拼接栈顶的元素,而栈顶元素也不断在被删除 result_binary += stack.pop(); } //待到栈顶元素彻底删除完毕,栈为空栈了,就返回最终的二进制变量 return result_binary; }; let binary = DecimalConversionBinary(10); //在这里打印: //1010 console.log(binary); 十进制转化为任何进制 十进制转化为任何进制的原理跟二进制是一样的,只不过除以的数值变了,所以需要外部传入,这样做的比较通用 let Stack = (function (){ //声明一个可公用的WeakMap的集合变量: stack_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let stack_mock = new WeakMap(); //声明一个类函数,这里当作栈Stack的类 class Stack { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 stack_mock.set(this, []); } //向栈内添加元素 push(element) { let stack_arr = stack_mock.get(this); let stack_index = stack_arr.push(element); stack_mock.set(this, stack_arr); return stack_index; } //栈顶删除元素 pop() { let stack_arr = stack_mock.get(this); let stack_item = stack_arr.pop(); stack_mock.set(this, stack_arr); return stack_item; } //校验栈是否为空 isEmpty() { let stack_arr = stack_mock.get(this); return stack_arr.length === 0; } //获取栈顶元素 peek() { let stack_arr = stack_mock.get(this), len = stack_arr.length; return stack_arr[len - 1]; } //获取栈内元素的个数 size() { let stack_arr = stack_mock.get(this); return stack_arr.length; } //对栈内所有元素进行打印 print() { let stack_arr = stack_mock.get(this); return stack_arr.toString(); } //对栈进行清空 clear() { stack_mock.set(this, []); } } //返回类函数Stack return Stack; })(); /**进行十进制转化为任何进制的函数 * @params decimal 传进去的十进制参数 * @params radix 表示十进制要转化的进制类型 */ let DecimalConversionRadix = (decimal, radix)=&gt; { //声明一个栈Stack类的实例 let stack = new Stack(), //声明一个承接%radix之后的余数的变量 decimal_remainder, //声明一个承接最终外部传入进制的字符串变量,初始化为空字符串 result_radix = &quot;&quot;, //声明一个承接十进制的变量 decimal_integer = decimal, //各个进制栈中的进制位数所对应的字符文本,最多十六进制,最少二进制 radix_formatter = &quot;0123456789ABCDEF&quot;; //在十进制的变量除以radix还不为0时,继续执行循环 while(decimal_integer / radix){ //将十进制的变量对radix进行取余,余数赋值给承接余数的变量 decimal_remainder = decimal_integer % radix; //将余数添加进栈中 stack.push(decimal_remainder); //十进制的变量取余后,再除以radix向下取整,到达下一位数,复制给十进制的变量 decimal_integer = Math.floor(decimal_integer / radix); } //检测栈是否为空,如果不为空,则继续执行循环 while(!stack.isEmpty()){ //承接外部传入进制字符串的变量不断的拼接栈顶的元素所对应的字符文本,而栈顶元素也不断在被删除 result_radix += radix_formatter[stack.pop()]; } //待到栈顶元素彻底删除完毕,栈为空栈了,就返回最终的外部传入进制变量 return result_radix; }; //这里传入的进制类型是二进制 let radix = DecimalConversionRadix(10, 2); //在这里打印: //1010 console.log(radix); //这里传入的进制类型是十六进制 let radix_ano = DecimalConversionRadix(100, 16); //在这里打印: //64 console.log(radix_ano); 队列 Queue 队列也是数据结构中比较简单的顺序数据结构,和栈相似,特点是: 先进先出,新的元素都会添加到队列的末尾,等待队列中之前已经添加的元素删除掉,现实生活中也有好多队列的例子,排队就是很常见的例子,在医院排队挂号、在食堂排队打饭、在抢票软件中排队抢票等等一系列都是队列的表现,经过栈Stack一系列的对类函数Stack的优化改进,在和栈Stack相似的队列Queue这里就不再赘述,我们直接写最终的优化改进的ES6版本 let Queue = (function() { //声明一个可公用的WeakMap的集合变量: queue_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let queue_mock = new WeakMap(); //声明一个类函数,这里当作队列Queue的类 class Queue { constructor(){ //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 queue_mock.set(this, []); } //向队列末尾中添加新的元素 enqueue(element) { let queue_arr = queue_mock.get(this); let queue_index = queue_arr.push(element); queue_mock.set(this, queue_arr); return queue_index; } //将队列列头的元素删除掉 dequeue() { let queue_arr = queue_mock.get(this); let queue_item = queue_arr.shift(); queue_mock.set(this, queue_arr); return queue_item; } //检测队列是否为空 isEmpty() { return queue_mock.get(this).length === 0; } //获取队列中元素的个数 size() { return queue_mock.get(this).length; } //将队列清空 clear() { queue_mock.set(this, []); } //将队列中所有的元素进行打印 print() { return queue_mock.get(this).toString(); } //获取队列列头的元素 front() { return queue_mock.get(this)[0]; } } })(); //声明一个队列Queue类实例 let queue = new Queue(); //这里判断队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //向队列中添加元素 queue.enqueue(&quot;Gary&quot;); queue.enqueue(&quot;Lily&quot;); queue.enqueue(&quot;Simon&quot;); queue.enqueue(&quot;Aaron&quot;); //这里打印队列添加元素的返回值 //在这里打印队列中元素的个数: //5 console.log(queue.enqueue(&quot;Frank&quot;)); //这里判断队列是否为空 //在这里打印: //false console.log(queue.isEmpty()); //这里打印队列中元素的个数 //在这里打印: //5 console.log(queue.size()); //这里打印队列中列头的元素 //在这里打印: //&quot;Gary&quot; console.log(queue.front()); //这里打印队列中所有的元素 //在这里打印: //Gary,Lily,Simon,Aaron,Frank console.log(queue.print()); //这里将队列列头的元素删除 //在这里打印列头的元素: //&quot;Gary&quot; console.log(queue.dequeue()); queue.dequeue(); queue.dequeue(); //这里打印队列中元素的个数 //在这里打印: //2 console.log(queue.size()); //这里打印队列中列头的元素 //在这里打印: //&quot;Aaron&quot; console.log(queue.front()); //将队列清空 queue.clear(); //这里判断队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //这里打印队列中元素的个数 //在这里打印: //0 console.log(queue.size()); 优先队列 队列有时需要根据某些参数进行优先级处理,比如我们乘坐飞机,购买飞机票,分为头等舱、商务舱和经济舱,头等舱的优先级最高,经济舱的优先级最低,所以在进行队列处理时,需要根据优先级进行排列 let Queue = (function () { //声明一个可公用的WeakMap的集合变量: queue_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let queue_mock = new WeakMap(); //声明一个队列优先级类函数 //生成队列元素优先级实例 class Queue_Prior { constructor(element, prior) { this.element = element; this.prior = prior; } } //声明一个类函数,这里当作队列Queue的类 class Queue { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 queue_mock.set(this, []); } //根据优先级向队列中添加优先级实例元素 enqueue(element, prior) { //生成队列优先级实例元素 let queue_prior = new Queue_Prior(element, prior), //获取现状态的队列 queue_arr = queue_mock.get(this), len = queue_arr.length, index = 0; //循环现状态的队列,假如队列中存在元素优先级比实例优先级小的,就插入到小优先级队列元素之前 while(index &lt; len) { if(queue_arr[index][&quot;prior&quot;] &gt; queue_prior[&quot;prior&quot;]) { queue_arr.splice(index, 0, queue_prior); queue_mock.set(this, queue_arr); return index + 1; } index++; } //假如不存在,就直接添加到队列列尾 index = queue_arr.push(queue_prior); queue_mock.set(this, queue_arr); return index; } //对队列列头的元素进行删除 dequeue() { let queue_arr = queue_mock.get(this); let queue_index = queue_arr.shift(); queue_mock.set(this, queue_arr); return queue_index; } //判断队列是否为空 isEmpty() { return queue_mock.get(this).length === 0; } //获取队列中的元素个数 size() { return queue_mock.get(this).length; } //对队列进行清空 clear() { queue_mock.set(this, []); } //获取队列列头的元素 front() { return queue_mock.get(this)[0]; } //对队列中的所有的元素进行打印 print() { let queue_arr = queue_mock.get(this); let len = queue_arr.length; let queue_toString_arr = []; for(let i = 0; i &lt; len; i++) { queue_toString_arr.push(queue_arr[i][&quot;element&quot;]); } return queue_toString_arr.toString(); } } //返回队列Queue队列 return Queue; })(); //声明一个优先队列Queue类实例 let queue = new Queue(); //这里判断优先队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //向优先队列中添加元素 queue.enqueue(&quot;Gary&quot;, 1); queue.enqueue(&quot;Lily&quot;, 2); queue.enqueue(&quot;Simon&quot;, 1); queue.enqueue(&quot;Aaron&quot;, 3); //这里打印优先队列添加元素的返回值 //在这里打印优先队列添加元素的位置: //4 console.log(queue.enqueue(&quot;Frank&quot;, 2)); //这里判断优先队列是否为空 //在这里打印: //false console.log(queue.isEmpty()); //这里打印优先队列中元素的个数 //在这里打印: //5 console.log(queue.size()); //这里打印优先队列中列头的元素 //在这里打印: //{element: &quot;Gary&quot;, prior: 1} console.log(queue.front()); //这里打印优先队列中所有的元素 //在这里打印: //Gary,Simon,Lily,Frank,Aaron console.log(queue.print()); //这里将优先队列列头的元素删除 //在这里打印列头的元素: //{element: &quot;Gary&quot;, prior: 1} console.log(queue.dequeue()); queue.dequeue(); queue.dequeue(); //这里打印优先队列中元素的个数 //在这里打印: //2 console.log(queue.size()); //这里打印优先队列中列头的元素 //在这里打印: //{element: &quot;Frank&quot;, prior: 2} console.log(queue.front()); //将优先队列清空 queue.clear(); //这里判断优先队列是否为空 //在这里打印: //true console.log(queue.isEmpty()); //这里打印优先队列中元素的个数 //在这里打印: //0 console.log(queue.size()); 循环队列使用循环队列解决计算机经典算法 - 击鼓传花 用队列来实现击鼓传花,再合适不过了,给定一个数组以及传递的次数作为函数的参数 let Queue = (function () { //声明一个可公用的WeakMap的集合变量: queue_mock //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了 let queue_mock = new WeakMap(); //声明一个类函数,这里当作队列Queue的类 class Queue { constructor() { //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组 queue_mock.set(this, []); } //向队列末尾中添加新的元素 enqueue(element) { let queue_arr = queue_mock.get(this); let queue_index = queue_arr.push(element); queue_mock.set(this, queue_arr); return queue_index; } //将队列列头的元素删除掉 dequeue() { let queue_arr = queue_mock.get(this); let queue_item = queue_arr.shift(); queue_mock.set(this, queue_arr); return queue_item; } //检测队列是否为空 isEmpty() { return queue_mock.get(this).length === 0; } //获取队列中的元素个数 size() { return queue_mock.get(this).length; } //对队列进行清空 clear() { queue_mock.set(this, []); } //对队列中的所有的元素进行打印 print() { return queue_mock.get(this).toString(); } //对队列中的所有的元素进行打印 front() { return queue_mock.get(this)[0]; } } return Queue; })(); //击鼓传花函数 //@params queueList 数组 //@params count 传递的次数 function passThePaperFlower(queueList, count) { //声明一个循环队列Queue类的实例 let queue = new Queue(); //遍历数组,将数组元素添加到队列中 for(let i = 0; i &lt; queueList.length; i++) { queue.enqueue(queueList[i]); } //只要队列中的元素大于1,就继续循环 while(queue.size() &gt; 1) { //遍历传递的次数,将队列列头的元素(就是击鼓传花中要淘汰的人)删除掉,再添加到队列的列尾 for(let j = 0; j &lt; count; j++) { queue.enqueue(queue.dequeue()); } //获取到传递完之后,队列列头的元素 let queueItem = queue.dequeue(); console.log(`${queueItem}被淘汰~`); } //返回队列中仅剩的最后的击鼓传花大赢家 return queue.front(); } //给定的进行击鼓传花的人 let paperFlowerParticipant = [&quot;Gary&quot;, &quot;Lily&quot;, &quot;Aaron&quot;, &quot;Alice&quot;, &quot;Simon&quot;, &quot;Frank&quot;]; //队列中仅剩的最后的击鼓传花大赢家 let finallyGet = passThePaperFlower(paperFlowerParticipant, 10); //对最后的击鼓传花大赢家进行打印 console.log(&quot;最后的赢家是:&quot; + finallyGet); 链表 LinkList 前面说了栈和队列简单的顺序数据结构,下面介绍一下最后的顺序数据结构: 链表 LinkList,链表相比于栈和队列的优点在于: 栈和队列会直接对内部元素进行添加、修改以及删除的操作,使得其他内存元素的位置发生改变(其他元素前移或者后移),大量的消耗内存,而链表不会破坏内存元素的位置,假如进行添加、修改以及删除的操作,直接断开中间的一个环节,将这个环节的前一个环节以及后一个环节重连就可以了,生活中也有很多链表的例子: 比如说火车,火车的车厢都是一环连着一环的,和链表差不多 let LinkList = (function() { //定义链表头部的链表元素,并在初始化时设置为null //定义链表的长度,并在初始化时设置为0 let head = new WeakMap(), length = new WeakMap(); //声明链表元素Node对象的类函数 //初始化有两个参数 //@param node 现链表元素的值 //@param next 用来链接下一个链表元素 class Node { constructor(node) { this.node = node; this.next = null; } } //声明链表LinkList对象的类函数 class LinkList { constructor() { head.set(this, null); length.set(this, 0); } //向链表中添加链表元素 insert(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, node = new Node(element); if(!headElement) { headElement = node; } else { while(current.next) { current = current.next; } current.next = node; } lengths++; head.set(this, headElement); length.set(this, lengths); return lengths; } //向链表的指定位置添加链表元素 insertAt(element, position) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, previous, node = new Node(element); if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!headElement) { headElement = node; } else { if(position === 0) { node.next = current; headElement = node; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.next = current; } } lengths++; head.set(this, headElement); length.set(this, lengths); return position; } return false; } //删除链表中的指定链表元素 remove(element) { const {indexOf, removeAt} = this; let index = indexOf.bind(this)(element); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : index; } //获取指定链表元素的位置 indexOf(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(element === current.node) { return index - 1; } current = current.next; } return false; } //删除链表中指定位置的链表元素 removeAt(position) { let headElement = head.get(this), lengths = length.get(this), index = 0, previous, current = headElement; if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!head) { return false; } else { if(lengths === 1) { headElement = null; } else { if(position === 0) { headElement = current.next; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; } } } lengths--; head.set(this, headElement); length.set(this, lengths); return position; } return false; } //获取链表中所有的链表结构 toString() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result = ``; while(index++ &lt; lengths) { result = `${result}${current.node}|~`; current = current.next; } return result; } //获取链表的头部链表元素 headElement() { return head.get(this).node; } //获取链表的长度 size() { return length.get(this); } //判断链表是否为空 isEmpty() { return length.get(this) === 0; } //获取链表的真实结构 valueOf() { return head.get(this); } //将链表清空 clear() { head.set(this, null); length.set(this, 0); } } //返回链表LinkList类函数 return LinkList; })(); //声明链表类函数的实例 let link_list = new LinkList(); //这里判断链表是否是空链表 //在这里打印: //true console.log(link_list.isEmpty()); //这里获取链表的长度 //在这里打印: //0 console.log(link_list.size()); //这里打印链表元素的数量: //在这里打印: //1 console.log(link_list.insert(104)); link_list.insert(99); link_list.insert(155); link_list.insert(34); link_list.insert(16); //这里判断链表是否是空链表 //在这里打印: //false console.log(link_list.isEmpty()); //这里获取链表的长度 //在这里打印: //5 console.log(link_list.size()); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //155 //34 //16 console.log(link_list.toString()); //这里获取链表的头部链表元素 //在这里打印: //104 console.log(link_list.headElement()); //这里在链表下标为2处插入链表元素 //在这里打印: //2 console.log(link_list.insertAt(88, 2)); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //88 //155 //34 //16 console.log(link_list.toString()); //这里打印链表中所有的链表结构 //在这里打印: //{element: 104, next: {element: 99, next: {element: 88, next: {element: 155, next: {element: 34, next: {element: 16, next: null}}}}}} console.log(link_list.valueOf()); //这里删除链表下标为3处的链表元素 //在这里打印: //3 console.log(link_list.removeAt(3)); link_list.removeAt(4); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //88 //34 console.log(link_list.toString()); //这里删除链表中链表元素为88的链表元素 //在这里打印: //2 console.log(link_list.remove(88)); //这里打印链表中所有的链表元素 //在这里打印: //104 //99 //34 link_list.toString(); //这里打印链表中的头部链表元素 //在这里打印: //104 console.log(link_list.headElement()); link_list.clear(); //这里判断链表是否是空链表 //在这里打印: //true console.log(link_list.isEmpty()); //这里获取链表的长度 //在这里打印: //0 console.log(link_list.size()); 双向链表 DoublyLinkList 双向链表和单向链表的模式,唯一的区别: 双向链表多出了一个尾部链表元素,且链表元素类实例不仅仅有next属性,还有prev属性,next指向下一个链表元素,prev指向上一个链表元素 let DoublyLinkList = (function() { //定义链表头部的链表元素,并在初始化时设置为null //定义链表尾部的链表元素,并在初始化时设置为null //定义链表的长度,并在初始化时设置为0 let head = new WeakMap(), tail = new WeakMap(), length = new WeakMap(); //声明链表元素Node对象的类函数 //初始化有三个参数 //@param node 现链表元素的值 //@param next 用来链接下一个链表元素 //@param prev 用来链接上一个链表元素 class Node { constructor(node) { this.node = node; this.next = null; this.prev = null; } } //声明双向链表DoublyLinkList对象的类函数 class DoublyLinkList { constructor() { head.set(this, null); tail.set(this, null); length.set(this, 0); } //向链表中添加链表元素 insert(element) { let headElement = head.get(this), tailElement = tail.get(this), lengths = length.get(this), current = headElement, node = new Node(element); if(!headElement) { headElement = node; tailElement = node; } else { while(current.next) { current = current.next; } current.next = node; node.prev = current; tailElement = node; } lengths++; head.set(this, headElement); tail.set(this, tailElement); length.set(this, lengths); return lengths; } //向链表的指定位置添加链表元素 insertAt(element, position) { let headElement = head.get(this), tailElement = tail.get(this), current = headElement, lengths = length.get(this), node = new Node(element), previous, index = 0; if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!headElement) { headElement = node; tailElement = node; } else { if(position === 0) { node.next = current; current.prev = node; headElement = node; } else if(position === lengths - 1) { node.prev = tailElement; tailElement.next = node; tailElement = node; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.prev = previous; node.next = current; current.prev = node; } } lengths++; head.set(this, headElement); tail.set(this, tailElement); length.set(this, lengths); return position; } return false; } //删除链表中指定位置的链表元素 removeAt(position) { let headElement = head.get(this), tailElement = tail.get(this), lengths = length.get(this), current = headElement, index = 0, previous; if(position &gt;=0 &amp;&amp; position &lt; lengths) { if(!headElement) { return false; } else { if(lengths === 1) { headElement = null; tailElement = null; } else { if(position === 0) { headElement = current.next; headElement.prev = null; } else if (position === lengths - 1) { tailElement = tailElement.prev; tailElement.next = null; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; current.next.prev = previous; } } lengths--; head.set(this, headElement); tail.set(this, tailElement); length.set(this, lengths); return position; } } return false; } //获取链表指定的元素位置 indexOf(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(current.node === element) { return index - 1; } current = current.next; } return false; } //删除链表中的指定链表元素 remove(element) { const {indexOf, removeAt} = this; let index = indexOf.bind(this)(element); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : false; } //获取链表的长度 size() { return length.get(this); } //判断链表是否为空数组 isEmpty() { return length.get(this) === 0; } //打印链表中所有的链表元素 toString() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result = ``; while(index++ &lt; lengths) { result = `${result}${current.node}~|~`; current = current.next; } return result; } //获取链表中所有的链表结构 valueOf() { return head.get(this); } //将链表清空 clear() { head.set(this, null); tail.set(this, null); length.set(this, 0); } //获取链表的头部链表元素 headElement() { return head.get(this).node; } //获取链表的尾部链表元素 tailElement() { return tail.get(this).node; } } //返回双向链表DoublyLinkList类函数 return DoublyLinkList; })(); let doubly_link = new DoublyLinkList(); //这里打印链表是否为空链表 //在这里打印: //true console.log(doubly_link.isEmpty()); //这里打印链表的长度 //在这里打印: //0 console.log(doubly_link.size()); //这里打印插入新的链表元素后链表的长度 //在这里打印: //1 console.log(doubly_link.insert(111)); doubly_link.insert(88); doubly_link.insert(99); doubly_link.insert(77); doubly_link.insert(222); //这里打印链表是否为空链表 //在这里打印: //false console.log(doubly_link.isEmpty()); //这里打印链表的长度 //在这里打印: //5 console.log(doubly_link.size()); //这里打印链表的头部链表元素 //在这里打印: //111 console.log(doubly_link.headElement()); //这里打印链表的尾部链表元素 //在这里打印: //222 console.log(doubly_link.tailElement()); //这里打印链表的所有链表元素 //在这里打印: //111~|88~|99~|77~|222~| console.log(doubly_link.toString()); //这里打印链表的所有链表结构 //在这里打印: //{prev: null, element: 111, next: {prev: {//上一个链表元素 ...}, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 77, next: {//上一个链表元素 ...}, element: 222, next: null}}}}} console.log(doubly_link.valueOf()); //这里打印插入到3号位置的新的链表元素的下标位置 //在这里打印: //3 console.log(doubly_link.insertAt(66, 3)); //这里打印链表的所有链表元素 //在这里打印: //111~|88~|99~|66~|77~|222~| console.log(doubly_link.toString()); //这里打印链表的所有链表结构 //在这里打印: //{prev: null, element: 111, next: {prev: {//上一个链表元素 ...}, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 66, next: {prev: {//上一个链表元素 ...}, element: 77, next: {//上一个链表元素 ...}, element: 222, next: null}}}}}} console.log(doubly_link.valueOf()); //这里打印删除4号位置的链表元素的下标位置 //在这里打印: //4 console.log(doubly_link.removeAt(4)); doubly_link.removeAt(0); //这里打印删除指定的链表元素的下标位置 //在这里打印: //2 doubly_link.remove(66); //这里打印链表的所有链表元素 //在这里打印: //88~|99~|222~| console.log(doubly_link.toString()); //这里打印链表的所有链表结构 //在这里打印: //{prev: null, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 222, next: null}}} console.log(doubly_link.valueOf()); //这里打印链表的头部链表元素 //在这里打印: //88 console.log(doubly_link.headElement()); //这里打印链表的尾部链表元素 //在这里打印: //222 console.log(doubly_link.tailElement()); doubly_link.clear(); //这里打印链表是否为空链表 //在这里打印: //true console.log(doubly_link.isEmpty()); //这里打印链表的长度 //在这里打印: //0 console.log(doubly_link.size()); 集合自己封装Set集合 接下来学习下一种非顺序线性数据结构,那就是集合。在实义上指的是具有某种特定性质的事物的总体,俗话讲的好,”物以类聚,人以群分”,这是对集合相当恰当的写照,在ES6中,新语法对象Set也是用来实现集合的,下面我们也来封装一下Set集合,并封装一些ES6 Set语法中不存在的方法,比如:交集、并集、差集和子集 let Set = (function () { //设置集合的容器,并在初始化时设置为空对象{} let set = new WeakMap(); //设置集合类 class Set { constructor() { set.set(this, {}); } //在集合中添加集合项 add(value) { let set_add = set.get(this); set_add[value] = value; set.set(this, set_add); return true; } //判断集合中是否存在此集合项 has(value) { let set_has = set.get(this); return set_has.hasOwnProperty(value); } //删除集合中的指定集合项 delete(value) { let set_delete = set.get(this); if(set_delete.hasOwnProperty(value)) { delete set_delete[value]; set.set(this, set_delete); return true; } return false; } //获取集合的长度 size() { let set_size = set.get(this), index = 0; for(let [key, value] of Object.entries(set_size)) { index++; } return index; } //判断集合是否为空 isEmpty() { let set_isEmpty = set.get(this); for(let [key, value] of Object.entries(set_isEmpty)) { if(set_isEmpty.hasOwnProperty(key)) { return false; } } return true; } //获取集合的属性值数组 values() { let set_values = set.get(this); return Object.values(set_values); } //清空集合 clear() { set.set(this, {}); return true; } //并集 union(union_ano) { let union_this = this, union_new = new Set(); for(let [key_this, value_this] of union_this.values().entries()) { union_new.add(value_this); } for(let [key_ano, value_ano] of union_ano.values().entries()) { union_new.add(value_ano); } return union_new.values(); } //交集 intersection(intersection_ano) { let intersection_this = this, intersection_new = new Set(); for(let [key_this, value_this] of intersection_this.values().entries()) { if(intersection_ano.has(value_this)) { intersection_new.add(value_this); } } return intersection_new.values(); } //差集 differenceSet(differenceSet_ano) { let differenceSet_this = this, differenceSet_new = new Set(); for(let [key, value] of differenceSet_this.values().entries()) { if(!differenceSet_ano.has(value)) { differenceSet_new.add(value); } } return differenceSet_new.values(); } //子集 subset(subset_ano) { let subset_this = this; for(let [key, value] of subset_this.values().entries()) { if(!subset_ano.has(value)) { return false; } } return true; } } //返回集合类 return Set; })(); let set = new Set(); //这里判断集合是否为空 //在这里打印: //true console.log(set.isEmpty()); //这里查看集合的长度 //在这里打印: //0 console.log(set.size()); //这里在集合中添加集合项,并返回true //在这里打印: //true console.log(set.add(&quot;Gary&quot;)); set.add(&quot;Simon&quot;); set.add(&quot;Frank&quot;); set.add(&quot;Lily&quot;); set.add(&quot;Alice&quot;); set.add(&quot;Tom&quot;); set.add(&quot;Tommy&quot;); //这里判断集合是否为空 //在这里打印: //false console.log(set.isEmpty()); //这里查看集合的长度 //在这里打印: //7 console.log(set.size()); //这里判断集合中是否存在此集合项&quot;Gary&quot; //在这里打印: //true console.log(set.has(&quot;Gary&quot;)); //这里判断集合中是否存在此集合项&quot;Alice&quot; //在这里打印: //true console.log(set.has(&quot;Alice&quot;)); //这里判断集合中是否存在此集合项&quot;Clay&quot; //在这里打印: //false console.log(set.has(&quot;Clay&quot;)); //这里获取集合的属性值数组 //在这里打印: //[&quot;Gary&quot;, &quot;Simon&quot;, &quot;Frank&quot;, &quot;Lily&quot;, &quot;Alice&quot;, &quot;Tom&quot;, &quot;Tommy&quot;] console.log(set.values()); //这里删除集合中的指定集合项 //在这里打印: //true console.log(set.delete(&quot;Simon&quot;)); set.delete(&quot;Alice&quot;); //这里查看集合的长度 //在这里打印: //5 console.log(set.size()); //这里获取集合的属性值数组 //在这里打印: //[&quot;Gary&quot;, &quot;Frank&quot;, &quot;Lily&quot;, &quot;Tom&quot;, &quot;Tommy&quot;] console.log(set.values()); set.clear(); //这里判断集合是否为空 //在这里打印: //true console.log(set.isEmpty()); //这里打印集合的长度 //在这里打印: //0 console.log(set.size()); let _set = new Set(); let _set_ano = new Set(); _set.add(45); _set.add(66); _set.add(100); _set.add(52); _set.add(28); _set.add(89); _set_ano.add(28); _set_ano.add(52); _set_ano.add(111); _set_ano.add(120); _set_ano.add(18); //这里查询两个集合属于_set集合或者属于_set_ano集合的并集 //在这里打印: //[45, 66, 100, 52, 28, 89, 111, 120, 18] console.log(_set.union(_set_ano)); //这里查询两个集合既属于_set集合又属于_set_ano集合的交集 //在这里打印: //[28, 52] console.log(_set.intersection(_set_ano)); //这里查询两个集合属于_set集合但不属于_set_ano集合的差集 //在这里打印: //[45, 66, 100, 89] console.log(_set.differenceSet(_set_ano)); //这里查询_set集合是否是_set_ano的子集 //在这里打印: //false console.log(_set.subset(_set_ano)); ES6 Set集合 之前说过ES6中使用Set来表现集合,ES6的Set也有add、has、delete和clear等方法,当然size是以属性来存储集合的长度,而也拥有keys、values和entries等遍历的方式来返回属性数组、属性值数组以及[属性, 属性值]数组,但是Set并没有封装union(并集)、intersection(交集)、differenceSet(差集)和subset(子集)等方法,我们可以利用它现有的属性和方法来封装一下 //封装ES6 Set集合union并集方法 Set.prototype.union = function(set_ano) { let set_this = this, set_new = new Set(), set_union = []; for(let [key, value] of set_this.entries()) { set_new.add(key); } for(let [key, value] of set_ano.entries()) { set_new.add(key); } for(let [key, value] of set_new.entries()) { set_union = [...set_union, key]; } return set_union; }; //封装ES6 Set集合intersection交集方法 Set.prototype.intersection = function(set_ano) { let set_this = this, set_new = new Set(), set_intersection = []; for(let [key, value] of set_this.entries()) { if(set_ano.has(key)) { set_new.add(key); } } for(let [key, value] of set_new.entries()) { set_intersection = [...set_intersection, key]; } return set_intersection; }; //封装ES6 Set集合differenceSet差集方法 Set.prototype.differenceSet = function(set_ano) { let set_this = this, set_new = new Set(), set_differenceSet = []; for(let [key, value] of set_this.entries()) { if(!set_ano.has(key)) { set_new.add(key); } } for(let [key, value] of set_new.entries()) { set_differenceSet = [...set_differenceSet, key]; } return set_differenceSet; }; //封装ES6 Set集合subset子集方法 Set.prototype.subset = function(set_ano) { let set_this = this; for(let [key, value] of set_this.entries()) { if(!set_ano.has(key)) { return false; } } return true; }; let set = new Set(), set_ano = new Set(); set.add(45); set.add(66); set.add(100); set.add(52); set.add(28); set.add(89); set_ano.add(28); set_ano.add(52); set_ano.add(111); set_ano.add(120); set_ano.add(18); //这里查询属于set集合或者属于set_ano集合的并集 //在这里打印: //[45, 66, 100, 52, 28, 89, 111, 120, 18] console.log(set.union(set_ano)); //这里查询既属于set集合又属于set_ano集合的交集 //在这里打印: //[52, 28] console.log(set.intersection(set_ano)); //这里查询属于set集合但不属于set_ano集合的差集 //在这里打印: //[45, 66, 100, 89] console.log(set.differenceSet(set_ano)); //这里查询set集合是否是set_ano集合的子集 //在这里打印: //false console.log(set.subset(set_ano)); 字典 除了集合这种线性的非顺序结构以外,还有两种线性的非顺序结构: 字典和散列表,如果说集合是具有某种特征性质事物的总量的话,那字典就是具有某种特征性质事物的分集(分类集合),ES6中用Map来表现字典,下面我们就来介绍一下字典 let Map = (function () { //设置字典的容器,并在初始化时设置为空对象{} let map = new WeakMap(); //定义Map字典类 class Map { constructor() { map.set(this, {}); } //在字典中添加字典项 set(key, value) { let map_set = map.get(this); map_set[key] = value; map.set(this, map_set); return true; } //获取字典指定的字典项 get(key) { let map_get = map.get(this); if(map_get.hasOwnProperty(key)) { return map_get[key]; } return false; } //判断字典是否存在指定的字典项 has(key) { let map_has = map.get(this); return map_has.hasOwnProperty(key); } //删除字典指定的字典项 delete(key) { let map_delete = map.get(this); if(map_delete.hasOwnProperty(key)){ delete map_delete[key]; map.set(this, map_delete); return true; } return false; } //清空字典 clear() { map.set(this, {}); return true; } //获取字典的属性数组 keys() { let map_keys = map.get(this); return Object.keys(map_keys); } //获取字典的属性值数组 values() { let map_values = map.get(this); return Object.values(map_values); } //获取字典的长度 size() { let map_size = map.get(this); return Object.keys(map_size).length; } //判断字典是否为空 isEmpty() { let map_isEmpty = map.get(this); return Object.keys(map_isEmpty).length === 0; } } //返回Map字典类 return Map; })(); let map = new Map(); //这里判断字典是否为空 //在这里打印: //true console.log(map.isEmpty()); //这里获取字典的长度 //在这里打印: //0 console.log(map.size()); //这里在字典中添加制定的字典项 //在这里打印: //true console.log(map.set(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); map.set(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); map.set(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); map.set(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); map.set(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); //这里判断字典是否为空 //在这里打印: //false console.log(map.isEmpty()); //这里获取字典的长度 //在这里打印: //5 console.log(map.size()); //这里获取字典指定的字典项 //在这里打印: //gary@gmail.com console.log(map.get(&quot;Gary&quot;)); //这里获取字典指定的字典项 //在这里打印: //lily@gmail.com console.log(map.get(&quot;Alice&quot;)); //这里判断是否存在指定的字典项 //在这里打印: //true console.log(map.has(&quot;Lily&quot;)); //这里获取字典的属性数组 //在这里打印: //[&quot;Gary&quot;, &quot;Simon&quot;, &quot;Lily&quot;, &quot;Alice&quot;, &quot;Aaron&quot;] console.log(map.keys()); //这里获取字典的属性值数组 //在这里打印: //[&quot;gary@gmail.com&quot;, &quot;simon@gmail.com&quot;, &quot;lily@gmail.com&quot;, &quot;alice@gmail.com&quot;, &quot;aaron@gmail.com&quot;] console.log(map.values()); //这里删除字典的执行字典项 //在这里打印: //true console.log(map.delete(&quot;Alice&quot;)); //这里判断是否存在指定的字典项 //在这里打印: //false console.log(map.has(&quot;Alice&quot;)); //这里清空字典 //在这里打印: //true console.log(map.clear()); //这里获取字典指定的字典项 //在这里打印: //false console.log(map.get(&quot;Gary&quot;)); //这里判断字典是否为空 //在这里打印: //true console.log(map.isEmpty()); //这里获取字典的长度 //在这里打印: //0 console.log(map.size()); 散列表 另外一种线性非顺序数据结构就是散列表了,也就是我们在Java中常用的HashTable,当然单纯的用HashTable会出现很多问题,最显著的一点就是容易一个值被另外一个值所覆盖,下面我们来介绍一下HashTable散列表 let HashTable = (function () { //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //定义散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为loseLose算法 //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数 //然后对任何一个质数取余 //最后进行返回 loseLoseHashTable(key) { let hash_key = 13, result_index = 0; for(let i = 0; i &lt; key.length; i++) { result_index += i * hash_key + key.charCodeAt(i); } return result_index % 37; } //在散列表中添加散列表项 put(key, value) { let hashTable = hash_table.get(this); const {loseLoseHashTable} = this; let index = loseLoseHashTable.bind(this)(key); hashTable[index] = value; hash_table.set(this, hashTable); return true; } //获取散列表指定的散列表项 get(key) { let hashTable = hash_table.get(this); const {loseLoseHashTable} = this; let index = loseLoseHashTable.bind(this)(key); if(hashTable[index] !== undefined) { return hashTable[index]; } return false; } //删除散列表中指定的散列表项 remove(key) { let hashTable = hash_table.get(this); const {loseLoseHashTable} = this; let index = loseLoseHashTable.bind(this)(key); if(hashTable[index] !== undefined) { hashTable[index] = undefined; hash_table.set(this, hashTable); return true; } return false; } //获取散列表拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}${value} -&gt; `; } } return result_str; } //获取散列表的具体结构 valueOf() { let hashTable = hash_table.get(this); return hashTable; } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里获取散列表指定的散列表项 //在这里打印: //tommy@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里获取散列表指定的散列表项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //martin@gmail.com -&gt; lily@gmail.com -&gt; tom@gmail.com -&gt; alice@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; helen@gmail.com -&gt; tommy@gmail.com -&gt; frank@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[&quot;martin@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 2, &quot;tom@gmail.com&quot;, empty × 5, &quot;alice@gmail.com&quot;, empty × 2, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 8, &quot;helen@gmail.com&quot;, empty × 4, &quot;tommy@gmail.com&quot;, &quot;frank@gmail.com&quot;] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); //这里获取散列表中指定的散列表项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //martin@gmail.com -&gt; lily@gmail.com -&gt; alice@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; helen@gmail.com -&gt; frank@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[&quot;martin@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 2, undefined, empty × 5, &quot;alice@gmail.com&quot;, empty × 2, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 8, &quot;helen@gmail.com&quot;, empty × 4, undefined, &quot;frank@gmail.com&quot;] console.log(hash_table.valueOf()); 不知道你们注意到了没,有一些散列表项被覆盖了,比如说key属性为Aaron的散列表项的value属性值竟然是tommy@gmail.com,再比如说我将key属性为Aaron的散列表项删除掉,key属性为Tommy的散列表项也消失了,变为了undefined,说明key属性为Tommy和key属性为Aaron的散列表项经过loseLose算法解析散列表项后是同一个散列表项,所以散列表项被覆盖了,所以用单纯的用HashTable是不适当的,要解决这个比较显著的问题,有两种解决方式:链表查询以及散列表巡航迭代 链表查询 链表查询就是用链表来作为散列表项,假如已经存在loseLose算法解析散列表项后的散列表项,就添加到此位置链表的最后,这样的话就不会发生覆盖的事情了,下面我们就用链表查询来解决散列表项覆盖的问题吧 let LinkList = (function () { //定义链表头部的链表元素,并在初始化时设置为null //定义链表的长度,并在初始化时设置为0 let head = new WeakMap(), length = new WeakMap(); //声明链表元素Node对象的类函数 //初始化有两个参数 //@param node 现链表元素的值 //@param next 用来链接下一个链表元素 class Node { constructor(node) { this.node = node; this.next = null; } } //定义链表类 class LinkList { constructor() { head.set(this, null); length.set(this, 0); } //向链表中添加链表元素 insert(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, node = new Node(element); if(!headElement) { headElement = node; } else { while(current.next) { current = current.next; } current.next = node; } lengths++; head.set(this, headElement); length.set(this, lengths); return lengths; } //向链表的指定位置添加链表元素 insertAt(element, position) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, previous, node = new Node(element); if(position &gt;= 0 &amp;&amp; position &lt; lengths) { if(!headElement) { headElement = node; } else { if(position === 0) { node.next = current; headElement = node; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.next = current; } } lengths++; head.set(this, headElement); length.set(this, lengths); return position; } return false; } //删除链表中指定位置的链表元素 removeAt(position) { let headElement = head.get(this), lengths = length.get(this), index = 0, current = headElement, previous; if(position &gt;= 0 &amp;&amp; position &lt; lengths) { if(!headElement) { return false; } else { if(lengths === 1) { headElement = null; } else { if(position === 0) { headElement = current.next; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; } } lengths--; head.set(this, headElement); length.set(this, lengths); return position; } } return false; } //删除链表中的指定链表元素 remove(element) { const {indexOf, removeAt} = this; let index = indexOf.bind(this)(element); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : false; } //删除链表中散列表链表查询中的链表项 removeKey(key) { const {indexOfKeyPosition, removeAt} = this; let index = indexOfKeyPosition.bind(this)(key); return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : index; } //获取链表指定的元素位置 indexOf(element) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(current.node === element) { return index - 1; } current = current.next; } return false; } //判断链表中是否存在散列表链表查询中的key indexOfKey(key) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(key === current.node.key) { return true; } current = current.next; } return false; } //获取链表指定的散列表链表查询中的链表项位置 indexOfKeyPosition(key) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(key === current.node.key) { return index - 1; } current = current.next; } return false; } //获取链表中散列表链表查询中的链表项 indexOfNode(key) { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0; while(index++ &lt; lengths) { if(key === current.node.key) { return current.node; } current = current.next; } return false; } //获取链表的长度 size() { return length.get(this); } //判断链表是否为空 isEmpty() { return length.get(this) === 0; } //获取链表的头部链表元素 headElement() { return head.get(this).node; } //获取链表中所有的链表结构 toString() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result_str = ``; while(index++ &lt; lengths) { result_str = `${result_str}${current.node} =&gt; `; current = current.next; } return result_str; } //获取链表中所有散列表查询的链表结构 toStringKey() { let headElement = head.get(this), lengths = length.get(this), current = headElement, index = 0, result_str = ``; while(index++ &lt; lengths) { result_str = `${result_str}{key: ${current.node.key}, value: ${current.node.value}} =&gt; `; current = current.next; } return result_str; } //获取链表的真实结构 valueOf() { return head.get(this); } //将链表清空 clear() { head.set(this, null); length.set(this, 0); } } //返回链表类 return LinkList; })(); let HashTable = (function (){ //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //设置散列表中的链表类 //@params key //@params value class Node { constructor(key, value) { this.key = key; this.value = value; } } //设置散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为loseLose算法 //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数 //然后对任何一个质数取余 //最后进行返回 loseLoseHashTable(key) { let hash_key = 13, index = 0; for(let i = 0; i &lt; key.length; i++) { index += i * hash_key + key.charCodeAt(i); } return index % 37; } //在散列表中添加散列表链表查询项 put(key, value) { const {loseLoseHashTable} = this; let hashTable = hash_table.get(this), index = loseLoseHashTable.bind(this)(key), node = new Node(key, value), linkList; if(hashTable[index] === undefined) { linkList = new LinkList(); linkList.insert(node); hashTable[index] = linkList; } else { linkList = hashTable[index]; if(linkList.indexOfKey(key)) { return false; } else { linkList = hashTable[index]; linkList.insert(node); hashTable[index] = linkList; } } hash_table.set(this, hashTable); return true; } //获取散列表指定的散列表链表查询项 get(key) { const {loseLoseHashTable} = this; let hashTable = hash_table.get(this), index = loseLoseHashTable.bind(this)(key), linkList, node; if(hashTable[index] !== undefined) { linkList = hashTable[index]; if(linkList.indexOfKey(key)) { node = linkList.indexOfNode(key); return node.value; } else { return false; } } return false; } //删除散列表中指定的散列表链表查询项 remove(key) { const {loseLoseHashTable} = this; let hashTable = hash_table.get(this), index = loseLoseHashTable.bind(this)(key), linkList; if(hashTable[index] !== undefined) { linkList = hashTable[index]; if(linkList.indexOfKey(key)) { linkList.removeKey(key); if(linkList.isEmpty()){ hashTable[index] = undefined; } else { hashTable[index] = linkList; } return true; } else { return false; } } return false; } //获取散列表链表查询拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}${value.toStringKey()} -&gt; `; } } return result_str; } //获取散列表链表查询的具体结构 valueOf() { return hash_table.get(this); } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表链表查询项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里在散列表中获取散列表链表查询项 //在这里打印: //aaron@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里在散列表中获取散列表链表查询项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表链表查询拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} =&gt; {key: Martin, value: martin@gmail.com} =&gt; -&gt; {key: Lily, value: lily@gmail.com} =&gt; -&gt; {key: Tom, value: tom@gmail.com} =&gt; -&gt; {key: Alice, value: alice@gmail.com} =&gt; -&gt; {key: Simon, value: simon@gmail.com} =&gt; -&gt; {key: Betty, value: betty@gmail.com} =&gt; -&gt; {key: Helen, value: helen@gmail.com} =&gt; -&gt; {key: Aaron, value: aaron@gmail.com} =&gt; {key: Tommy, value: tommy@gmail.com} =&gt; -&gt; {key: Frank, value: frank@gmail.com} =&gt; -&gt; console.log(hash_table.toString()); //这里获取散列表链表查询的具体结构 //在这里打印: //[LinkList, empty × 6, LinkList, empty × 2, LinkList, empty × 5, LinkList, empty × 2, LinkList, empty, LinkList, empty × 8, LinkList, empty × 4, LinkList, LinkList] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表链表查询项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); hash_table.remove(&quot;Tommy&quot;); //这里在散列表中获取散列表链表查询项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表链表查询拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} =&gt; {key: Martin, value: martin@gmail.com} =&gt; -&gt; {key: Lily, value: lily@gmail.com} =&gt; -&gt; {key: Alice, value: alice@gmail.com} =&gt; -&gt; {key: Simon, value: simon@gmail.com} =&gt; -&gt; {key: Betty, value: betty@gmail.com} =&gt; -&gt; {key: Helen, value: helen@gmail.com} =&gt; -&gt; {key: Frank, value: frank@gmail.com} =&gt; -&gt; console.log(hash_table.toString()); //这里获取散列表链表查询的具体结构 //在这里打印: //[LinkList, empty × 6, LinkList, empty × 2, undefined, empty × 5, LinkList, empty × 2, LinkList, empty, LinkList, empty × 8, LinkList, empty × 4, undefined, LinkList] console.log(hash_table.valueOf()); 散列表巡航迭代 散列表巡航迭代其实就是利用位置迭代解决问题,假如根据loseLose算法解析散列表项后的散列表项,所在位置已经存在散列表项,就去查询所在位置的下一个位置,依次迭代下去,直到查询到位置的散列表项为没有定义的值为止,下面我们就用散列表巡航迭代来解决散列表项覆盖的问题吧 let HashTable = (function () { //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //设置散列表中的对象类 //@params key //@params value class Node { constructor(key, value) { this.key = key; this.value = value; } } //设置散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为loseLose算法 //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数 //然后对任何一个质数取余 //最后进行返回 loseLoseHashTable(key) { let hash_key = 13, index = 0; for(let i = 0; i &lt; key.length; i++) { index += i * hash_key + key.charCodeAt(i); } return index % 37; } //在散列表中添加散列表巡航迭代项 put(key, value) { const {loseLoseHashTable} = this; let hash_key = loseLoseHashTable.bind(this)(key), hashTable = hash_table.get(this), node = new Node(key, value); if(hashTable[hash_key] === undefined) { hashTable[hash_key] = node; } else { while(hashTable[hash_key] !== undefined) { if(hashTable[hash_key].key === key) { return false; } hash_key++; } if(hashTable[hash_key] === undefined) { hashTable[hash_key] = node; } } hash_table.set(this, hashTable); return true; } //获取散列表指定的散列表巡航迭代项 get(key) { const {loseLoseHashTable} = this; let hash_key = loseLoseHashTable.bind(this)(key), hashTable = hash_table.get(this); if(hashTable[hash_key] === undefined) { return false; } else { while(hashTable[hash_key] !== undefined) { if(hashTable[hash_key].key === key) { return hashTable[hash_key].value; } hash_key++; } } return false; } //删除散列表中指定的散列表巡航迭代项 remove(key) { const {loseLoseHashTable} = this; let hash_key = loseLoseHashTable.bind(this)(key), hashTable = hash_table.get(this); if(hashTable[hash_key] === undefined) { return false; } else { while(hashTable[hash_key] !== undefined) { if(hashTable[hash_key].key === key) { hashTable[hash_key] = undefined; hash_table.set(this, hashTable); return true; } hash_key++; } } return false; } //获取散列表巡航迭代拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}{key: ${value[&quot;key&quot;]}, value: ${value[&quot;value&quot;]}} -&gt; `; } } return result_str; } //获取散列表巡航迭代的具体结构 valueOf() { return hash_table.get(this); } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表巡航迭代项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里在散列表中获取散列表巡航迭代项 //在这里打印: //aaron@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里在散列表中获取散列表巡航迭代项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表巡航迭代拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} -&gt; {key: Martin, value: martin@gmail.com} -&gt; {key: Lily, value: lily@gmail.com} -&gt; {key: Tom, value: tom@gmail.com} -&gt; {key: Alice, value: alice@gmail.com} -&gt; {key: Simon, value: simon@gmail.com} -&gt; {key: Betty, value: betty@gmail.com} -&gt; {key: Helen, value: helen@gmail.com} -&gt; {key: Aaron, value: aaron@gmail.com} -&gt; {key: Tommy, value: tommy@gmail.com} -&gt; {key: Frank, value: frank@gmail.com} -&gt; console.log(hash_table.toString()); //这里获取散列表巡航迭代的具体结构 //在这里打印: //[Node, Node, empty × 5, Node, empty × 2, Node, empty × 5, Node, empty × 2, Node, empty, Node, empty × 8, Node, empty × 4, Node, Node, Node] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表巡航迭代项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); //这里在散列表中获取散列表巡航迭代项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表巡航迭代拥有值的字符串项 //在这里打印: //{key: Gary, value: gary@gmail.com} -&gt; {key: Martin, value: martin@gmail.com} -&gt; {key: Lily, value: lily@gmail.com} -&gt; {key: Alice, value: alice@gmail.com} -&gt; {key: Simon, value: simon@gmail.com} -&gt; {key: Betty, value: betty@gmail.com} -&gt; {key: Helen, value: helen@gmail.com} -&gt; {key: Tommy, value: tommy@gmail.com} -&gt; {key: Frank, value: frank@gmail.com} -&gt; console.log(hash_table.toString()); //这里获取散列表巡航迭代的具体结构 //在这里打印: //[Node, Node, empty × 5, Node, empty × 2, undefined, empty × 5, Node, empty × 2, Node, empty, Node, empty × 8, Node, empty × 4, undefined, Node, Node] console.log(hash_table.valueOf()); djb2算法解决一切问题 还有一种既不使用链表查询,也不使用巡航迭代的方法,那就是展示散列表更广的djb2算法,使用djb2算法就可以直接解决loseLose算法解析后散列表项覆盖的问题,下面我们就用djb2算法来解决散列表项覆盖的问题吧 let HashTable = (function() { //设置散列表的容器,并初始化为空数组[] let hash_table = new WeakMap(); //设置散列表类 class HashTable { constructor() { hash_table.set(this, []); } //定义设计散列表的算法为djb2算法 //djb2算法和loseLose算法相近,都是定义一个质数(数值比较大的质数)乘以属性的每一个字符所在的位置,再加上属性每一个字符所对应的ASCII码值 //然后对任何一个质数(数值比较大的质数)取余 //最后再返回 djb2HashTable(key) { let hash_key = 5381, index = 0; for(let i = 0; i &lt; key.length; i++) { index += i * hash_key + key.charCodeAt(i); } return index % 1013; } //在散列表中添加散列表项 put(key, value) { const {djb2HashTable} = this; let hashTable = hash_table.get(this), hash_key = djb2HashTable.bind(this)(key); if(hashTable[hash_key] !== undefined) { return false; } hashTable[hash_key] = value; return true; } //获取散列表指定的散列表项 get(key) { const {djb2HashTable} = this; let hashTable = hash_table.get(this), hash_key = djb2HashTable.bind(this)(key); if(hashTable[hash_key] === undefined) { return false; } return hashTable[hash_key]; } //删除散列表中指定的散列表项 remove(key) { const {djb2HashTable} = this; let hashTable = hash_table.get(this), hash_key = djb2HashTable.bind(this)(key); if(hashTable[hash_key] === undefined) { return false; } hashTable[hash_key] = undefined; return true; } //获取散列表拥有值的字符串项 toString() { let hashTable = hash_table.get(this), result_str = ``; for(let [key, value] of hashTable.entries()) { if(value !== undefined) { result_str = `${result_str}${value} -&gt; `; } } return result_str; } //获取散列表的具体结构 valueOf() { return hash_table.get(this); } } //返回散列表类 return HashTable; })(); let hash_table = new HashTable(); //这里在散列表中添加散列表项 //在这里打印: //true console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;)); hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;); hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;); hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;); hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;); hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;); hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;); hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;); hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;); hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;); hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;); //这里获取散列表中指定的散列表项 //在这里打印: //aaron@gmail.com console.log(hash_table.get(&quot;Aaron&quot;)); //这里获取散列表中指定的散列表项 //在这里打印: //tom@gmail.com console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //tom@gmail.com -&gt; gary@gmail.com -&gt; lily@gmail.com -&gt; martin@gmail.com -&gt; alice@gmail.com -&gt; helen@gmail.com -&gt; aaron@gmail.com -&gt; frank@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; tommy@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[empty × 239, &quot;tom@gmail.com&quot;, empty × 33, &quot;gary@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 13, &quot;martin@gmail.com&quot;, empty × 304, &quot;alice@gmail.com&quot;, empty × 13, &quot;helen@gmail.com&quot;, empty × 4, &quot;aaron@gmail.com&quot;, &quot;frank@gmail.com&quot;, empty × 19, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 13, &quot;tommy@gmail.com&quot;] console.log(hash_table.valueOf()); //这里删除散列表中指定的散列表项 //在这里打印: //true console.log(hash_table.remove(&quot;Aaron&quot;)); hash_table.remove(&quot;Tom&quot;); //这里获取散列表中指定的散列表项 //在这里打印: //false console.log(hash_table.get(&quot;Tom&quot;)); //这里获取散列表拥有值的字符串项 //在这里打印: //gary@gmail.com -&gt; lily@gmail.com -&gt; martin@gmail.com -&gt; alice@gmail.com -&gt; helen@gmail.com -&gt; frank@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; tommy@gmail.com -&gt; console.log(hash_table.toString()); //这里获取散列表的具体结构 //在这里打印: //[empty × 239, undefined, empty × 33, &quot;gary@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 13, &quot;martin@gmail.com&quot;, empty × 304, &quot;alice@gmail.com&quot;, empty × 13, &quot;helen@gmail.com&quot;, empty × 4, undefined, &quot;frank@gmail.com&quot;, empty × 19, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 13, &quot;tommy@gmail.com&quot;] console.log(hash_table.valueOf()); 二叉树 这是我们学习的第一种非线性非顺序的数据结构 —— 树,后面还会学到更多,比如说图。树只有一个根节点,每一个节点都可能有一个或者多个子节点 —— 子叶,今天我们实现的二叉树,每个节点最多只能有两个子叶,left的子叶比其父节点数值小,right的子叶比其父节点数值大,下面我们来介绍一下二叉树 let Tree = (function () { //设置二叉树的容器,并初始化为null let head = new WeakMap(); //定义二叉树子叶节点类 //@params node //@params left //@params right class Node { constructor(node) { this.node = node; this.left = null; this.right = null; } } //定义二叉树类 class Tree { constructor() { head.set(this, null); } //在二叉树中添加子叶节点 insert(node) { const {insertNode} = this; let head_tree = head.get(this); head_tree = insertNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //二叉树中添加子叶节点执行方法 //利用当前的子叶节点和添加的子叶节点数值进行比较 //假如小于添加的子叶节点数值,就查询当前子叶节点的右子叶节点 //假如大于添加的子叶节点数值,就查询当前子叶节点的左子叶节点 //直到查询到节点为null为止,然后添加新的子叶节点 insertNode(node, node_key) { const {insertNode} = this; if(!node) { node = new Node(node_key); } else if(node.node &gt; node_key) { node.left = insertNode.bind(this)(node.left, node_key); } else { node.right = insertNode.bind(this)(node.right, node_key); } return node; } //在二叉树中删除指定的子叶节点 remove(node) { const {removeNode} = this; let head_tree = head.get(this); if(!head_tree) { return false; } head_tree = removeNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //二叉树中删除指定的子叶节点执行方法 //利用当前的子叶节点和删除的子叶节点数值进行比较 //假如小于删除的子叶节点,就查询当前子叶节点的右子叶节点 //假如大于删除的子叶节点,就查询当前子叶节点的左子叶节点 //直到等于删除的子叶节点数值,分为三种情况 //第一种,删除的子叶节点底下没有其左右子叶节点,就直接将删除的子叶节点置为null //第二种,删除的子叶节点底下的左右子叶节点有一边为null,就直接将删除的子叶节点置为左右子叶节点不为null的一边 //第三种,删除的子叶节点底下其左右子叶节点都不为null,就直接去查询删除的子叶节点其右子叶节点底下的最小的子叶节点,并将删除的子叶节点的数值置为这个最小的子叶节点的数值,再将删除的子叶节点其右子叶节点底下的最小的子叶节点删除 removeNode(node, node_key) { const {removeNode, findTheLeftNode} = this; if(node.node &gt; node_key) { node.left = removeNode.bind(this)(node.left, node_key); } else if(node.node &lt; node_key){ node.right = removeNode.bind(this)(node.right, node_key); } else { if(!node.left &amp;&amp; !node.right) { node = null; } else if (!node.left) { node = node.right; } else if (!node.right) { node = node.left; } else { let aux = findTheLeftNode.bind(this)(node.right); node.node = aux.node; node.right = removeNode.bind(this)(node.right, aux.node); } } return node; } //查询子叶节点底下的最小的(最左边的)子叶节点 findTheLeftNode(node) { const {findTheLeftNode} = this; if(node.left) { return findTheLeftNode.bind(this)(node.left); } return node; } //在二叉树中获取最小的(最左边的)子叶节点数值 min() { const {minNode} = this; let head_tree = head.get(this); console.log(&quot;最小的子叶:&quot;); return minNode.bind(this)(head_tree).node; } //二叉树中获取最小的(最左边的)子叶节点执行方法 minNode(node) { const {minNode} = this; if(node.left) { return minNode.bind(this)(node.left); } return node; } //在二叉树中获取最大的(最右边的)子叶节点数值 max() { const {maxNode} = this; let head_tree = head.get(this); console.log(&quot;最大的子叶:&quot;); return maxNode.bind(this)(head_tree).node; } //二叉树中获取最大的(最右边的)子叶节点执行方法 maxNode(node) { const {maxNode} = this; if(node.right) { return maxNode.bind(this)(node.right); } return node; } //在二叉树获取先序遍历 preorderTraversal(method) { const {preorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;先序遍历:&quot;); preorderTraversalNode.bind(this)(head_tree, method); } //二叉树先序遍历执行方法 preorderTraversalNode(node, method) { const {preorderTraversalNode} = this; if(node) { method.bind(this)(node); preorderTraversalNode.bind(this)(node.left, method); preorderTraversalNode.bind(this)(node.right, method); } } //在二叉树中获取中序遍历 inorderTraversal(method) { const {inorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;中序遍历:&quot;); inorderTraversalNode.bind(this)(head_tree, method); } //二叉树中序遍历执行方法 inorderTraversalNode(node, method) { const {inorderTraversalNode} = this; if(node) { inorderTraversalNode.bind(this)(node.left, method); method.bind(this)(node); inorderTraversalNode.bind(this)(node.right, method); } } //在二叉树中获取后序遍历 postorderTraversal(method) { const {postorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;后序遍历:&quot;); postorderTraversalNode.bind(this)(head_tree, method); } //二叉树后序遍历执行方法 postorderTraversalNode(node, method) { const {postorderTraversalNode} = this; if(node) { postorderTraversalNode.bind(this)(node.left, method); postorderTraversalNode.bind(this)(node.right, method); method.bind(this)(node); } } //在二叉树中获取二叉树的具体结构 valueOf() { let head_tree = head.get(this); return head_tree; } } //返回二叉树类 return Tree; })(); let tree = new Tree(); //这里在二叉树中添加子节点 //在这里打印: //true console.log(tree.insert(15)); tree.insert(10); tree.insert(18); tree.insert(20); tree.insert(17); tree.insert(16); tree.insert(25); tree.insert(5); tree.insert(8); tree.insert(55); tree.insert(30); tree.insert(35); tree.insert(40); tree.insert(45); tree.insert(50); //这里在二叉树中获取最小的(最左边的)子叶节点数值 //在这里打印: //最小的子叶: //5 console.log(tree.min()); //这里在二叉树中获取最大的(最右边的)子叶节点数值 //在这里打印: //最大的子叶: //55 console.log(tree.max()); //这里在二叉树中获取中序遍历 //在这里打印: //中序遍历: //5 //8 //10 //15 //16 //17 //18 //20 //25 //30 //35 //40 //45 //50 //55 tree.inorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在二叉树中获取先序遍历 //在这里打印: //先序遍历: //15 //10 //5 //8 //18 //17 //16 //20 //25 //55 //30 //35 //40 //45 //50 tree.preorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在二叉树中获取后序遍历 //在这里打印: //后序遍历: //8 //5 //10 //16 //17 //50 //45 //40 //35 //30 //55 //25 //20 //18 //15 tree.postorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 15, left: Node, right: Node} console.log(tree.valueOf()); //这里在二叉树中删除指定的子叶节点 //在这里打印: //true console.log(tree.remove(50)); tree.remove(40); tree.remove(15); //这里在二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 16, left: Node, right: Node} console.log(tree.valueOf()); 平衡二叉树 介绍并封装完了二叉树之后,我们来介绍一下平衡二叉树,其实平衡二叉树就是每一个二叉树上面的节点的平衡因子的绝对值不可以超过1,也就是说-1 &lt;= 平衡因子 &lt;= 1,所谓的平衡因子就是二叉树节点子树节点级数,-1 &lt;= 左子树级数 - 右子树级数 &lt;= 1,下面就让我们来介绍一下平衡二叉树吧 let AVLTree = (function () { //设置平衡二叉树的容器,并初始化为null let head = new WeakMap(); //定义平衡二叉树子叶节点类 //@params node //@params left //@params right class Node { constructor(node) { this.node = node; this.left = null; this.right = null; } } //定义平衡二叉树类 class AVLTree { constructor() { head.set(this, null); } //在平衡二叉树中添加子叶节点 insert(node) { const {insertNode} = this; let head_tree = head.get(this); head_tree = insertNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //平衡二叉树中添加子叶节点执行方法 //利用当前的子叶节点和添加的子叶节点数值进行比较 //假如小于添加的子叶节点数值,就查询当前子叶节点的右子叶节点 //假如大于添加的子叶节点数值,就查询当前子叶节点的左子叶节点 //直到查询到节点为null为止,然后添加新的子叶节点 insertNode(node, node_key) { const {insertNode, findBalanceFactor, LLBalanceNode, LRBalanceNode, RRBalanceNode, RLBalanceNode} = this; if(!node) { node = new Node(node_key); } else if(node.node &gt; node_key) { node.left = insertNode.bind(this)(node.left, node_key); if(findBalanceFactor.bind(this)(node.left) - findBalanceFactor.bind(this)(node.right) &gt; 1) { if(node_key &lt; node.left.node) { node = LLBalanceNode.bind(this)(node); } else { node = LRBalanceNode.bind(this)(node); } } } else { node.right = insertNode.bind(this)(node.right, node_key); if(findBalanceFactor.bind(this)(node.right) - findBalanceFactor.bind(this)(node.left) &gt; 1) { if(node_key &gt; node.right.node) { node = RRBalanceNode.bind(this)(node); } else { node = RLBalanceNode.bind(this)(node); } } } return node; } //平衡二叉树使用LL算法来解决添加的新的子叶节点数值小于其父子叶节点(左边父子叶节点)的数值的平衡问题 LLBalanceNode(node) { let target = node.left; node.left = target.right; target.right = node; return target; } //平衡二叉树使用LL算法来解决添加的新的子叶节点数值大于其父子叶节点(左边父子叶节点)的数值的平衡问题 LRBalanceNode(node) { const {RRBalanceNode, LLBalanceNode} = this; node.left = RRBalanceNode.bind(this)(node.left); return LLBalanceNode.bind(this)(node); } //平衡二叉树使用RR算法来解决添加的新的子叶节点数值大于其父子叶节点(右边父子叶节点)的数值的平衡问题 RRBalanceNode(node) { let target = node.right; node.right = target.left; target.left = node; return target; } //平衡二叉树使用RR算法来解决添加的新的子叶节点数值小于其父子叶节点(右边父子叶节点)的数值的平衡问题 RLBalanceNode(node) { const {RRBalanceNode, LLBalanceNode} = this; node.right = LLBalanceNode.bind(this)(node.right); return RRBalanceNode.bind(this)(node); } //获取每个平衡二叉树节点的平衡因子 findBalanceFactor(node) { const {findBalanceFactor} = this; if(!node) { return -1; } else { return Math.max(findBalanceFactor.bind(this)(node.left), findBalanceFactor.bind(this)(node.right)) + 1; } } //在平衡二叉树中删除指定的子叶节点 remove(node) { const {removeNode} = this; let head_tree = head.get(this); if(!head_tree) { return false; } head_tree = removeNode.bind(this)(head_tree, node); head.set(this, head_tree); return true; } //平衡二叉树中删除指定的子叶节点执行方法 //利用当前的子叶节点和删除的子叶节点数值进行比较 //假如小于删除的子叶节点,就查询当前子叶节点的右子叶节点 //假如大于删除的子叶节点,就查询当前子叶节点的左子叶节点 //直到等于删除的子叶节点数值,分为三种情况 //第一种,删除的子叶节点底下没有其左右子叶节点,就直接将删除的子叶节点置为null //第二种,删除的子叶节点底下的左右子叶节点有一边为null,就直接将删除的子叶节点置为左右子叶节点不为null的一边 //第三种,删除的子叶节点底下其左右子叶节点都不为null,就直接去查询删除的子叶节点其右子叶节点底下的最小的子叶节点,并将删除的子叶节点的数值置为这个最小的子叶节点的数值,再将删除的子叶节点其右子叶节点底下的最小的子叶节点删除 removeNode(node, node_key) { const {removeNode, findTheLeftNode} = this; if(node.node &gt; node_key) { node.left = removeNode.bind(this)(node.left, node_key); } else if(node.node &lt; node_key){ node.right = removeNode.bind(this)(node.right, node_key); } else { if(!node.left &amp;&amp; !node.right) { node = null; } else if (!node.left) { node = node.right; } else if (!node.right) { node = node.left; } else { let aux = findTheLeftNode.bind(this)(node.right); node.node = aux.node; node.right = removeNode.bind(this)(node.right, aux.node); } } return node; } //查询子叶节点底下的最小的(最左边的)子叶节点 findTheLeftNode(node) { const {findTheLeftNode} = this; if(node.left) { return findTheLeftNode.bind(this)(node.left); } return node; } //在平衡二叉树中获取最小的(最左边的)子叶节点数值 min() { const {minNode} = this; let head_tree = head.get(this); console.log(&quot;最小的子叶:&quot;); return minNode.bind(this)(head_tree).node; } //平衡二叉树中获取最小的(最左边的)子叶节点执行方法 minNode(node) { const {minNode} = this; if(node.left) { return minNode.bind(this)(node.left); } return node; } //在平衡二叉树中获取最大的(最右边的)子叶节点数值 max() { const {maxNode} = this; let head_tree = head.get(this); console.log(&quot;最大的子叶:&quot;); return maxNode.bind(this)(head_tree).node; } //平衡二叉树中获取最大的(最右边的)子叶节点执行方法 maxNode(node) { const {maxNode} = this; if(node.right) { return maxNode.bind(this)(node.right); } return node; } //在平衡二叉树获取先序遍历 preorderTraversal(method) { const {preorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;先序遍历:&quot;); preorderTraversalNode.bind(this)(head_tree, method); } //平衡二叉树先序遍历执行方法 preorderTraversalNode(node, method) { const {preorderTraversalNode} = this; if(node) { method.bind(this)(node); preorderTraversalNode.bind(this)(node.left, method); preorderTraversalNode.bind(this)(node.right, method); } } //在平衡二叉树中获取中序遍历 inorderTraversal(method) { const {inorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;中序遍历:&quot;); inorderTraversalNode.bind(this)(head_tree, method); } //平衡二叉树中序遍历执行方法 inorderTraversalNode(node, method) { const {inorderTraversalNode} = this; if(node) { inorderTraversalNode.bind(this)(node.left, method); method.bind(this)(node); inorderTraversalNode.bind(this)(node.right, method); } } //在平衡二叉树中获取后序遍历 postorderTraversal(method) { const {postorderTraversalNode} = this; let head_tree = head.get(this); console.log(&quot;后序遍历:&quot;); postorderTraversalNode.bind(this)(head_tree, method); } //平衡二叉树后序遍历执行方法 postorderTraversalNode(node, method) { const {postorderTraversalNode} = this; if(node) { postorderTraversalNode.bind(this)(node.left, method); postorderTraversalNode.bind(this)(node.right, method); method.bind(this)(node); } } //在平衡二叉树中获取二叉树的具体结构 valueOf() { let head_tree = head.get(this); return head_tree; } } //返回平衡二叉树类 return AVLTree; })(); let tree = new AVLTree(); //这里在平衡二叉树中添加子节点 //在这里打印: //true console.log(tree.insert(15)); tree.insert(10); tree.insert(18); tree.insert(20); tree.insert(17); tree.insert(16); tree.insert(25); tree.insert(5); tree.insert(8); tree.insert(55); tree.insert(30); tree.insert(35); tree.insert(40); tree.insert(45); tree.insert(50); //这里在平衡二叉树中获取最小的(最左边的)子叶节点数值 //在这里打印: //最小的子叶: //5 console.log(tree.min()); //这里在平衡二叉树中获取最大的(最右边的)子叶节点数值 //在这里打印: //最大的子叶: //55 console.log(tree.max()); //这里在平衡二叉树中获取中序遍历 //在这里打印: //中序遍历: //5 //8 //10 //15 //16 //17 //18 //20 //25 //30 //35 //40 //45 //50 //55 tree.inorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在平衡二叉树中获取先序遍历 //在这里打印: //先序遍历: //17 //15 //8 //5 //10 //16 //30 //20 //18 //25 //40 //35 //50 //45 //55 tree.preorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在平衡二叉树中获取后序遍历 //在这里打印: //后序遍历: //5 //10 //8 //16 //15 //18 //25 //20 //35 //45 //55 //50 //40 //30 //17 tree.postorderTraversal((node)=&gt;{ console.log(node.node); }); //这里在平衡二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 17, left: Node, right: Node} console.log(tree.valueOf()); //这里在平衡二叉树中删除指定的子叶节点 //在这里打印: //true console.log(tree.remove(50)); tree.remove(40); tree.remove(15); //这里在平衡二叉树中获取二叉树的具体结构 //在这里打印: //Node {node: 17, left: Node, right: Node} console.log(tree.valueOf());]]></content>
      <categories>
        <category>Javascript数据结构和算法</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-07 浅谈使用jQuery和react的区别]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%B5%85%E8%B0%88%E4%BD%BF%E7%94%A8jQuery%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-07 查漏补缺]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%2F</url>
    <content type="text"><![CDATA[赋值操作的返回 最近在读一本《JavaScript DOM 编程艺术》的书,其中有一句话引起了我的好奇,假如if判断语句中存在赋值语句,则赋值语句的返回总是true。我对此结果进行了检验 var a; //这种情况下,if判断语句中返回&quot;good&quot;,为true //打印&quot;good result&quot; if(a = &quot;good&quot;) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回false,为false //什么都不打印 if(a = false) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回undefined,为false //什么都不打印 if(a = undefined) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回0,为false //什么都不打印 if(a = 0) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回null,为false //什么都不打印 if(a = null) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回{},为true //打印&quot;good result&quot; if(a = {}) { console.log(&quot;good result&quot;); } //这种情况下,if判断语句中返回[],为true //打印&quot;good result&quot; if(a = []) { console.log(&quot;good result&quot;); } 实践是检验真理的唯一标准,由此检验到赋值操作的返回就是其本身,本身类型转换后为true,则为true;转换后为false,则为false,并不总是返回true,书中的那句话实践出是不妥当的。 模板字符串的换行功能 学模板字符串时,本来只是以为模板字符串所带来的只不过是一个外部变量引入的功能,这几天发现换行不直接写\n,直接换行编写,就可以实现换行功能 let name = &quot;Gary&quot;, sentence = `Hi, ${name} is my name, I&apos;m 25 year&apos;s old~`; //这里打印 //Hi, Gary is my name, //I&apos;m 25 year&apos;s old~ console.log(sentence); ES6类的存取函数 在ES6中实现了类的表象,虽然还是基于原型链来实现的,但是大致的功能正在向着C、Java类的方式逐渐靠近,比如类的存取函数 class Book { constructor(name = &quot;Gary&quot;) { this._name = name; } //类的取值函数 get getBook() { return this._name; } //类的存储函数 set setBook(value) { this._name = `Hi, ${value}`; } } //获取到&quot;书&quot;这个类的实例 let book = new Book(&quot;Yinwk&quot;); //调用实例的取值函数 //这里打印: //Yinwk console.log(book.getBook); //调用实例的存储函数 book.setBook = &quot;yinwenkai&quot;; //再次调用实例的取值函数 //这里打印: //yinwenkai console.log(book.getBook); 各类型比较运算符时的转化 if(“package” == true) console.log(“package == true”);是会打印”package == true”呢,还是不会打印呢,很多人的答案肯定是会打印,理由是:因为”package”返回true啊,所以true == true啊。请看这里判断语句中是一个比较表达式,并不是if(“package”),是需要在比较语句两边进行转化的,普通类型进行toNumber,引用类型进行valueOf或者toString之后的原始值比较 if(null == undefeind) {...} //返回true if(undefined == null) {...} //返回true if(&quot;package&quot; == true) {...} //将string和boolean类型进行number转化, //&quot;package&quot;转化为NaN,true转化为1, //NaN == 1吗?答案当然是false,返回false if(&quot;0&quot; == false){...} //将string和boolean类型进行number转化, //&quot;0&quot;转化为0,false转化为0, //0 == 0吗?答案当然是true,返回true if(&quot;package&quot; == 1){...} //将string和number类型进行number转化, //将&quot;package&quot;转化为NaN,1还是转化为1, //NaN == 1吗?答案当然是false,返回false let _obj = {name: &apos;Gary&apos;}, _objAno = {name: &apos;Gary&apos;}; if(_obj == _objAno){...} //将两个object类型进行valueOf方法或者toString方法的转化,哪个方法转化为原始值,就用转化为的原始值进行比较 //{name: &apos;Gary&apos;}在valueOf方法转化为{name: &apos;Gary&apos;},在toString方法转化为&quot;[object Object]&quot; //原始值当然是valueOf方法转化的值 //{name: &apos;Gary&apos;} == {name: &apos;Gary&apos;}吗？答案当然是false,返回false ES6新增Array.prototype.include ES6数组新增了一个判断是否包含数组元素的方法,用来检索数组中是否存在某个数组元素,基本有两种方式进行检索 let number_arr = [26, 18, 10, 55, 88, 100, 38, 44]; //数组中的确包含 88 这个元素 //在这里打印: //true console.log(number_arr.includes(88)); //从数组下标为 5 的元素后面去寻找 88 这个元素 //在这里打印: //false console.log(number_arr.includes(88, 5)); ES6类型数组 在ES6中引入了一些类型数组,他们的属性以及方法和普通的数组并无二致,只是对类型做了一些限制,比如Int8Array(8位二进制补码整数)、Uint8Array(8位无符号整数)、Int16Array(16位二进制补码整数)、Uint16Array(16位无符号整数)、Int32Array(32位二进制补码整数)、Uint32Array(32位无符号整数)等等 对具有着重符的字符串数组进行排序 假如需要对具有着重符号的字符串数组进行排序,需要用localCompare let string_arr = [&quot;Maève&quot;, &quot;Maeve&quot;]; string_arr.sort(function sort_arr(a, b){ return a.localCompare(b); }); //没有着重符号的数组元素会比有着重符号的数组元素小 //这里打印: //[&quot;Maeve&quot;, &quot;Maève&quot;] console.log(string_arr); apply、call硬绑定小经验function Person() { this.name = &quot;Gary&quot;; this.age = 26; console.log(this.name); console.log(this.age); } let clay = { name: &quot;Clay&quot;, age: 27 }; //这里充分证明了new绑定实现构造函数对象的优先级大于call或者apply硬绑定 //Person函数的this指向并没有指向clay,还保持着初始值 //而对象clay的属性name和age的值都改变为Person函数this指向的值 //在这里打印: //Gary //26 //Gary //26 Person.call(clay); console.log(clay.name); console.log(clay.age); function Person() { console.log(this.name); console.log(this.age); } let clay = { name: &quot;Clay&quot;, age: 27 }; //这里Person函数的this指向clay //而对象clay的属性name和age的值还是保持着初始值 //在这里打印: //Clay //27 //Clay //27 Person.call(clay); console.log(clay.name); console.log(clay.age); 从上面的例子,我们可以得出this的绑定优先级: new绑定 &gt; apply、call和bind硬绑定 &gt; 普通对象软绑定 &gt; 默认绑定,当this对象上面的属性进行定义声明,再使用apply、call或者bind硬绑定时,new绑定this对象上面的属性的优先级就大于apply、call或者bind硬绑定对象上面的属性的优先级,这时候显示的就是this对象上面的属性值,当this对象上面的属性没有进行定义声明,这时候apply、call或者bind硬绑定对象上面的属性的优先级就是最大的,这时候显示的就是硬绑定对象上面的属性的属性值]]></content>
      <categories>
        <category>Html or Css Or Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Html</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-06 封装的一些小工具]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[debounce函数节流 函数节流通常被用于输入下拉框、滚动懒加载等场景,目的只有一个,在短时间内,限制多次调用后台接口,浪费大量资源,防止接口响应数据时间上的误差造成的页面显示数据的错误。 //设置一个timer变量,用来承接setTimeout返回的延时对象 const timer = null; //函数节流方法 function debounce(fuc, delay) { //每一次进行输入或者拉动滚动条的时候,都会对延时对象进行判断,假如存在延时对象,就停止延时对象,并把延时对象置为空,释放内存,使得垃圾回收机制能更快的对延时对象进行回收 if(timer) { clearTimeout(timer); timer = null; } //给延时对象赋予一个延时方法,fuc就是请求后台接口的函数,delay就是延时时间 timer = setTimeout(fuc, delay); } //函数节流方法,只要在delay时间内,再次触发此方法,延时对象就会被停止且置空,后台的接口函数就不会被调用。 //做到了在短时间内输入或者滚动限制了多次调用后台接口,防止了接口响应数据时间上的误差造成页面数据显示的错误。 bind函数绑定 bind绑定是一种硬绑定,和apply函数、call函数一样的作用,且更加简便,其作用也是为了改变函数或者”类”函数this的指向,大多数浏览器都是已经实现了内置bind方法,我们今天来模拟一下bind方法的实现 if(Function.prototype.bind === undefined) { Function.prototype.bind = function(context) { //首先判断调用bind方法的是否是函数类型 //假如不是函数类型,直接抛出错误异常 if(typeof this !== &quot;function&quot;) { throw new Error(&quot;bind函数必须应用在函数上面&quot;); } //获取arguments参数,除了要绑定的对象第一个参数之外的所有的参数,并生成数组 let args = Array.prototype.slice.call(arguments, 1), self = this, fBind; function F() {} //在闭包中进行硬绑定,假如闭包不作为new绑定的函数对象使用,则其中的this指向window,假如作为new绑定的函数对象使用,则其中的this指向闭包函数对象 fBind = function () { let args_fBind = Array.prototype.slice.call(arguments); return self.apply(this instanceof fBind ? this : context, args.concat(args_fBind)); } //假如闭包作为new绑定的函数对象使用,就要继承bind绑定函数对象的显式原型 //即闭包函数对象的隐式原型指向其bind绑定函数对象的显式原型 F.prototype = self.prototype; fBind.prototype = new F(); fBind.constructor = fBind; return fBind; } } window.name = &quot;Gary&quot;; function Person(age) { console.log(this.name); this.age = age; console.log(this.age); } //此时this默认绑定在window上面 //在这里打印: //Gary //24 Person(24); let clay = { name: &quot;Clay&quot; }; //此时进行硬绑定,this指向clay对象 //而闭包函数对象中的this则指向window //在这里打印: //Clay //25 let me = Person.bind(clay); me(25); Person.prototype.introduce = function () { console.log(`name: ${this.name}, age: ${this.age}`); }; //此时进行硬绑定,this本指向clay对象 //但是闭包函数对象却进行了new绑定构造函数操作,使得this指向闭包函数本身 //闭包函数本身并不存在name对象,所以打印this.name为undefined,无定义的 //在这里打印: //undefined //26 //undefined //26 //name: undefined, age: 26 let me_bind = Person.bind(clay); let Clay = new me_bind(26); console.log(Clay.name); console.log(Clay.age); Clay.introduce(); new绑定实现构造函数对象 Javascript中存在一种特定的设计模式:原型设计模式,每一个对象都具有一个隐式原型,每一个函数对象都具有一个显式原型,通过new绑定实现构造函数对象返回的引用对象进行串联,也就是说每一个引用对象的隐式原型指向其构造函数的显式原型,所有的对象都是通过一个空对象复制出来的,也就是Object.prototype,现在我们模拟模拟一下new绑定实现构造函数对象 function ObjectNew() { let obj_prototype = {}, Constructor = Array.prototype.slice.call(arguments, 0, 1)[0]; obj_prototype.__proto__ = Constructor.prototype; let res = Constructor.apply(obj_prototype, Array.prototype.slice.call(arguments, 1)); return typeof res === &quot;object&quot; ? res : obj_prototype; } function Person(name, age) { this.name = name; this.age = age; } Person.prototype.introduce = function () { console.log(`name: ${this.name}, age: ${this.age}`); }; //这里和new绑定实现构造函数对象的效果一模一样 //在这里打印: //Gary //26 //name: Gary, age: 26 let gary = ObjectNew(Person, &apos;Gary&apos;, 26); console.log(gary.name); console.log(gary.age); gary.introduce(); getElementsByClassName封装 getElementsByClassName是HTML5 DOM引入的一个获取class样式节点的方法,有一些不支持HTML5 DOM的浏览器可能不存在这个方法,所以需要对这个方法进行封装 //html code &lt;!Doctype html&gt; &lt;html lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;getElemetnsByClassName封装&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;home&quot;&gt; &lt;p class=&quot;number&quot;&gt;first&lt;/p&gt; &lt;p class=&quot;number second&quot;&gt;second&lt;/p&gt; &lt;p class=&quot;number&quot;&gt;third&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;boxesByClassName.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; //boxesByClassName.js function getElementsByClassName(node, className) { //判断DOM是否有getElementsByClassName方法,假如有,就返回node节点下的所有className子节点 if(node.getElementsByClassName) { return node.getElementsByClassName(className); } else { //假如没有,就先去获取node节点下的所有子节点元素,然后根据子节点元素的className属性进行匹配外部传入的className,假如包含此className,就传入返回的数组中,最后返回数组 let _get_className_arr = [], _tag_arr = node.getElementsByTagName(&quot;*&quot;), _tag_arr_length = _tag_arr.length; for(let i = 0; i &lt; _tag_arr_length; i++) { if(_tag_arr[i].className.includes(className)){ _get_className_arr[_get_className_arr.length] = _tag_arr[i]; } } return _get_className_arr; } } addEvent加载完成事件封装 对于window.onload事件,再熟悉不过了,用于在页面DOM全部加载完毕之后执行Javascript,防止在页面DOM渲染过程中对DOM进行操作,使得页面卡顿,降低用户体验。window.onload的挂载一个或者多个的方式于实际情况而定,所以需要对window.onlaod加载完成事件进行封装 function addEvent(eventLoad) { //将window.onload事件函数赋值给一个变量 let load = window.onload; //判断window.onload加载完成事件上面,是否挂载了事件函数 //假如挂载了事件函数,就将新的事件函数添加到window.onload加载完成事件队列中 //假如没有挂载事件函数,就直接将新的事件函数挂载上去 if (typeof load !== &quot;function&quot;) { window.onload = eventLoad; } else { window.onload = function() { load(); eventLoad(); } } } insertAfter插入到某个元素节点之后封装 parentNode.insertBefore(newElement, targetElement),insertBefore方法是在某一个元素节点之前插入新的元素节点,而DOM-Core并没有提供insertAfter方法,旨在在某一个元素节点之后插入新的元素节点,于是进行insertAfter封装 function insertAfter(newElement, targetElement) { //获取目标节点的父节点 let parent = targetElement.parentNode; //判断父节点的最后一个子节点是否是目标节点,假如是,就直接将新的元素节点,添加到父节点下 //假如不是,就将新的元素节点插入到目标节点兄弟节点之前 if(parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement, targetElement.nextSibling); } } isEmpty判断对象是否为空的封装 Javascript的对象判断是否为空,并没有原生的方法,所以需要封装一下,成为自己的库 function isEmpty(obj) { //判断对象是否为空的标识符,默认为true,判断对象为空 let flag = true; //使用ES6遍历对象,假如对象中有遍历的对象属性,就说明对象不为空,设置flag为false,判断对象不为空 for(let [key, value] of Object.entries(obj)) { if(obj.hasOwnProperty(key)) { flag = false; break; } } return flag; } getNextElementSibling获取元素节点的下一个兄弟元素节点 node.nextSibling是获取某一个元素节点的下一个兄弟节点,但是节点类型可能是元素、属性以及文本,是不确定的,而通常,我们希望获取下一个兄弟节点的时候为元素节点,所以需要对获取元素节点的下一个兄弟元素节点进行封装 function getNextElementSibling(node) { //判断元素节点是否有下一个兄弟节点,如果没有返回false if(!node.nextSibling) return false; //获取元素节点的下一个兄弟节点 let nextSibling = node.nextSibling; //假如元素节点的下一个兄弟节点的节点类型为1,也就是元素节点,就返回元素节点的下一个兄弟节点 if(nextSibling.nodeType === 1) { return nextSibling; } //假如元素节点的下一个兄弟节点的节点类型为除了1以外的其他数字,就再次递归元素节点的下一个兄弟节点,直到找到下一个兄弟元素节点位置 return getNextElementSibling(nextSibling); } moveElement动态的元素节点 通过原生的Javascript来生成动画,是解决CSS3不兼容低版本浏览器的最好的平稳退化方案,利用setTimeout生成的通用动画效果的函数方法在此 //设置一个承接时间对象的变量 let timer = null; //函数传递四个参数,要产生移动的元素节点,将要移动到的x轴位置,将要移动到的y轴位置,以及移动元素节点的时间(单位: 毫秒) function moveElement(node, x, y, speed) { //首先校验是否存在移动元素的节点,假如不存在,直接返回false,退出函数 if(!document.getElementById(node)) return false; let elem = document.getElementById(node); //然后判断是否有时间对象,假如有的话,直接清理掉,并把时间对象置为空,以便浏览器垃圾回收机制更快的回收内存中的不需要的数据 if(timer) { clearTimeout(timer); timer = null; } //判断移动元素节点样式的top和left属性是否存在,如果不存在,初始化top和left的属性为0px if(!elem.style.top) { elem.style.top = &quot;0px&quot;; } if(!elem.style.left) { elem.style.left = &quot;0px&quot;; } //获取移动元素节点样式的top和left属性值,并转化为绝对值的数值类型 let xpo = Math.abs(parseInt(elem.style.left)), ypo = Math.abs(parseInt(elem.style.top)); //假如移动元素节点样式的left的绝对值与要移动到的x轴位置相等,且移动元素节点样式的top的绝对值与要移动到的y轴位置相等,则返回true,退出递归函数 if(xpo === x &amp;&amp; ypo === y) { return true } let dist; //假如移动元素节点样式的left的绝对值小于要移动到的x轴位置,就将移动元素节点样式的left的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果 if(xpo &lt; x) { dist = Math.ceil((x - xpo) / 10); xpo += dist; } //假如移动元素节点样式的left的绝对值大于要移动到的x轴位置... if(xpo &gt; x) { dist = Math.ceil((xpo - x) / 10); xpo -= dist; } //假如移动元素节点样式的top的绝对值小于要移动到的y轴位置,就将移动元素节点样式的top的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果 if(ypo &lt; y) { dist = Math.ceil((y - ypo) / 10); ypo += dist; } //假如移动元素节点样式的top的绝对值大于要移动到的y轴位置... if(ypo &gt; y) { dist = Math.ceil((ypo - y) / 10); ypo -= dist; } //将移动元素节点样式的top和left的绝对值取反,赋值重新赋值给移动元素节点样式 elem.style.left = `${-xpo}px`; elem.style.top = `${-ypo}px`; //未到目标位置,设置时间处理函数继续递归动态的元素节点函数,并把时间对象赋值给timer变量 timer = setTimeout(function timer() { moveElement(node, x, y, speed); }, speed); } getGreyGeneral根据图片利用canvas制作灰度图 利用canvas画布可以制作各种各样的图片以及动画效果,包括二维、三维等图片和动画,灰度图就是二维图片中一个比较难处理的例子,由此对其进行封装 function getGreyGeneral(img) { //假如Modernizr检测兼容的全局对象中查找不到canvas属性,就返回false,退出函数 if(!Modernizr.canvas) return false; //假如document对象中不存在createElement方法,也返回false,退出函数 if(!document.createElement) return false; //创建一个canvas元素节点对象 let canvas = document.createElement(&quot;canvas&quot;); //设置canvas元素节点对象的宽和高为图片的宽和高 canvas.width = img.width; canvas.height = img.height; //获取canvas二维画布绘图环境 let ctx = canvas.getContext(&quot;2d&quot;); //在二维画布绘图环境上面,根据图片DOM对象进行绘制,从图片DOM对象坐标的(0, 0)位置开始绘制 ctx.drawImage(img, 0, 0); //获取到二维绘图环境的图片数据,从坐标(0, 0)位置开始,到图片的(img.width, img.height)宽度和高度位置截止 let c = ctx.getImageData(0, 0, img.width, img.height); //对图片数据进行灰度处理,获取到每个像素的rgb值,每四个像素(最后一个像素永远是255)数据一组,求rgb的平均值,并重新赋值给rgb for(let i = 0;i &lt; c.height;i ++) { for(let j = 0;j &lt; c.width;j ++) { let x = i * 4 * c.height + j * 4, data = c.data, r = data[x], g = data[x + 1], b = data[x + 2]; data[x] = data[x + 1] = data[x + 2] = (r + g + b) / 3; } } //将灰度处理好的二维绘图环境图片数据,重新赋予到原来的二维绘图环境上面,且设置二维绘图环境的偏移位置(0, 0),以及绘图处理渲染的偏移位置(0, 0),最后设置二维绘图环境图片数据的宽度和高度 ctx.putImageData(c, 0, 0, 0, 0, img.width, img.height); //返回canvas生成的图片数据URL return canvas.toDataURL(); } setVideoControl配置video视频播放器的默认播放和暂停按键 HTML5中新加了video和audio标签,以前都是使用object和embed标签来插入视频和音频插件,有好多繁琐的配置,现在有了video和audio标签使得我们在编写视频和音频代码时,方便快捷了很多,下面是对video播放和暂停键重置的封装 function setVideoControl(video) { //首先先将video视频元素节点的controls属性删掉,这样controls一系列默认的播放、暂停键以及滑动条等配置就被剔除掉了 video.removeAttribute(&quot;controls&quot;); //设置video视频元素节点的宽度和高度,分别为视频的实际宽度和高度 video.width = video.videoWidth; video.height = video.videoHeight; //设置video视频元素节点的宽度和高度,分别也为视频的实际宽度和高度 video.parentNode.width = video.videoWidth; video.parentNode.height = video.videoHeight; //创建一个承接播放/暂停按钮的div容器,再创建一个播放/暂停按钮 let play = document.createElement(&quot;div&quot;), button = document.createElement(&quot;button&quot;); //设置div容器的title标题属性默认为&quot;Play&quot; play.setAttribute(&quot;title&quot;, &quot;Play&quot;); //设置播放/暂停按钮默认的文本节点为&amp;#x25BA;(播放按钮) button.innerHTML = &quot;&amp;#x25BA;&quot;; //将播放/暂停按钮放入到div容器中 play.appendChild(button); //并将承接播放/暂停按钮的div容器插入到video视频元素节点之前 video.parentNode.insertBefore(play, video); //设置承接播放/暂停按钮的div容器点击事件: //假如video视频元素节点的暂停属性为true,则执行video视频元素节点的play播放方法 //否则执行vedio视频元素节点的pause暂停方法 play.onclick = function (e){ if(video.paused) { video.play(); } else { video.pause(); } }; //设置video视频元素节点的play播放方法,将承载播放/暂停按钮的div容器title标题属性设置为Pause,并设置播放/暂停按钮的文本节点设置为&amp;#x2590;&amp;#x2590;(暂停按钮) video.addEventListener(&quot;play&quot;, function (e) { button.innerHTML = &quot;&amp;#x2590;&amp;#x2590;&quot;; play.setAttribute(&quot;title&quot;, &quot;Pause&quot;); }); //设置video视频元素节点的pause暂停方法,将承载播放/暂停按钮的div容器title标题属性设置为Play,并设置播放/暂停按钮的文本节点设置为&amp;#x25BA;;(播放按钮) video.addEventListener(&quot;pause&quot;, function (e) { button.innerHTML = &quot;&amp;#x25BA&quot;; play.setAttribute(&quot;title&quot;, &quot;Play&quot;); }); //设置video视频元素节点的ended视频结束方法,将video视频元素节点的currentTime属性(当前滑动条进度)设置为:起始位置,并执行video视频元素节点pause暂停方法 video.addEventListener(&quot;ended&quot;, function (e) { video.currentTime = 0; video.pause(); }); } Symbol.iterator迭代对象 说起Symbol.iterator,就会想到ES6新引进的迭代器,像Array.keys(),Array.values(),Array.entries(),都是Symbol.iterator迭代对象实现的,每一次迭代(.next())都会返回一个对象: {value: 迭代的值, done: 迭代的状态},当迭代结束,就会返回{value: undefined, done: true},但是这个迭代对象只存在于数组、Object对象以及Generator等迭代器里,要想迭代对象,需要手动去添加它的Symbol.iterator方法 let yinwk = { name: &quot;Gary&quot;, age: 25, hobby: [&quot;basketball&quot;, &quot;tennis&quot;], [Symbol.iterator]() { //首先将this对象赋值给一个变量 let that = this, //然后获取this对象指向的本对象的属性数组 that_key = Object.keys(that), //接着获取本对象的属性数组的长度 len = that_key.length, //最后定义一个递增变量,用来遍历本对象的属性值 index = 0; //返回一个对象,对象中有一个next函数方法,在其中判断递增变量index是否大于属性数组的长度, //假如不大于,说明没有迭代完成,则返回{value: 属性值(that[that_key[index++]]), done: false} //假如大于,说明迭代完成,则返回{value: 属性值(that[that_key[index++]]), done: true} return { next() { if(index &gt; len){ return { value: that[that_key[index++]], done: true } } else { return { value: that[that_key[index++]], done: false } } } } } }; //对添加好迭代对象的对象进行遍历 //这里打印: // &quot;Gary&quot; // 25 // [&quot;basketball&quot;, &quot;tennis&quot;] for(let value of yinwk) { console.log(value); } 闭包实现缓存机制 有时一些函数内的重复循环、判断甚至是普通的同步定义赋值,对于浏览器来说或大或小都是损耗,现在我们使用闭包对重复的操作缓存起来,减少重复的操作和损耗,提高浏览器的性能 function cache() { //进行存储的对象 let res_obj = {}; //进行运算的操作函数 function operation() { let a = 1; for(let i = 0; i &lt; arguments.length; i++) { a *= arguments[i]; } return a; } return function() { let args = Array.prototype.join.call(arguments, &quot;_&quot;); if(res_obj[args]) { return res_obj[args]; } console.log(&quot;first cache~&quot;); return res_obj[args] = operation.apply(this, arguments); } } let cache_control = cache(); //在这里打印: //first cache~ let cache_result = cache_control(3, 4, 5); //在这里打印: //60 console.log(cache_result); //在这里打印: //60 console.log(cache_control(3, 4, 5)); 使用命令模式实现模拟的开关Tv的功能 将开关Tv对象封装至函数内部,以构造函数的引用对象或者闭包函数的方式导出,调用新的函数方法控制模拟开关Tv,首先以构造函数的引用对象方式导出 let Tv = { open() { console.log(&quot;open the Tv&quot;); }, close() { console.log(&quot;close the Tv&quot;); } }; //以构造函数的引用对象方式导出 function CommandInOrder(command) { this.command = command; } //原型链函数方法: 打开Tv CommandInOrder.prototype.openTheTv = function() { this.command.open(); }; //原型链函数方法: 关闭Tv CommandInOrder.prototype.closeTheTv = function() { this.command.close(); }; function CommandInOrderOutput(command) { document.getElementById(&quot;open&quot;).onclick = function(e) { command.openTheTv(); //取消冒泡 e.stopImmediatePropagation(); }; document.getElementById(&quot;close&quot;).onclick = function(e) { command.closeTheTv(); //取消冒泡 e.stopImmediatePropagation(); } } //点击id为open的元素 //在这里打印: //open the Tv //点击id为close的元素 //在这里打印: //close the Tv CommandInOrderOutput(new CommandInOrder(Tv)); 接着是以闭包的方式导出 let Tv = { open() { console.log(&quot;open the Tv&quot;); }, close() { console.log(&quot;close the Tv&quot;); } }; //以闭包的方式导出 function CommandInOrder(command) { function openTheTv() { command.open(); } function closeTheTv() { command.close(); } return { openTheTv, closeTheTv } } function CommandInOrderOutput(command) { document.getElementById(&quot;open&quot;).onclick = function(e) { command.openTheTv(); //取消冒泡 e.stopImmediatePropagation(); }; document.getElementById(&quot;close&quot;).onclick = function(e) { command.closeTheTv(); //取消冒泡 e.stopImmediatePropagation(); }; } //点击id为open的元素 //在这里打印: //open the Tv //点击id为close的元素 //在这里打印: //close the Tv CommandInOrderOutput(CommandInOrder(Tv)); 高阶函数 回调高阶函数事例: xhr请求回调高阶函数 //xhr请求回调高阶函数 function xhr_request(callback) { let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;../data/code.json&quot;); xhr.onreadystatechange = function () { callback.apply(xhr, arguments); }; xhr.send(null); } //在这里打印: //{code: &quot;000000&quot;} xhr_request(function (e) { if(this.readyState === 4) { if(this.status === 200) { console.log(JSON.parse(this.responseText)); } } //取消冒泡 e.stopImmediatePropagation(); }); 回调函数高阶函数事例: 创建DOM节点回调高阶函数 //创建DOM节点回调高阶函数 function createDOMNode(callback) { for(let i = 0; i &lt; 10; i++) { let div = document.createElement(&quot;div&quot;); callback.call(div, i); document.body.appendChild(div); } } createDOMNode(function (number) { let text = document.createTextNode(number); this.appendChild(text); }); 闭包高阶函数: 单例模式 //单例函数 function getSingle(func) { let res; return function() { return res || (res = func.apply(this, arguments)); } } let Single = getSingle(function () { return document.createElement(&quot;script&quot;); }); let single_one = Single(); let single_two = Single(); //在这里打印: //true console.log(single_one === single_two); 闭包高阶函数: AOP装饰者模式 /** * 在某个函数之前执行 */ Function.prototype.before = function(before) { let self = this; return function() { before.apply(this, arguments); return self.apply(this, arguments); } }; /** * 在某个函数之后执行 */ Function.prototype.after = function(after) { let self = this; return function() { let res_func = self.apply(this, arguments); after.apply(this, arguments); return res_func; } }; function mid() { console.log(&quot;this is middle~&quot;); } //AOP装饰者模式完成并执行 let res = mid.before(function() { console.log(&quot;this is before~&quot;); }).after(function() { console.log(&quot;this is after~&quot;); }); //在这里打印: //this is before~ //this is middle~ //this is after~ res(); 高阶函数实用 curry化,柯里化高阶函数 /** * 柯里化高阶函数 */ function Currying() { let res_arr = []; function curry_result() { let m = 0; for(let i = 0; i &lt; arguments.length; i++) { m += arguments[i]; } return m; } return function() { if(arguments.length &gt; 0) { let args = Array.prototype.slice.call(arguments, 0); res_arr = [...res_arr, ...args]; } else { return curry_result.apply(this, ...res_arr); } } } let currying_res = Currying(); currying_res(300); currying_res(255); currying_res(244); currying_res(344); currying_res(88); //在这里打印: //1231 console.log(currying_res()); uncurry化,非柯里化高阶函数,直接将原型函数方法外用 /** * 非柯里化高阶函数 */ Function.prototype.uncurrying = function() { let self = this; return function() { let obj = Array.prototype.slice.call(arguments, 0, 1)[0], args = Array.prototype.slice.call(arguments, 1); return self.apply(obj, args); } }; let push = Array.prototype.push.uncurrying(); //在这里打印: //[1, 2, 3, 4] (function() { push(arguments, 4); console.log(arguments); })(1, 2, 3); let obj = { length: 3, 0: 1, 1: 2, 2: 3 }; push(obj, &quot;4&quot;); //在这里打印: //{0: 1, 1: 2, 2: 3, 3: &quot;4&quot;} console.log(obj); uncurry化拓展,非柯里化高阶函数 /** * 非柯里化高阶函数 */ Function.prototype.uncurrying = function() { let self = this; return function() { let obj = Array.prototype.slice.call(arguments, 0, 1)[0], args = Array.prototype.slice.call(arguments, 1); return self.apply(obj, args); } }; let method_arr = [&quot;push&quot;, &quot;shift&quot;, &quot;forEach&quot;]; for(let i = 0; i &lt; method_arr.length; i ++) { Array[method_arr[i]] = Array.prototype[method_arr[i]].uncurrying(); } let obj = { length: 3, 0: 1, 1: 2, 2: 3 }; Array.push(obj, &quot;44&quot;); //在这里打印: //{0: 1, 1: 2, 2: 3, 3: &quot;44&quot;, length: 4} console.log(obj); Array.shift(obj); //在这里打印: //{0: 2, 1: 3, 2: &quot;44&quot;, length: 3} console.log(obj); //在这里打印: //2 //3 //&quot;44&quot; Array.forEach(obj, function(item, index){ console.log(item); }); uncurry化拓展call与apply,非柯里化高阶函数 /** * 非柯里化高阶函数 */ Function.prototype.uncurrying = function() { let self = this; return function() { let obj = Array.prototype.slice.call(arguments, 0, 1)[0], args = Array.prototype.slice.call(arguments, 1); return self.apply(obj, args); } }; let call = Function.prototype.call.uncurrying(); let name = &quot;Gary&quot;; window.name = &quot;Clay&quot;; function introduce() { console.log(name); console.log(this.name); } //在这里打印: //&quot;Gary&quot; //&quot;Clay&quot; call(introduce, window); let apply = Function.prototype.apply.uncurrying(); function Gary_myself() { console.log(arguments); console.log(this.name); } //在这里打印: //[&quot;simon&quot;] //&quot;wenkai yin&quot; apply(Gary_myself, {name: &quot;wenkai yin&quot;}, [&quot;simon&quot;]); 函数节流高阶函数,我们在前面整理过函数节流,只是这次的函数节流与上次不同,这次在延时的时间内不能再执行调用方法的操作,只有等到延时处理器执行完才停止延时处理器,而上次无论是是否是在延时的时间内,只要再次执行调用方法的操作,就直接停止延时处理器 /** * 函数节流 */ function throttle(func, speed) { let first_time = true, timer; return function() { let self = this, args = arguments; if(first_time) { func.apply(self, args); first_time = false; } if(timer) { return false; } timer = setTimeout(function time() { clearTimeout(timer); timer = null; func.apply(self, args); }, speed); } } //在这里打印: //Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} //Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …} //800 window.onresize = throttle(function(e) { console.log(this); console.log(e); console.log(800); }, 800); 分时高阶函数,有时为了防止大量的DOM操作,比如一次性创建几万个DOM节点,一起添加到页面上,使得浏览器卡顿甚至是卡down,分时函数就是解决这个问题的比较不错的方法,将这几万个DOM节点,分为很多份,在一定的时间内,只去处理一份内的节点数据,添加到页面上,这样比较大的优化了浏览器的性能 /** * 分时函数 */ function timeShare(share_arr, func, count) { let timer, inner_arr = share_arr; function resolve_res() { for(let i = 1; i &lt;= Math.min(count || 1, inner_arr.length); i ++) { let inner_shift = inner_arr.shift(); func.call(this, inner_shift); } } return function() { let self = this, args = arguments; timer = setInterval(function time() { if(inner_arr.length &lt;= 0) { clearInterval(timer); timer = null; } resolve_res.apply(self, args); }, 100); } } let share_arr = Array.from(Array.apply(null, {length: 1000}), function map(item, index) { return index + 1; }); timeShare(share_arr, function(i) { let div = document.createElement(&quot;div&quot;), text = document.createTextNode(i); div.appendChild(text); document.body.appendChild(div); }, 8); 惰性加载高阶函数 /** * 普通惰性加载函数,调用时,每一次都要去判断哪种事件方式浏览器可用,这样虽对于性能没有什么大影响,但是还是很不优雅的 */ function addEvent(elem, type, func) { if(window.addEventListener) { elem.addEventListener(type, function() { func.apply(this, arguments); }); } if(window.attachEvent) { elem.attachEvent(`on${type}`, function() { func.apply(this, arguments); }); } } addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) { console.log(e.target); }); /** * 这样省去了在调用时的判断哪种事件方式浏览器可用,换成了在浏览器加载时判断,只判断一次,这样在调用时就可以直接使用判断后的事件方式了,但是假如页面没有使用到事件,还是进行了判断哪种事件方式浏览器可用,这样浪费了浏览器的性能,还是不能这样做的 */ let addEvent = (function (){ if(window.addEventListener) { return function(elem, type, func) { elem.addEventListener(type, function() { func.apply(this, arguments); }); } } if(window.attachEvent) { return function(elem, type, func) { elem.attachEvent(`on${type}`, function() { func.apply(this, arguments); }); } } })(); addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) { console.log(e.target); }); /** * 这样只有在第一次调用addEvent函数方法的时候,才回去判断哪种事件方式浏览器可用,在第一次调用之后,就直接将判断后的那种事件方式以另外一种函数方法的方式赋值给addEvent变量,然后再继续执行调用addEvent函数方法,再一次调用时,就不需要判断哪种方式浏览器可用了,直接调用第一次判断过后赋值给addEvent变量的函数方法即可,这就是惰性加载函数 */ let addEvent = function(elem, type, func) { let args = Array.prototype.slice.call(arguments); if(window.addEventListener) { addEvent = function(elem, type, func) { elem.addEventListener(type, function() { func.apply(this, arguments); }); } } if(window.attachEvent) { addEvent = function(elem, type, func) { elem.attachEvent(`on${type}`, function() { func.apply(this, arguments); }); } } addEvent(elem, type, func); }; addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) { console.log(e.target); });]]></content>
      <categories>
        <category>封装的一些小工具</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-30 webpack打包如何防止第三方依赖包体积过大造成打包速度慢的问题]]></title>
    <url>%2F2018%2F04%2F30%2Fwebpack%E6%89%93%E5%8C%85%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BF%87%E5%A4%A7%E9%80%A0%E6%88%90%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为何第三方依赖包会引起打包的体积过大 ES6的模块化机制,当引入外部第三方依赖包时,无论是否已经引入,都会再次将其引入进来,这时候就会存在重复引入导致打包体积过大、打包速度过慢的问题。 如何解决重复引入第三方依赖包,引起的打包体积过大以及打包速度过慢的问题 使用CommonsChunkPlugin提取公共模块,理想状态下是将第三方外部依赖包、业务代码、业务代码中的重复引入的公共部分和webpack的引导程序以及manifest 加载运行外部依赖包都分别打成一个包,减小打包体积,提高打包的速度。 const webpack = require(&quot;webpack&quot;), HtmlWebpackIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;), HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;; module.exports = { entry: { //login入口有引入testConfig.js以及reactConfig.js login: `${APP_DIR}/login.js`, //index入口也有引入testConfig.js以及reactConfig.js index: `${APP_DIR}/index.js`, //app入口没有引入testConfig.js,也没有引入reactConfig.js app: `${APP_DIR}/app.js`, //mobile入口有引入testConfig.js,却没有引入reactConfig.js mobile: `${APP_DIR}/mobule.js` }, plugins: [ //... //首先我想把四个入口中的公共模块,包括引入的第三方外部依赖包都提取出来 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;login.html&quot;, template: `${ROOT_DIR}/login.html`, chunks: [&quot;common&quot;, &quot;login&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;index.html&quot;, template: `${ROOT_DIR}/index.html`, chunks: [&quot;common&quot;, &quot;index&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;app.html&quot;, template: `${ROOT_DIR}/app.html`, chunks: [&quot;common&quot;, &quot;app&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;mobile.html&quot;, template: `${ROOT_DIR}/mobile.html`, chunks: [&quot;common&quot;, &quot;mobile&quot;], inject: &quot;body&quot; }) //发现这样行不通,打包之后,common.[hash].js中只有webpack引导程序以及manifest 加载运行模块的代码,公共部分并没有办法提取出来。 //后来查找原因,原来是CommonsChunkPlugin中的minChunks属性默认设置为公共模块部分最小在全部入口全部引入,才会被提取合成公共代码。 //知道了原因,那就简单了,直接设置minChunks: 2,也就是说只要公共模块最小在两个入口引入,就可以被提取出来作为公共模块部分。 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos;, minChunks: 2 }), ... //这样设置之后发现是可以的,将公共的第三方的外部依赖包、testConfig.js、reactConfig.js、webpack引导程序以及manifest 加载运行模块部分都提取出来,打包至common.[hash].js中,减小了打包的体积,加快了打包速度。 //试想假如我只想提取testConfig.js模块 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos;, //minChunks还可以是一个函数,接收两个参数,module是指入口所引入的每一个模块,count则是指module被几个入口所调用 //module有两个属性: context和resource //context: 模块所存储的目录位置 //resource: 模块所执行的文件名称 //这里就是使用resource模块所执行的文件名称去匹配testConfig,且模块至少被两个入口所引入,这样就可以单独提取testConfig.js文件了 minChunks: function(module, count) { return module.resource &amp;&amp; /testConfig/.test(module.resource) &amp;&amp; count &gt;= 2; } }), ... ], //将第三方公共依赖包与testConfig.js、reactConfig.js这种业务开发所使用的公共模块分离开,使得第三方公共依赖包分离在另一个包下 entry: { //login入口有引入testConfig.js以及reactConfig.js login: `${APP_DIR}/login.js`, //index入口也有引入testConfig.js以及reactConfig.js index: `${APP_DIR}/index.js`, //app入口没有引入testConfig.js,也没有引入reactConfig.js app: `${APP_DIR}/app.js`, //mobile入口有引入testConfig.js,却没有引入reactConfig.js mobile: `${APP_DIR}/mobule.js`, //设置一个第三方外部依赖包的入口 vendor: [&apos;react&apos;, &apos;react-redux&apos;, &apos;redux&apos;, &apos;react-router&apos;, &apos;redux-thunk&apos;, &apos;redux-logger&apos;, &apos;react-dom&apos;, &apos;react-addons&apos;, &apos;prop-types&apos;, &apos;moment&apos;, &apos;antd&apos;, &apos;babel-polyfill&apos;] }, plugins: [ ... //这里无论入口是否引入了vendor入口数组里面的第三方依赖包,它都会对数组里面的第三方外部依赖包进行提取,当然这里的第三方外部依赖包是有限制的,module.context在这里起到了作用,只有模块所存储的路径含有&quot;node_modules&quot;的情况下,也就是说只有是在npm下载的第三方外部依赖包,才会被提取出来。 new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, filename: &apos;js/vendor.[hash].js&apos;, minChunks: function(module, count) { return module.context &amp;&amp; module.context.includes(&quot;nodule_modules&quot;); } }), //这样提取第三方外部依赖包是可以的,直接提取到js文件夹里面的vendor.[hash].js //上面以及所有的提取的公共模块文件加hash的原因,是为了防止浏览器的永久缓存机制,使得文件更新过后,使用的还是原来文件的内容。 //提取出了第三方外部依赖包之后,由于想到它们不是业务代码,很少进行修改,尽量的多利用浏览器永久缓存机制,所以为了防止每一次构建都会引起它们hash值的改变,不能利用浏览器永久缓存机制,要把webpack引导程序以及manifest 加载运行文件提取到另一个模块包中。 //这里manifest就是隐藏的webpack引导程序以及manifest 加载和运行模块文件的入口 new webpack.optimize.CommonsChunkPlugin({ name: &apos;manifest&apos;, filename: &apos;js/manifest.[hash].js&apos;, minChunks: Infinity }), //这样提取webpack引导程序以及manifest 加载和运行文件是可以的,直接提取到js文件夹里面的manifest.[hash].js //再提取出业务使用的像testConfig.js、reactConfig.js公共模块,想着应该可以满足需求,业务代码的公共部分一个模块包,第三方外部依赖包一个模块包,以及webpack引导程序和manfiest 加载运行模块文件一个模块包 new webpack.optimize.CommonsChunkPlugin({ name: &apos;common&apos;, filename: &apos;js/common.[hash].js&apos;, minChunks: 2 }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;login.html&quot;, template: `${ROOT_DIR}/login.html`, chunks: [&quot;manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;login&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;index.html&quot;, template: `${ROOT_DIR}/index.html`, chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;index&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;app.html&quot;, template: `${ROOT_DIR}/app.html`, chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;app&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;mobile.html&quot;, template: `${ROOT_DIR}/mobile.html`, chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;mobile&quot;], inject: &quot;body&quot; }) //发现这样实现是不可以的,第三方外部依赖包的模块包,webpack引导程序以及manifest 加载和运行模块文件的模块包被打出来了。 //但是common.[hash].js中却没有至少两个入口共同引入业务代码公共模块的部分,还是被分别打进了业务代码模块包中。 //且common.[hash].js中的代码实际上是webpack运行文件以及manfiest 加载和运行模块的文件部分,manfiest.[hash].js也不见了,好像common.[hash].js替换掉了。 //原因到现在还没有找到... //CommonsChunkPlugin的缺点就在于:即使我使用了vendor的方式去提取公共的第三方外部依赖包模块,还是在每一次构建的时候,都会去进行打包,像我前面说的,第三方外部依赖包模块不像业务代码,很少进行修改。 //所以每一次都去进行打包,还是不妥当的,花费了很多时间在打包第三方外部依赖包上面。 ] }; 使用DllPlugin、DllReferencePlugin、CommonsChunkPlugin以及HtmlWebpackIncludeAssetsPlugin实现对第三方外部依赖包模块、业务代码公共模块以及webpack引导程序和manifest 加载和运行模块文件都分别打成一个包,减小打包体积,提高打包的速度。 //使用DllPlugin和DllReferencePlugin,就不需要像CommonsChunkPlugin那样,对于第三方外部依赖包模块,每次都要去构建打包了,只需要另外配置一个webpack配置文件,就可以实现一劳永逸的体验。 //只要没有下载新的第三方外部依赖包模块,就不需要利用webpack.dll.config配置文件去打dll包,总体上减少了每次都构建第三方外部依赖包模块的时间。 //webpack.dll.config配置 const webpack = require(&quot;webpack&quot;), path = require(&quot;path&quot;); const PUBLIC_DIR = &quot;/&quot;, DLL_DIR = path.resolve(__dirname, &quot;../dll&quot;), ROOT_DIR = path.resolve(__dirname, &quot;../..&quot;); const webpackDllConfig = { devtool: &quot;source-map&quot;, entry: { vendor: [&quot;react&quot;, &quot;react-router&quot;, &quot;redux&quot;, &quot;react-redux&quot;, &quot;redux-thunk&quot;, &quot;redux-logger&quot;, &quot;react-dom&quot;, &quot;react-addons&quot;, &quot;prop-types&quot;, &quot;antd&quot;, &quot;babel-polyfill&quot;] }, output: { publicPath: PUBLIC_DIR, path: DLL_DIR, filename: &quot;[name].dll.js&quot;, library: &quot;[name]_[chunkhash]&quot; }, plugins: [ //防止打包过程中出现错误,中断打包 new webpack.NoEmitOnErrorsPlugin(), //谈一下DllPlugin,DllPlugin的机制是根据webpack制定的id映射到vendor入口中的第三方外部依赖包模块的路径上,生成映射关系,打包后,生成vendor.dll.js文件和vendor_manifest.dll.json文件,这个文件的内容是webpack制定的id与vendor入口中的第三方外部依赖包模块的映射数据,之后再使用DllReferencePlugin将vendor_manifest.dll.json文件引入到业务代码打包的配置文件的manfiest 加载和运行模块文件中,最后只要将vendor.dll.js引入到你所选择的业务代码入口就可以了。 //vendor.dll.js的作用是,根据vendor_manifest.dll.json中webpack制定的id与vendor入口中第三方外部依赖包模块路径的映射关系,业务代码入口所引入的第三方外部依赖包模块,都会通过vendor.dll.js全局函数进行处理,并根据所引入的第三方外部依赖包模块的id进行使用,且这样并不会把库文件中的代码也打包进去 new webpack.DllPlugin({ path: path.join(DLL_DIR, &quot;[name]_manifest.dll.json&quot;), //name必须和output的library属性保持一致 name: &quot;[name]_[chunkhash]&quot;, context: ROOT_DIR }), //对打包代码进行压缩 new webpack.optimize.UglifyJsPlugin({ uglifyOptions: { sourceMap: true, compress: { unused: false, dead_code: false, warnings: true }, output: { comments: true } } }) ] }; export default webpackDllConfig; //业务代码webpack打包配置文件 const webpack = require(&quot;webpack&quot;), path = require(&quot;path&quot;), //用来复制目录或者目录下的文件的插件 CopyWebpackPlugin = require(&quot;copy-webpack-config&quot;), //用来将vendor.dll.js插入到业务代码入口的插件,但不可选择插入的入口业务代码文件,默认会将所有的入口业务代码都插入vendor.dll.js AddAssetHtmlPlugin = require(&quot;add-asset-html-webpack-plugin&quot;), //用来将vendor.dll.js插入到业务代码入口的插件,可选择插入的入口业务代码文件 HtmlWebpackIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;), HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;, ROOT_DIR = path.resolve(__dirname, &quot;../&quot;), BUILD_DIR = path.resolve(__dirname, &quot;../build&quot;), DLL_DIR = path.resolve(__dirname, &quot;../dll&quot;), IMAGE_DIR = path.resolve(__dirname, &quot;../images&quot;), MANIFEST_DIR = require(path.resolve(__dirname, `${DLL_DIR}/vendor_manifest.dll.json`)); const webpackProdConfig = { entry: { //login入口有引入testConfig.js以及reactConfig.js login: `${APP_DIR}/login.js`, //index入口也有引入testConfig.js以及reactConfig.js index: `${APP_DIR}/index.js`, //app入口没有引入testConfig.js,也没有引入reactConfig.js app: `${APP_DIR}/app.js`, //mobile入口有引入testConfig.js,却没有引入reactConfig.js mobile: `${APP_DIR}/mobule.js` }, ... plugins: [ ... //这里就是将vendor_manfiest.dll.json第三方外部依赖包模块引入到业务代码的打包配置文件的manifest 加载和运行模块文件中 new webpack.DllReferencePlugin({ manifest: MANIFEST_DIR, context: ROOT_DIR }), new CopyWebpackPlugin([{ context: ROOT_DIR, from: IMAGE_DIR, to: `${BUILD_DIR}/images` },{ context: ROOT_DIR, from: DLL_DIR, to: `${BUILD_DIR}/dll` }, { context: ROOT_DIR, from: &quot;./dll/vendor.dll.js&quot;, to: &quot;js/&quot; }]), //这里的AddAssetHtmlPlugin会将所有的业务代码入口都引入vendor.dll.js文件 //new AddAssetHtmlPlugin({ // filepath: &quot;js/vendor.dll.js&quot;, // hash: true //}), //这里的HtmlWebpackIncludeAssetsPlugin会有选择的将login、index、app入口文件引入vendor.dll.js,可实现按需加载 //append属性设置为false,是确保vendor.dll.js文件在业务代码包模块之前引入 new HtmlWebpackIncludeAssetsPlugin({ assets: [&quot;js/vendor.dll.js&quot;], files: [&quot;login.html&quot;, &quot;index.html&quot;, &quot;app.html&quot;], append: false, hash: true }), //这样第三方外部依赖包模块就生成了,当每次没有新的第三方外部依赖包模块下载时,就可以直接利用vendor.dll.js全局函数处理对引入的webpack制定的id与vendor_manfiest.dll.json中的第三方外部依赖包模块路径的映射进行调用 new webpack.optimize.CommonsChunkPlugin({ name: &quot;common&quot;, filename: &quot;js/common.[hash].js&quot;, minChunks: 2 }), //这里上面在CommonsChunkPlugin部分有介绍过,直接对业务代码中的公共模块部分进行提取,且至少在两个入口中有公共模块的引入 new webpack.optimize.CommonsChunkPlugin({ name: &quot;manifest&quot;, filename: &quot;js/manifest.[hash].js&quot;, minChunks: Infinity }), //再将webpack引导程序以及manfiest 加载运行模块文件从common.[hash].js文件中提取出来,这样就完成配置了 new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;login.html&quot;, template: `${ROOT_DIR}/login.html`, chunks: [&quot;manifest&quot;, &quot;common&quot;, &quot;login&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;index.html&quot;, template: `${ROOT_DIR}/index.html`, chunks: [manifest&quot;, &quot;common&quot;, &quot;index&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;app.html&quot;, template: `${ROOT_DIR}/app.html`, chunks: [manifest&quot;, &quot;common&quot;, &quot;app&quot;], inject: &quot;body&quot; }), new HtmlWebpackPlugin({ publicPath: PUBLIC_DIR, filename: &quot;mobile.html&quot;, template: `${ROOT_DIR}/mobile.html`, chunks: [manifest&quot;, &quot;common&quot;, &quot;mobile&quot;], inject: &quot;body&quot; }) ] }; 这种由DllPlugin、DllReferencePlugin和HtmlWebpackIncludAssetsPlugin(可实现按需加载)打包第三方外部依赖包模块,由CommonsChunkPlugin提取业务代码公共模块部分和webpack引导程序以及manifest 加载运行模块文件的方式,很好的实现了对第三方外部依赖包模块、业务代码公共模块以及webpack引导程序和manifest 加载和运行模块文件的打包,减小了打包体积,提高了打包的速度。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-30 关于闭包]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是回调函数 A函数作为B函数的参数,并在B函数中执行,A函数就是回调函数。 function setTimer(fn, timer) { fn(timer); } //function timer就是function setTimer的回调函数 setTimer(function timer(time) { console.log(time); }, 1000); 回调函数也分同步和异步,上例就是同步,而像setTimeout,setInterval中这种牵扯到消息队列(异步队列),Event Loop的回调函数来说,就是异步。 什么是闭包 “A函数中包含B函数,并返回B函数,调用B函数可以使用A函数作用域中定义的变量”,B函数就是闭包,示例如下: function foo() { let _name = &quot;Gary&quot;; function bar() { console.log(`name: ${_name}`); } return bar; } //foo函数执行之后,作用域会被销毁,随之而然的作用域中定义的变量应该会被销毁,并被引擎垃圾回收机制回收, //但是在这里神奇的事情发生了,foo函数作用域并没有被销毁之后回收,而是还存在于内存中,并被bar使用,这里就形成了闭包。 let bar = foo(); bar(); 还有一种形式是这样 function foo() { let _name = &quot;Gary&quot;; function bar() { console.log(`name: ${_name}`); } baz(bar); } //这里在foo函数执行之后,按理来说,foo函数中作用域,以及其中_name变量,都会被销毁,并随后被引擎垃圾回收机制回收。 //但是神奇的是,这里的作用域并没有被销毁,而其中的_name变量也没有被销毁,当然也没有被引擎垃圾回收机制回收,而还是存储于内存中,并被bar使用,这里就形成了闭包。 function baz(fn) { fn(); } foo();]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于异步]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是异步 异步在JS中的表现分为三类: 时间延迟,比如setTimeout,setInterval这种时间处理函数 事件处理,比如onClick(点击事件),onChange(输入框内容改变回调),onMouseover(鼠标移入事件),onMouseout(鼠标移出事件),onMouseEnter(鼠标移入事件),onMouseLeave(鼠标移出事件)等等 xhr、fetch请求等等 为什么会出现异步 由于JS是单线程(同一时间,只能做一件事情)的语言,为了实现时间延迟、事件处理和xhr、fetch请求处理这些必须是异步的操作,JS必须处理单线程怎样异步的问题。 为什么JS要使用单线程 JS使用单线程,是由于JS中不仅仅有ECMAScript,还有DOM(Document Object Modal),html渲染DOM,JS也可以动态改变DOM,假如JS不是单线程,同一时间可以处理多件事情,html渲染DOM和JS动态改变DOM就会混乱,浏览器会不知道是先渲染html DOM,还是先执行JS动态改变DOM,即使是实现了多线程的WebWorker,也没有触及DOM部分。 关于异步 JS使用单线程,运行时,先会运行同步代码,如果遇到异步代码,就会先将异步代码放进内存的异步队列中,待到同步代码运行完毕,就会去轮询异步队列中的异步代码。 假如异步闭包中还存在异步闭包,在异步队列中,就会将里层的异步闭包push到外层的异步闭包后面,待到外层的异步闭包执行完毕之后,再执行里层的异步闭包。 使用异步出现的问题 JS使用异步解决了JS单线程的问题,但是异步却又引起了另外一个问题,就是异步情况下的同步执行,尤其是xhr、fetch的请求,由于响应时间不确定,很容易引起异步执行混乱的问题。 异步的演变过程setTimeout callback 之前还没有使用nodejs的时候,解决异步问题基本上使用的是setTimeout使用异步闭包去解决异步的方式,比如在react中,setState就是异步执行的,假如name的初始值为Gary componentWillMount() { this.setState({ name: &quot;Yinwk&quot; }); this.setState({ name: &quot;CLAY&quot; }); //这时候由于setState是异步的,所以会先执行同步代码,也就是说这时候this.state.name的值依然为Gary console.log(this.state.name); } componentWillMount() { setTimeout(function timer(){ this.setState({ name: &quot;Yinwk&quot; }); //这时候this.state.name的值就变为了Yinwk console.log(this.state.name); setTimeout(function timer(){ this.setState({ name: &quot;CLAY&quot; }); //这时候this.state.name的值就变为了CLAY console.log(this.state.name); }.bind(this), 0); }.bind(this), 0) } EventEmitter(并不是异步问题的解决方案) nodejs出现之后,event模块有一个类——EventEmitter,一直以为它是一个消息管理模块,跟Event Loop异步队列有着千丝万缕的关系,后来看了源码,发现它并不是一个消息管理模块,跟消息队列没有任何关系,on/emit只是一个监听的观察者模式,on时添加/删除listener,emit时运行回调函数。还是拿上一个例子进行举例,假如name的初始值为Gary import {EventEmitter} from &quot;events&quot;; const eventEmitter = new EventEmitter(); componentWillMount(){ eventEmitter.on(&quot;gary&quot;, () =&gt; { this.setState({ name: &quot;Yinwk&quot; }); console.log(this.state.name); }); //这里打印出的this.state.name还是Gary,由于EventEmitter跟消息队列没有任何关系,所以并不是异步,只是一个监听的观察者模式,所以是同步的 eventEmitter.emit(&quot;gary&quot;); } Promise ES6语法发布之后,Promise成为了新的解决异步问题的方案,实质的也是利用异步闭包来解决异步问题。还是拿最初的例子进行举例,假如name的初始值为Gary ComponentWillMount() { (function iifeSetName() { return new Promise(function promise(resolve, reject) { this.setState({ name: &quot;Yinwk&quot; }); resolve(); }.bind(this)); }.bind(this))().then(function resolve() { //这里打印出的this.state.name就是Yinwk console.log(this.state.name); }.bind(this), function reject() { }.bind(this)); } yield and * 再到后来最新的解决异步的方案:yield *配合Promise,也就是Generator控制迭代器,执行时每执行到yield时,就会停止执行并返回一个Iterator迭代器,且会保留上下文,直到下次运行,社区tj大神的co函数同步读取文件就是使用了yield *配合Promise const fs = require(&quot;fs&quot;); function readFile(file){ return new Promise((resolve, reject) =&gt; { fs.readFile((err, data) =&gt; { if(err) reject(err); resolve(data); }); }); } function *gc() { let a = yield readFile(&quot;../data/file_first.txt&quot;); console.log(a); let b = yield readFile(&quot;../data/file_second.txt&quot;); console.log(b); return b; } co(gc).then(function resolve(data){ console.log(data); }.bind(this), function reject(){ }.bind(this)); //co函数利用yield * + Promise同步读取文件 function co(gc_co){ let gc = gc_co(); return new Promise((resolve, reject) =&gt; { //这里实现一个Generator控制迭代器的迭代循环 (function readData(data){ let gcNext = gc.next(data), value = gcNext.value, done = gcNext.done; if(done) { resolve(value); } else { value.then(readData, reject); } })(); }); } async and await 现如今的推出的解决异步问题的最终解决方案:async和await,很好的解决了异步的问题,且当await Promise时,返回的是fulfilled和rejected返回的结果。还是拿最初的例子进行举例,假如name的初始值为Gary ComponentWillMount() { (async function iifeSetName() { await this.setState({ name: &quot;Yinwk&quot; }); //这里打印出的this.state.name就是Yinwk await console.log(this.state.name); }.bind(this))(); } 还可以这样 ComponentWillMount() { (async function iifeSetName() { let name = await new Promise((resolve, reject) =&gt; { this.setState({ name: &quot;Yinwk&quot; }); resolve(); }).then(()=&gt;{ return this.state.name; }, ()=&gt;{ }); //这里打印出的this.state.name就是Yinwk await console.log(name); //这里打印出的this.state.name还是Yinwk await console.log(this.state.name); }.bind(this))(); }]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于webpack]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8Ewebpack%2F</url>
    <content type="text"><![CDATA[关于webpack 使用webpack已有大半年,从webpack 1.0直到4.0,都有尝试过,每次升级都比较痛苦,今天梳理一下不同点 webpack 1.0 webpack是现如今非常流行、易用语义化很明显的打包压缩工具,废话不多说,直接上代码(会有明确的注释)。PS：react使用的是CommonJS模块化语法 const webpack = require(&quot;webpack&quot;), //对于路径管理的外部依赖包 path = require(&quot;path&quot;), //自动添加css扩展头以兼容低版本浏览器的外部依赖包 autoprefixer = require(&quot;autoprefixer&quot;), //处理打包css的webpack plugin插件 ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;), //处理打包html的webpack plugin插件 HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;, //路径巡航,先进入webpack文件所在的路径,然后再进入根路径,我这里是把webpack配置文件放在了根路径底下的一个文件夹里面 ROOT_DIR = path.resolve(__dirname, &quot;../&quot;)]]></content>
      <categories>
        <category>webpack or webpack-dev-server</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>webpack-dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于webstorm]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8Ewebstorm%2F</url>
    <content type="text"><![CDATA[webstorm license server 从毕业就开始使用webstorm,从webstorm 11到webstorm 2017,再到现在的webstorm 2018,webstorm IDE功能越来越强大,但是我从来不使用正版,而今天就给大家介绍一下,在使用盗版过程中最大的困难——license server。在最初的时候,我也是百度的一些Activation code,后来发现这些Activation code极不稳定,可能是一个Activation code只能在一个终端使用吧,我放弃了使用Activation code的方式。 后来,在Webstorm吧找到了一种可以设置试用期到2099年的方法:改变本地的日期时间至2099年11月30日,然后安装webstorm,选择试用,试用期一个月,这时候你的试用期就到了2099年的12月31日。假如你已经安装了webstorm,直接找到WINDOWS系统,C:/Users(用户)/你的WINDOWS电脑用户名/.Webstorm2017.2/config/eval,直接将eval文件删掉,重新打开webstorm,更改本地日期,后面的操作就同上了。直到2017.3版本之前,使用的很舒服,到了2017.3版本,JetBrains发现了这个漏洞,进行了修补,由此也放弃了使用这种方式。 再之后,就开始使用license server,使用的license server如下: http://idea.imsxm.com (2017.3.3版本极其之前版本可用) http://idea.iteblog.com/key.php (2017.1可用) http://www.aku.vn/idea (2017.1可用) http://idea.ibdyr.com (2017.3.3版本极其之前版本可用) 再后来,就开始使用本地nginx反向代理http://idea.imsxm.com,将下面的配置放进server中: location /rpc { proxy_pass http://idea.imsxm.com/rpc; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 现在连本地nginx反向代理都失效了,jetbrains在2017.3.4版本使用了ip地址动态封禁,经过我很长时间的寻找,找到了现在在2018版本之后都可使用的license server: http://www.activejetbrains.ml 最新的license server转自网上的一篇文章,来源于https://www.imsxm.com/jetbrains-license-server.html]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react思想]]></title>
    <url>%2F2018%2F04%2F26%2Freact%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[React主体思想 React的主体思想:数据驱动。就是利用数据的变化,来引起View视图的变化。React使用的是jsx(js + xml)语法和虚拟DOM,虚拟DOM是React做的一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,来进行View视图的渲染,虚拟DOM节点发生变化时,React首先会利用diff算法对前后的虚拟DOM树进行对比,一旦发现有所不同,就会引起虚拟DOM从根结点进行重新刷新,而浏览器实际操作DOM的仅仅是diff部分,尽管每一次虚拟DOM都会从根结点进行重新刷新,但是由于是内存数据,所以性能很高,而浏览器实际操作DOM的仅仅是diff的部分,所以很大程度上提高了web网站的性能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-26 Javascript 0.1 + 0.2 !== 0.3]]></title>
    <url>%2F2018%2F04%2F26%2Fjavascript-0-1-0-2-0-3%2F</url>
    <content type="text"><![CDATA[为什么0.1 + 0.2 !== 0.3 Javascript的浮点数类型不够精确,双精度浮点数类型的二进制位数加上符号位为53位,也就是说0.1的二进制树加上0.2的二进制数,转化为十进制数为0.30000000000000004,所以0.1 + 0.2 !== 0.3 怎么解决0.1 + 0.2 !== 0.3的问题 最好的方法是设置一个误差”机器精度”的范围值,与0.1 + 0.2 - 0.3的值进行比较,假如不超过这个范围就返回true,如果超过这个范围就返回false,可以利用ES6给开发者提供的一个新属性EPSILON,这个属性正好等于2^-52,无限接近于0,但不等于0 0.1 + 0.2 - 0.3 &lt; Number.EPSILON 也可以利用保留小数的方式进行解决,比如toFixed和toPrecision parseFloat((0.1 + 0.2).toFixed(1)) === 0.3]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-25 react优化]]></title>
    <url>%2F2018%2F04%2F25%2Freact%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[React性能优化 由于React使用的虚拟DOM在其节点发生变化时,React会使用Diff算法对前后的虚拟DOM树进行对比,一旦发现不同,虚拟DOM树就会从根结点进行重新刷新,而浏览器进行实际操作DOM的仅仅是diff的部分,尽管每次虚拟DOM都会从根结点进行重新刷新,但是由于javascript是存储在内存中,所以性能很高,但是每一次都会从虚拟DOM的根结点进行重新刷新,会造成一些无谓的虚拟DOM树的重新刷新,比如父组件的虚拟DOM节点修改发生了变化,虚拟DOM节点根据diff算法进行对比之后,就会从虚拟DOM根结点进行重新刷新,但是其子组件并没有发生虚拟DOM的修改,这是子组件也会跟着父组件一起进行虚拟DOM树的diff算法对比和虚拟DOM节点的重新刷新,也耗费了比较多的时间。为了避免无谓的虚拟DOM树diff算法对比和虚拟DOM根结点的重新刷新,React给开发者提供了shouldComponentUpdate进行判断,shouldComponentUpdate是运行在虚拟DOM树diff算法对比和虚拟DOM树根结点重新渲染之前的,假如返回true就说明,数据发生了变化,需要进行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新,否则就返回false,不执行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新。 避免无谓的虚拟DOM树重新刷新 假如有一个组件仅仅渲染一个字符串,利用shouldComponentUpdate进行判断,避免无谓的虚拟DOM树重新刷新 class TextView extends React.Component{ static propTypes = { value: PropTypes.string.isRequired }; constructor(props){ super(props); this.state = { }; } shouldComponentUpdate(nextProps, nextState){ return this.props.value !== nextProps.value; } render(){ let {value} = this.props; return ( &lt;h1&gt; {value} &lt;/h1&gt; ) } }]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-25 react-router 3.0 browserHistory配置]]></title>
    <url>%2F2018%2F04%2F25%2Freact-router-3-0-browserHistory%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为什么推荐使用browserHistory,舍弃hashHistory 首先browserHistory从表现来看,比较舒服和语义化,更易读。 browserHistory使用的是HTML5的History API,根据路由路径的变化引起浏览器历史记录的变化;hashHistory则是依靠hash的改变,来使得浏览器的历史记录发生改变。hashHistory的hash部分不会请求到服务端,服务端获取不到URL的细节部分,而browserHistory使用的History API需要服务端的支持,服务端可以完全的掌握URL中的细节部分。 有一些浏览器会把hashHistory URL当中的hash部分删除掉,记起之前进行分享的时候,URL传到微信中,hash部分遭到丢失。 browserHistory配置 路由上面除了引入不同,基本上和hashHistory配置相同 import {Router, browserHistory} from &quot;react-router&quot;; &lt;Router history={browserHistory}&gt; &lt;/Router&gt; 配置路径为空时,callback的处理,使用webpack-dev-server时,在配置文件内部添加 historyApiFallback: true 使用nginx时,在配置文件内部添加 location / { root ... index index.html index.htm try_files $uri /index.html }]]></content>
      <categories>
        <category>react-router</category>
      </categories>
      <tags>
        <tag>react-router</tag>
        <tag>browserHistory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-24 react原理]]></title>
    <url>%2F2018%2F04%2F24%2Freact%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[React原理 React的主体思想:数据驱动。React根据数据的变化,使得View视图rerender,也就是重新渲染。React使用的是jsx(js + xml)语法和虚拟DOM,React引入虚拟DOM,是一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,使得View进行渲染,当虚拟DOM节点发生修改时,React使用diff算法进行比对,一旦发现不同,React虚拟DOM就会从根节点进行rerender,而浏览器实际的DOM操作仅仅是diff部分,尽管每次的虚拟DOM都是从根节点进行刷新,但由于是内存数据,性能很高,而浏览器实际的DOM操作仅仅是diff部分,从而很大程度上提高了web网站的性能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-24 hexo搭建自己的博客]]></title>
    <url>%2F2018%2F04%2F24%2Fhexo%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[git建库 首先要先建立一个以dreamthen(我的用户名).github.io结尾的repository,作为hexo托管代码的库,github默认.github.io结尾作为用户的网站二级域名。所以github用户搭建自己的个人网站很容易。 hexo安装 首先要用npm外部依赖包管理工具安装全局命令hexo-cli npm install hexo-cli -g 然后使用hexo初始化博客文件夹,比如blog文件夹 hexo init blog 之后,进入生成的blog文件夹,下载外部依赖包 npm i/npm install 最后启动hexo自身搭建的服务,生成本地的博客网站,默认端口在本地ip地址下的4000端口,假如你不想启动在4000端口,也可使用-p 其他端口号进行配置,比如-p 9977 hexo server hexo server -p 9977 默认的主题风格theme是landscape,假如你想更换,可以通过https://hexo.io/themes/进行筛选,筛选之后进行配置,主题配置见下文 hexo配置 hexo git配置 要想部署到自己搭建的个人网站github库里面,首先要下载hexo-git插件 npm install hexo-deployer-git --save 然后就要在你自己的本地hexo博客的项目里面,更改根目录底下的_config.yml文件,全局搜索git,更改deploy配置 deploy: type: git repo: git@github.com:dreamthen/dreamthen.github.io.git(你的个人网站github库的链接地址,最好使用git:开头的,https:开头的会报错) branch: master(分支名) hexo theme主题配置 筛选好自己选中的主题之后,就需要在项目里面进行配置更换。首先需要下载远程github库里面的主题项目到项目根目录里面的themes文件夹底下,比如本人用的是next主题的hexo git clone https://github.com/iissnan/hexo-theme-next.git themes/next 随后更改根目录里面的_config.yml文件,全局搜索theme,更改theme配置 theme: next 接着选择主题展示的方式,需要在主题的项目目录下,更改_config.yml文件,全局搜索Scheme,更改Scheme配置,比如next主题底下的Scheme配置 scheme: #scheme: Muse scheme: Mist #scheme: Pisces #scheme: Gemini hexo language语言配置 每个主题的语言都是根据作者的母语来配置的,要想配置开发者自己国家的语言,还是更改项目根目录底下的_config.yml文件,全局搜索language,更改language配置 language: zh-CN 再更改主题项目目录底下的language文件夹底下的zh-Hans.yml文件,将其重命名为zh-CN.yml,再更改其目录底下的_config.yml文件,全局搜索language,更改language配置 language: zh-CN hexo page 页面配置 hexo提供了几个可供筛选的页面,常用的有这么几个：home(首页)、tags(标签)、about(关于我)、archives(档案)和categories(分类),首先要创建页面 hexo new page tags hexo new page about hexo new page archives hexo new page categories 接着在主题项目目录下,更改_config.yml文件,全局搜索menu,更改menu配置,当然每个主题的配置不尽相同 menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 随后更改source目录底下创建的页面,以tags为例 ---------------------------- title: about date: 2018-04-24 17:57:26 type: &quot;tags&quot; comments: false ---------------------------- hexo avatar 头像配置 配置自己个人博客网站的头像,需要更改hexo博客项目底下的_config.yml文件,添加avatar配置 avatar: https://avatars1.githubusercontent.com/u/13704681?s=400&amp;u=bfc4636397a7c4384f63d4836a33d1797cd2c660&amp;v=4(头像url链接) hexo search 全站搜索配置 假如想要配置自己hexo个人博客网站的全站搜索配置,首先要下载hexo search外部依赖包 npm install hexo-generator-search --save npm install hexo-generator-searchdb --save 更改hexo博客项目根目录底下的_config.yml文件,添加search配置 search: path: search.xml field: post format: html limit: 10000 开启主题项目目录底下的_config.yml文件中的local_search配置 local_search: enable: true hexo new_post_name配置 假如想要更改每一篇博客的文件名称,不再是默认的:title.md的文件名,需要更改hexo博客项目根目录底下的_config.yml文件,更改new_post_name配置 new_post_name: :year-:month-:day-:title.md hexo auto_excerpt阅读全文配置 博客文章一般都会很长的,所以在首页要对博客进行超长截断,要想看所有的内容,点击阅读全文或者文章标题进入全文查看,需要更改主题项目目录底下的_config.yml文件,全局搜索auto_excerpt,更改auto_excerpt配置 auto_excerpt: enable: true length: 200 hexo 其他配置 更改hexo博客项目根目录底下的_config.yml文件,更改网站title(标题)、author(作者)、keywords(关键字)、description(描述)配置,比如本人的配置 title: yinwk_Gary Blog author: yinwk_Gary keywords: hexo,hexo-cli,hexo博客,hexo博客个人网站 description: Gary&apos;s blog,记录_从今天开始 设置个人的github(github托管代码网址)、google(google个人资料网址)、gmail(gmail邮箱网址)、twitter(twitter个人微博网址)等等,比如本人的配置 social: GitHub: https://github.com/dreamthen || github E-Mail: https://dreamthen.00@gmail.com || envelope Google: https://plus.google.com/u/0/103833130011211353424 || google #hexo命令 首先建立一篇名为hexo配置的博客 hexo new hexo配置 在hexo博客项目source目录底下的_post目录下找到名为hexo配置的博客文件,在里面用markdown进行记录自己的博客,当然可以在hexo server自带的服务器运行监听的情况下,进行添加和修改自己的博客。之后，进行生成静态文件 hexo generate 生成静态文件之后,进行部署 hexo deploy 生成静态文件和部署可以使用一句命令执行 hexo generate -deploy hexo deploy -generate 为了防止存在静态文件和缓存,造成没有重新渲染页面的问题,在每一次部署之前,要运行一下清理静态文件和缓存的命令 hexo clean hexo generate hexo deploy hexo deploy部署之后,根据hexo博客项目根目录底下_config.yml配置文件的deploy git配置,会提交到远程github repository库]]></content>
      <categories>
        <category>hexo博客搭建工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-cli</tag>
      </tags>
  </entry>
</search>
