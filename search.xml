<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018-04-30 webpack打包如何防止第三方依赖包体积过大造成打包速度慢的问题]]></title>
    <url>%2F2018%2F04%2F30%2Fwebpack%E6%89%93%E5%8C%85%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BF%87%E5%A4%A7%E9%80%A0%E6%88%90%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为何第三方依赖包会引起打包的体积过大 ES6的模块化机制,当引入外部第三方依赖包时,无论是否已经引入,都会再次将其引入进来,这时候就会存在重复引入导致打包体积过大、打包速度过慢的问题。 如何解决重复引入第三方依赖包,引起的打包体积过大以及打包速度过慢的问题 DllPlugin和DllReferencePlugin生成第三方manifest json api包,每次当项目中去引入api包所拥有的依赖包时,就会直接从api包中去获取,而不是直接将整个第三方依赖包代码重复引入多次。 CommonsChunkPlugin合并入口所属的页面所使用的所有的组件所使用的第三方依赖包,当引用时,也是从合并的包中去获取,而不是直接将整个第三方依赖包代码重复引入多次。 //在多个入口都引入第三方依赖包时,可以直接使用CommonsChunkPlugin提取公共代码,会直接将login.js和index.js中的公共部分提取出来,生成vendor.js公共部分和webpack运行文件包。 entry: { login: `${APP_DIR}/login.js`, index: `${APP_DIR}/index.js` }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, filename: &apos;vendor.js&apos; }) ] //在有的入口引入第三方依赖包,有的入口没有引入共同的第三方依赖包时,用CommonsChunkPlugin只会将webpack运行文件打包进去,只生成webpack运行文件包。 entry:{ login: `${APP_DIR}/login.js`, index: `${APP_DIR}/index.js` }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, filename: &apos;vendor.js&apos; }) ] //无论是一个入口,还是多个入口,假如有引入了vendor入口(前提是entry入口的chunk名称要与CommonsChunkPlugin中的name名称,也就是chunk名称一致)中的外部依赖包,就会被CommonsChunkPlugin当作公共组件代码部分提取出来,生成vendor.js第三方公共组件代码部分和webpack运行文件包。 //再可以运用CommonsChunkPlugin中的manifest名称,也就是chunk名称,将webpack运行文件提取出来,生成webpack运行文件包。 entry:{ login: `${APP_DIR}/login.js`, index: `${APP_DIR}/index.js`, &apos;vendor&apos;: [&apos;react&apos;, &apos;react-redux&apos;, &apos;redux&apos;, &apos;react-router&apos;, &apos;react-dom&apos;, &apos;react-addons&apos;, &apos;redux-thunk&apos;, &apos;redux-logger&apos;, &apos;redux-saga&apos;, &apos;antd&apos;, &apos;moment&apos;, &apos;prop-types&apos;] }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, filename: &apos;vendor.js&apos; }), new webpack.optimize.CommonsChunkPlugin({ name: &apos;manifest&apos;, chunks: [&apos;vendor&apos;] }) ]]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-30 关于闭包]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是回调函数 A函数作为B函数的参数,并在B函数中执行,A函数就是回调函数。 function setTimer(fn, timer) { fn(timer); } //function timer就是function setTimer的回调函数 setTimer(function timer(time) { console.log(time); }, 1000); 回调函数也分同步和异步,上例就是同步,而像setTimeout,setInterval中这种牵扯到消息队列(异步队列),Event Loop的回调函数来说,就是异步。 什么是闭包 “A函数中包含B函数,并返回B函数,调用B函数可以使用A函数作用域中定义的变量”,B函数就是闭包,示例如下: function foo() { let _name = &quot;Gary&quot;; function bar() { console.log(`name: ${_name}`); } return bar; } //foo函数执行之后,作用域会被销毁,随之而然的作用域中定义的变量应该会被销毁,并被引擎垃圾回收机制回收, //但是在这里神奇的事情发生了,foo函数作用域并没有被销毁之后回收,而是还存在于内存中,并被bar使用,这里就形成了闭包。 let bar = foo(); bar(); 还有一种形式是这样 function foo() { let _name = &quot;Gary&quot;; function bar() { console.log(`name: ${_name}`); } baz(bar); } //这里在foo函数执行之后,按理来说,foo函数中作用域,以及其中_name变量,都会被销毁,并随后被引擎垃圾回收机制回收。 //但是神奇的是,这里的作用域并没有被销毁,而其中的_name变量也没有被销毁,当然也没有被引擎垃圾回收机制回收,而还是存储于内存中,并被bar使用,这里就形成了闭包。 function baz(fn) { fn(); } foo();]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于异步]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是异步 异步在JS中的表现分为三类: 时间延迟,比如setTimeout,setInterval这种时间处理函数 事件处理,比如onClick(点击事件),onChange(输入框内容改变回调),onMouseover(鼠标移入事件),onMouseout(鼠标移出事件),onMouseEnter(鼠标移入事件),onMouseLeave(鼠标移出事件)等等 xhr、fetch请求等等 为什么会出现异步 由于JS是单线程(同一时间,只能做一件事情)的语言,为了实现时间延迟、事件处理和xhr、fetch请求处理这些必须是异步的操作,JS必须处理单线程怎样异步的问题。 为什么JS要使用单线程 JS使用单线程,是由于JS中不仅仅有ECMAScript,还有DOM(Document Object Modal),html渲染DOM,JS也可以动态改变DOM,假如JS不是单线程,同一时间可以处理多件事情,html渲染DOM和JS动态改变DOM就会混乱,浏览器会不知道是先渲染html DOM,还是先执行JS动态改变DOM,即使是实现了多线程的WebWorker,也没有触及DOM部分。 关于异步 JS使用单线程,运行时,先会运行同步代码,如果遇到异步代码,就会先将异步代码放进内存的异步队列中,待到同步代码运行完毕,就会去轮询异步队列中的异步代码。 假如异步闭包中还存在异步闭包,在异步队列中,就会将里层的异步闭包push到外层的异步闭包后面,待到外层的异步闭包执行完毕之后,再执行里层的异步闭包。 使用异步出现的问题 JS使用异步解决了JS单线程的问题,但是异步却又引起了另外一个问题,就是异步情况下的同步执行,尤其是xhr、fetch的请求,由于响应时间不确定,很容易引起异步执行混乱的问题。 异步的演变过程setTimeout callback 之前还没有使用nodejs的时候,解决异步问题基本上使用的是setTimeout使用异步闭包去解决异步的方式,比如在react中,setState就是异步执行的,假如name的初始值为Gary componentWillMount() { this.setState({ name: &quot;Yinwk&quot; }); this.setState({ name: &quot;CLAY&quot; }); //这时候由于setState是异步的,所以会先执行同步代码,也就是说这时候this.state.name的值依然为Gary console.log(this.state.name); } componentWillMount() { setTimeout(function timer(){ this.setState({ name: &quot;Yinwk&quot; }); //这时候this.state.name的值就变为了Yinwk console.log(this.state.name); setTimeout(function timer(){ this.setState({ name: &quot;CLAY&quot; }); //这时候this.state.name的值就变为了CLAY console.log(this.state.name); }.bind(this), 0); }.bind(this), 0) } EventEmitter(并不是异步问题的解决方案) nodejs出现之后,event模块有一个类——EventEmitter,一直以为它是一个消息管理模块,跟Event Loop异步队列有着千丝万缕的关系,后来看了源码,发现它并不是一个消息管理模块,跟消息队列没有任何关系,on/emit只是一个监听的观察者模式,on时添加/删除listener,emit时运行回调函数。还是拿上一个例子进行举例,假如name的初始值为Gary import {EventEmitter} from &quot;events&quot;; const eventEmitter = new EventEmitter(); componentWillMount(){ eventEmitter.on(&quot;gary&quot;, () =&gt; { this.setState({ name: &quot;Yinwk&quot; }); console.log(this.state.name); }); //这里打印出的this.state.name还是Gary,由于EventEmitter跟消息队列没有任何关系,所以并不是异步,只是一个监听的观察者模式,所以是同步的 eventEmitter.emit(&quot;gary&quot;); } Promise ES6语法发布之后,Promise成为了新的解决异步问题的方案,实质的也是利用异步闭包来解决异步问题。还是拿最初的例子进行举例,假如name的初始值为Gary ComponentWillMount() { (function iifeSetName() { return new Promise(function promise(resolve, reject) { this.setState({ name: &quot;Yinwk&quot; }); resolve(); }.bind(this)); }.bind(this))().then(function resolve() { //这里打印出的this.state.name就是Yinwk console.log(this.state.name); }.bind(this), function reject() { }.bind(this)); } yield and * 再到后来最新的解决异步的方案:yield *配合Promise,也就是Generator控制迭代器,执行时每执行到yield时,就会停止执行并返回一个Iterator迭代器,且会保留上下文,直到下次运行,社区tj大神的co函数同步读取文件就是使用了yield *配合Promise const fs = require(&quot;fs&quot;); function readFile(file){ return new Promise((resolve, reject) =&gt; { fs.readFile((err, data) =&gt; { if(err) reject(err); resolve(data); }); }); } function *gc() { let a = yield readFile(&quot;../data/file_first.txt&quot;); console.log(a); let b = yield readFile(&quot;../data/file_second.txt&quot;); console.log(b); return b; } co(gc).then(function resolve(data){ console.log(data); }.bind(this), function reject(){ }.bind(this)); //co函数利用yield * + Promise同步读取文件 function co(gc_co){ let gc = gc_co(); return new Promise((resolve, reject) =&gt; { //这里实现一个Generator控制迭代器的迭代循环 (function readData(data){ let gcNext = gc.next(data), value = gcNext.value, done = gcNext.done; if(done) { resolve(value); } else { value.then(readData, reject); } })(); }); } async and await 现如今的推出的解决异步问题的最终解决方案:async和await,很好的解决了异步的问题,且当await Promise时,返回的是fulfilled和rejected返回的结果。还是拿最初的例子进行举例,假如name的初始值为Gary ComponentWillMount() { (async function iifeSetName() { await this.setState({ name: &quot;Yinwk&quot; }); //这里打印出的this.state.name就是Yinwk await console.log(this.state.name); }.bind(this))(); } 还可以这样 ComponentWillMount() { (async function iifeSetName() { let name = await new Promise((resolve, reject) =&gt; { this.setState({ name: &quot;Yinwk&quot; }); resolve(); }).then(()=&gt;{ return this.state.name; }, ()=&gt;{ }); //这里打印出的this.state.name就是Yinwk await console.log(name); //这里打印出的this.state.name还是Yinwk await console.log(this.state.name); }.bind(this))(); }]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于webpack]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8Ewebpack%2F</url>
    <content type="text"><![CDATA[关于webpack 使用webpack已有大半年,从webpack 1.0直到4.0,都有尝试过,每次升级都比较痛苦,今天梳理一下不同点 webpack 1.0 webpack是现如今非常流行、易用语义化很明显的打包压缩工具,废话不多说,直接上代码(会有明确的注释)。PS：react使用的是CommonJS模块化语法 const webpack = require(&quot;webpack&quot;), //对于路径管理的外部依赖包 path = require(&quot;path&quot;), //自动添加css扩展头以兼容低版本浏览器的外部依赖包 autoprefixer = require(&quot;autoprefixer&quot;), //处理打包css的webpack plugin插件 ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;), //处理打包html的webpack plugin插件 HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const PUBLIC_DIR = &quot;/&quot;, //路径巡航,先进入webpack文件所在的路径,然后再进入根路径,我这里是把webpack配置文件放在了根路径底下的一个文件夹里面 ROOT_DIR = path.resolve(__dirname, &quot;../&quot;)]]></content>
      <categories>
        <category>webpack or webpack-dev-server</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>webpack-dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-27 关于webstorm]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%85%B3%E4%BA%8Ewebstorm%2F</url>
    <content type="text"><![CDATA[webstorm license server 从毕业就开始使用webstorm,从webstorm 11到webstorm 2017,再到现在的webstorm 2018,webstorm IDE功能越来越强大,但是我从来不使用正版,而今天就给大家介绍一下,在使用盗版过程中最大的困难——license server。在最初的时候,我也是百度的一些Activation code,后来发现这些Activation code极不稳定,可能是一个Activation code只能在一个终端使用吧,我放弃了使用Activation code的方式。 后来,在Webstorm吧找到了一种可以设置试用期到2099年的方法:改变本地的日期时间至2099年11月30日,然后安装webstorm,选择试用,试用期一个月,这时候你的试用期就到了2099年的12月31日。假如你已经安装了webstorm,直接找到WINDOWS系统,C:/Users(用户)/你的WINDOWS电脑用户名/.Webstorm2017.2/config/eval,直接将eval文件删掉,重新打开webstorm,更改本地日期,后面的操作就同上了。直到2017.3版本之前,使用的很舒服,到了2017.3版本,JetBrains发现了这个漏洞,进行了修补,由此也放弃了使用这种方式。 再之后,就开始使用license server,使用的license server如下: http://idea.imsxm.com (2017.3.3版本极其之前版本可用) http://idea.iteblog.com/key.php (2017.1可用) http://www.aku.vn/idea (2017.1可用) http://idea.ibdyr.com (2017.3.3版本极其之前版本可用) 再后来,就开始使用本地nginx反向代理http://idea.imsxm.com,将下面的配置放进server中: location /rpc { proxy_pass http://idea.imsxm.com/rpc; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 现在连本地nginx反向代理都失效了,jetbrains在2017.3.4版本使用了ip地址动态封禁,经过我很长时间的寻找,找到了现在在2018版本之后都可使用的license server: http://www.activejetbrains.ml 最新的license server转自网上的一篇文章,来源于https://www.imsxm.com/jetbrains-license-server.html]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react思想]]></title>
    <url>%2F2018%2F04%2F26%2Freact%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[React主体思想 React的主体思想:数据驱动。就是利用数据的变化,来引起View视图的变化。React使用的是jsx(js + xml)语法和虚拟DOM,虚拟DOM是React做的一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,来进行View视图的渲染,虚拟DOM节点发生变化时,React首先会利用diff算法对前后的虚拟DOM树进行对比,一旦发现有所不同,就会引起虚拟DOM从根结点进行重新刷新,而浏览器实际操作DOM的仅仅是diff部分,尽管每一次虚拟DOM都会从根结点进行重新刷新,但是由于是内存数据,所以性能很高,而浏览器实际操作DOM的仅仅是diff的部分,所以很大程度上提高了web网站的性能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-26 Javascript 0.1 + 0.2 !== 0.3]]></title>
    <url>%2F2018%2F04%2F26%2Fjavascript-0-1-0-2-0-3%2F</url>
    <content type="text"><![CDATA[为什么0.1 + 0.2 !== 0.3 Javascript的浮点数类型不够精确,双精度浮点数类型的二进制位数加上符号位为53位,也就是说0.1的二进制树加上0.2的二进制数,转化为十进制数为0.30000000000000004,所以0.1 + 0.2 !== 0.3 怎么解决0.1 + 0.2 !== 0.3的问题 最好的方法是设置一个误差”机器精度”的范围值,与0.1 + 0.2 - 0.3的值进行比较,假如不超过这个范围就返回true,如果超过这个范围就返回false,可以利用ES6给开发者提供的一个新属性EPSILON,这个属性正好等于2^-52,无限接近于0,但不等于0 0.1 + 0.2 - 0.3 &lt; Number.EPSILON 也可以利用保留小数的方式进行解决,比如toFixed和toPrecision parseFloat((0.1 + 0.2).toFixed(1)) === 0.3]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-25 react优化]]></title>
    <url>%2F2018%2F04%2F25%2Freact%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[React性能优化 由于React使用的虚拟DOM在其节点发生变化时,React会使用Diff算法对前后的虚拟DOM树进行对比,一旦发现不同,虚拟DOM树就会从根结点进行重新刷新,而浏览器进行实际操作DOM的仅仅是diff的部分,尽管每次虚拟DOM都会从根结点进行重新刷新,但是由于javascript是存储在内存中,所以性能很高,但是每一次都会从虚拟DOM的根结点进行重新刷新,会造成一些无谓的虚拟DOM树的重新刷新,比如父组件的虚拟DOM节点修改发生了变化,虚拟DOM节点根据diff算法进行对比之后,就会从虚拟DOM根结点进行重新刷新,但是其子组件并没有发生虚拟DOM的修改,这是子组件也会跟着父组件一起进行虚拟DOM树的diff算法对比和虚拟DOM节点的重新刷新,也耗费了比较多的时间。为了避免无谓的虚拟DOM树diff算法对比和虚拟DOM根结点的重新刷新,React给开发者提供了shouldComponentUpdate进行判断,shouldComponentUpdate是运行在虚拟DOM树diff算法对比和虚拟DOM树根结点重新渲染之前的,假如返回true就说明,数据发生了变化,需要进行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新,否则就返回false,不执行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新。 避免无谓的虚拟DOM树重新刷新 假如有一个组件仅仅渲染一个字符串,利用shouldComponentUpdate进行判断,避免无谓的虚拟DOM树重新刷新 class TextView extends React.Component{ static propTypes = { value: PropTypes.string.isRequired }; constructor(props){ super(props); this.state = { }; } shouldComponentUpdate(nextProps, nextState){ return this.props.value !== nextProps.value; } render(){ let {value} = this.props; return ( &lt;h1&gt; {value} &lt;/h1&gt; ) } }]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-25 react-router 3.0 browserHistory配置]]></title>
    <url>%2F2018%2F04%2F25%2Freact-router-3-0-browserHistory%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为什么推荐使用browserHistory,舍弃hashHistory 首先browserHistory从表现来看,比较舒服和语义化,更易读。 browserHistory使用的是HTML5的History API,根据路由路径的变化引起浏览器历史记录的变化;hashHistory则是依靠hash的改变,来使得浏览器的历史记录发生改变。hashHistory的hash部分不会请求到服务端,服务端获取不到URL的细节部分,而browserHistory使用的History API需要服务端的支持,服务端可以完全的掌握URL中的细节部分。 有一些浏览器会把hashHistory URL当中的hash部分删除掉,记起之前进行分享的时候,URL传到微信中,hash部分遭到丢失。 browserHistory配置 路由上面除了引入不同,基本上和hashHistory配置相同 import {Router, browserHistory} from &quot;react-router&quot;; &lt;Router history={browserHistory}&gt; &lt;/Router&gt; 配置路径为空时,callback的处理,使用webpack-dev-server时,在配置文件内部添加 historyApiFallback: true 使用nginx时,在配置文件内部添加 location / { root ... index index.html index.htm try_files $uri /index.html }]]></content>
      <categories>
        <category>react-router</category>
      </categories>
      <tags>
        <tag>react-router</tag>
        <tag>browserHistory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-24 react原理]]></title>
    <url>%2F2018%2F04%2F24%2Freact%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[React原理 React的主体思想:数据驱动。React根据数据的变化,使得View视图rerender,也就是重新渲染。React使用的是jsx(js + xml)语法和虚拟DOM,React引入虚拟DOM,是一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,使得View进行渲染,当虚拟DOM节点发生修改时,React使用diff算法进行比对,一旦发现不同,React虚拟DOM就会从根节点进行rerender,而浏览器实际的DOM操作仅仅是diff部分,尽管每次的虚拟DOM都是从根节点进行刷新,但由于是内存数据,性能很高,而浏览器实际的DOM操作仅仅是diff部分,从而很大程度上提高了web网站的性能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-24 hexo搭建自己的博客]]></title>
    <url>%2F2018%2F04%2F24%2Fhexo%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[git建库 首先要先建立一个以dreamthen(我的用户名).github.io结尾的repository,作为hexo托管代码的库,github默认.github.io结尾作为用户的网站二级域名。所以github用户搭建自己的个人网站很容易。 hexo安装 首先要用npm外部依赖包管理工具安装全局命令hexo-cli npm install hexo-cli -g 然后使用hexo初始化博客文件夹,比如blog文件夹 hexo init blog 之后,进入生成的blog文件夹,下载外部依赖包 npm i/npm install 最后启动hexo自身搭建的服务,生成本地的博客网站,默认端口在本地ip地址下的4000端口,假如你不想启动在4000端口,也可使用-p 其他端口号进行配置,比如-p 9977 hexo server hexo server -p 9977 默认的主题风格theme是landscape,假如你想更换,可以通过https://hexo.io/themes/进行筛选,筛选之后进行配置,主题配置见下文 hexo配置 hexo git配置 要想部署到自己搭建的个人网站github库里面,首先要下载hexo-git插件 npm install hexo-deployer-git --save 然后就要在你自己的本地hexo博客的项目里面,更改根目录底下的_config.yml文件,全局搜索git,更改deploy配置 deploy: type: git repo: git@github.com:dreamthen/dreamthen.github.io.git(你的个人网站github库的链接地址,最好使用git:开头的,https:开头的会报错) branch: master(分支名) hexo theme主题配置 筛选好自己选中的主题之后,就需要在项目里面进行配置更换。首先需要下载远程github库里面的主题项目到项目根目录里面的themes文件夹底下,比如本人用的是next主题的hexo git clone https://github.com/iissnan/hexo-theme-next.git themes/next 随后更改根目录里面的_config.yml文件,全局搜索theme,更改theme配置 theme: next 接着选择主题展示的方式,需要在主题的项目目录下,更改_config.yml文件,全局搜索Scheme,更改Scheme配置,比如next主题底下的Scheme配置 scheme: #scheme: Muse scheme: Mist #scheme: Pisces #scheme: Gemini hexo language语言配置 每个主题的语言都是根据作者的母语来配置的,要想配置开发者自己国家的语言,还是更改项目根目录底下的_config.yml文件,全局搜索language,更改language配置 language: zh-CN 再更改主题项目目录底下的language文件夹底下的zh-Hans.yml文件,将其重命名为zh-CN.yml,再更改其目录底下的_config.yml文件,全局搜索language,更改language配置 language: zh-CN hexo page 页面配置 hexo提供了几个可供筛选的页面,常用的有这么几个：home(首页)、tags(标签)、about(关于我)、archives(档案)和categories(分类),首先要创建页面 hexo new page tags hexo new page about hexo new page categories 接着在主题项目目录下,更改_config.yml文件,全局搜索menu,更改menu配置,当然每个主题的配置不尽相同 menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 随后更改source目录底下创建的页面,以tags为例 ---------------------------- title: about date: 2018-04-24 17:57:26 type: &quot;tags&quot; comments: false ---------------------------- hexo avatar 头像配置 配置自己个人博客网站的头像,需要更改hexo博客项目底下的_config.yml文件,添加avatar配置 avatar: https://avatars1.githubusercontent.com/u/13704681?s=400&amp;u=bfc4636397a7c4384f63d4836a33d1797cd2c660&amp;v=4(头像url链接) hexo search 全站搜索配置 假如想要配置自己hexo个人博客网站的全站搜索配置,首先要下载hexo search外部依赖包 npm install hexo-generator-search --save npm install hexo-generator-searchdb --save 更改hexo博客项目根目录底下的_config.yml文件,添加search配置 search: path: search.xml field: post format: html limit: 10000 开启主题项目目录底下的_config.yml文件中的local_search配置 local_search: enable: true hexo new_post_name配置 假如想要更改每一篇博客的文件名称,不再是默认的:title.md的文件名,需要更改hexo博客项目根目录底下的_config.yml文件,更改new_post_name配置 new_post_name: :year-:month-:day-:title.md hexo auto_excerpt阅读全文配置 博客文章一般都会很长的,所以在首页要对博客进行超长截断,要想看所有的内容,点击阅读全文或者文章标题进入全文查看,需要更改主题项目目录底下的_config.yml文件,全局搜索auto_excerpt,更改auto_excerpt配置 auto_excerpt: enable: true length: 200 hexo 其他配置 更改hexo博客项目根目录底下的_config.yml文件,更改网站title(标题)、author(作者)、keywords(关键字)、description(描述)配置,比如本人的配置 title: yinwk_Gary Blog author: yinwk_Gary keywords: hexo,hexo-cli,hexo博客,hexo博客个人网站 description: Gary&apos;s blog,记录_从今天开始 设置个人的github(github托管代码网址)、google(google个人资料网址)、gmail(gmail邮箱网址)、twitter(twitter个人微博网址)等等,比如本人的配置 social: GitHub: https://github.com/dreamthen || github E-Mail: https://dreamthen.00@gmail.com || envelope Google: https://plus.google.com/u/0/103833130011211353424 || google #hexo命令 首先建立一篇名为hexo配置的博客 hexo new hexo配置 在hexo博客项目source目录底下的_post目录下找到名为hexo配置的博客文件,在里面用markdown进行记录自己的博客,当然可以在hexo server自带的服务器运行监听的情况下,进行添加和修改自己的博客。之后，进行生成静态文件 hexo generate 生成静态文件之后,进行部署 hexo deploy 生成静态文件和部署可以使用一句命令执行 hexo generate -deploy hexo deploy -generate 为了防止存在静态文件和缓存,造成没有重新渲染页面的问题,在每一次部署之前,要运行一下清理静态文件和缓存的命令 hexo clean hexo generate hexo deploy hexo deploy部署之后,根据hexo博客项目根目录底下_config.yml配置文件的deploy git配置,会提交到远程github repository库]]></content>
      <categories>
        <category>hexo博客搭建工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-cli</tag>
      </tags>
  </entry>
</search>
